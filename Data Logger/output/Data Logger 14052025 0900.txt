// Basis map repository: "C:\Development\Projects\Afstudeeropdracht\Data Logger"
// Script uitgevoerd op: "05/14/2025 08:58:43"
// Inclusie relatieve mappen: Converters, Models, Services, ViewModels, Windows, Assets, Config, Core, Enums, Views, Opc.Ua.Client, .
// Exclusie subpad patronen (-like): \bin\, \obj\, \packages\, \.idea\, \.vs\, \.git\, \output\
// Bestanden verder gefilterd op toegestane extensies en bestandsnamen.

// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml"
<Application
    x:Class="Data_Logger.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:converters1="clr-namespace:Data_Logger.Converters"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Application.Resources>
        <converters1:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" xmlns:converters="clr-namespace:Data_Logger.Converters" />
    </Application.Resources>
</Application>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml.cs"
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Threading.Tasks;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services;
using Data_Logger.Services.Abstractions;
using Data_Logger.Services.Implementations;
using Data_Logger.ViewModels;
using Data_Logger.Views;
using Microsoft.Extensions.DependencyInjection;
using Opc.Ua;
using Opc.Ua.Configuration;
using Serilog;

namespace Data_Logger
{
    public partial class App
    {
        public IServiceProvider ServiceProvider { get; private set; }

        private ILoggingHostService _theActualLoggingHostService;

        private ApplicationConfiguration _opcUaAppConfig;

        public App()
        {
            _theActualLoggingHostService = new LoggingHostService();

            string logsDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
            if (!Directory.Exists(logsDirectory))
                Directory.CreateDirectory(logsDirectory);
            string logFilePath = Path.Combine(logsDirectory, "DataLoggerApp_.log");

            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Information()
                .WriteTo.Console()
                .WriteTo.File(
                    logFilePath,
                    rollingInterval: RollingInterval.Day,
                    retainedFileCountLimit: 7,
                    outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
                )
                .WriteTo.Sink(new UiLogSink(_theActualLoggingHostService))
                .CreateLogger();

            _opcUaAppConfig = CreateOpcUaApplicationConfiguration();

            var serviceCollection = new ServiceCollection();
            ConfigureServices(serviceCollection);
            ServiceProvider = serviceCollection.BuildServiceProvider();

            var loggerFromDI = ServiceProvider.GetService<ILogger>();
            loggerFromDI?.Information(
                "Applicatie initialisatie voltooid in App constructor (ServiceProvider is gebouwd)."
            );
        }

        private void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<ILogger>(Log.Logger);
            services.AddSingleton<ILoggingHostService>(_theActualLoggingHostService);

            services.AddSingleton<IStatusService, StatusService>();
            services.AddSingleton<ISettingsService, SettingsService>();
            services.AddSingleton<IDataLoggingService, DataLoggingService>();

            services.AddSingleton<ApplicationConfiguration>(_opcUaAppConfig);

            services.AddSingleton<LogViewModel>(serviceProvider => new LogViewModel(
                serviceProvider.GetRequiredService<ILoggingHostService>(),
                serviceProvider.GetRequiredService<ILogger>()
            ));

            services.AddTransient<Func<ModbusTcpConnectionConfig, IModbusService>>(
                serviceProvider =>
                    config => new ModbusService(
                        serviceProvider.GetRequiredService<ILogger>(),
                        config
                    )
            );

            services.AddTransient<Func<OpcUaConnectionConfig, IOpcUaService>>(serviceProvider =>
                config => new OpcUaService(
                    serviceProvider.GetRequiredService<ILogger>(),
                    config,
                    serviceProvider.GetRequiredService<ApplicationConfiguration>()
                )
            );

            services.AddSingleton<MainViewModel>(serviceProvider => new MainViewModel(
                serviceProvider.GetRequiredService<ILogger>(),
                serviceProvider.GetRequiredService<LogViewModel>(),
                serviceProvider.GetRequiredService<IStatusService>(),
                serviceProvider.GetRequiredService<ISettingsService>(),
                serviceProvider.GetRequiredService<Func<Action, SettingsViewModel>>(),
                serviceProvider.GetRequiredService<
                    Func<ModbusTcpConnectionConfig, IModbusService>
                >(),
                serviceProvider.GetRequiredService<Func<OpcUaConnectionConfig, IOpcUaService>>(),
                serviceProvider.GetRequiredService<IDataLoggingService>()
            ));

            services.AddTransient<Func<Action, SettingsViewModel>>(serviceProvider =>
                closeAction => new SettingsViewModel(
                    serviceProvider.GetRequiredService<ISettingsService>(),
                    serviceProvider.GetRequiredService<IStatusService>(),
                    serviceProvider.GetRequiredService<ILogger>(),
                    closeAction
                )
            );
        }

        protected override void OnStartup(StartupEventArgs e)
        {
            Log.Information("App.OnStartup: Begin van OnStartup.");

            var mainWindow = new MainWindow
            {
                DataContext = ServiceProvider.GetRequiredService<MainViewModel>(),
            };
            mainWindow.Show();

            Log.Debug("App.OnStartup: MainWindow getoond.");

            base.OnStartup(e);
        }

        private ApplicationConfiguration CreateOpcUaApplicationConfiguration()
        {
            var localLogger = Serilog.Log.Logger.ForContext<App>();

            string applicationName = "DataLogger";
            string hostName = Dns.GetHostName();

            string executableLocation = Assembly.GetExecutingAssembly().Location;
            string applicationDirectory = Path.GetDirectoryName(executableLocation);

            string certStoresBasePath = Path.Combine(applicationDirectory, "CertificateStores");
            string ownCertStorePath = Path.Combine(certStoresBasePath, "own");
            string trustedPeersStorePath = Path.Combine(certStoresBasePath, "trusted", "certs");
            string trustedIssuerStorePath = Path.Combine(certStoresBasePath, "issuer", "certs");
            string rejectedCertStorePath = Path.Combine(certStoresBasePath, "rejected", "certs");

            string trustedPeersCrlPath = Path.Combine(certStoresBasePath, "trusted", "crl");
            string trustedIssuerCrlPath = Path.Combine(certStoresBasePath, "issuer", "crl");

            localLogger.Information(
                "OPC UA Client Cert Store Base Path: {Path}",
                certStoresBasePath
            );

            var config = new ApplicationConfiguration
            {
                ApplicationName = applicationName,
                ApplicationUri = Utils.Format(@"urn:{0}:{1}", hostName, applicationName),
                ApplicationType = ApplicationType.Client,
                ProductUri = "urn:DataLogger:OpcUaClient",
                SecurityConfiguration = new SecurityConfiguration
                {
                    ApplicationCertificate = new CertificateIdentifier
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = ownCertStorePath,
                        SubjectName = Utils.Format(@"CN={0}, DC={1}", applicationName, hostName),
                    },
                    TrustedIssuerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = trustedIssuerStorePath,
                    },
                    TrustedPeerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = trustedPeersStorePath,
                    },
                    RejectedCertificateStore = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = rejectedCertStorePath,
                    },
                    AutoAcceptUntrustedCertificates = true,
                    AddAppCertToTrustedStore = true,
                    RejectSHA1SignedCertificates = false,
                    MinimumCertificateKeySize = 2048,
                },
                TransportConfigurations = new TransportConfigurationCollection(),
                TransportQuotas = new TransportQuotas { OperationTimeout = 15000 },
                ClientConfiguration = new ClientConfiguration { DefaultSessionTimeout = 60000 },
                TraceConfiguration = new TraceConfiguration
                {
                    OutputFilePath = Path.Combine(
                        applicationDirectory,
                        "Logs",
                        $"{applicationName}.OpcUaClient.log.txt"
                    ),
                    DeleteOnLoad = true,
                    TraceMasks =
                        Utils.TraceMasks.Error
                        | Utils.TraceMasks.Security
                        | Utils.TraceMasks.StackTrace,
                },
            };
            config.Validate(ApplicationType.Client).GetAwaiter().GetResult();

            if (config.SecurityConfiguration.AutoAcceptUntrustedCertificates)
            {
                config.CertificateValidator.CertificateValidation += (s, e) =>
                {
                    e.Accept = (e.Error.StatusCode == StatusCodes.BadCertificateUntrusted);
                };
            }

            var application = new ApplicationInstance
            {
                ApplicationName = "DataLogger",
                ApplicationType = ApplicationType.Client,
                ApplicationConfiguration = config,
            };

            application.CheckApplicationInstanceCertificates(false, 24).GetAwaiter().GetResult();

            return config;
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Log.CloseAndFlush();
            base.OnExit(e);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\BooleanToConnectionStatusConverter.cs"
using System;
using System.Globalization;
using System.Windows.Data;

namespace Data_Logger.Converters
{
    public class BooleanToConnectionStatusConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isConnected)
            {
                return isConnected ? "Verbonden" : "Niet Verbonden";
            }
            return "Onbekend";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\BooleanToForwardBackwardConverter.cs"
using System;
using System.Globalization;
using System.Windows.Data;

namespace Data_Logger.Converters;

public class BooleanToForwardBackwardConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool isForward)
        {
            return isForward ? "Forward" : "Inverse";
        }
        return string.Empty;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\InverseBooleanConverter.cs"
using System;

namespace Data_Logger.Converters;

public class InverseBooleanConverter : System.Windows.Data.IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        if (value is bool boolValue) return !boolValue;
        return value;
    }

    public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        if (value is bool boolValue) return !boolValue;
        return value;
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\ObservableObject.cs"
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Data_Logger.Core
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\RelayCommand.cs"
using System;
using System.Windows.Input;

namespace Data_Logger.Core
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;
        
        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }
        
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
        
        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ApplicationStatus.cs"
namespace Data_Logger.Enums
{
    public enum ApplicationStatus
    {
        Idle,        
        Connecting,  
        Logging,     
        Warning,     
        Error,       
        Loading,     
        Saving       
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ConnectionType.cs"
namespace Data_Logger.Enums
{
    public enum ConnectionType
    {
        OpcUa,
        ModbusTcp
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusDataType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusDataType
    {
        Boolean,

        Int16,
        UInt16,

        Int32,
        UInt32,
        Float32,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusRegisterType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusRegisterType
    {
        HoldingRegister,  
        InputRegister,    
        Coil,             
        DiscreteInput     
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\OpcUaDataType.cs"
namespace Data_Logger.Enums
{
    public enum OpcUaDataType
    {
        Variant,
        Boolean,
        SByte,
        Byte,
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,
        Double,
        String,
        DateTime,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\TagAlarmState.cs"
namespace Data_Logger.Enums;

public enum TagAlarmState
{
    Normal,

    High,

    HighHigh,

    Low,

    LowLow,

    Outlier,

    Error,
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\AppSettings.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;

namespace Data_Logger.Models
{
    public class AppSettings : ObservableObject
    {
        private ObservableCollection<ConnectionConfigBase> _connections;

        public ObservableCollection<ConnectionConfigBase> Connections
        {
            get => _connections;
            set => SetProperty(ref _connections, value);
        }

        public AppSettings()
        {
            Connections = new ObservableCollection<ConnectionConfigBase>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ConnectionConfigBase.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public abstract class ConnectionConfigBase : ObservableObject
    {
        private string _connectionName;
        private ConnectionType _type;
        private bool _isEnabled = true;
        private int _scanIntervalSeconds = 5;

        public string ConnectionName
        {
            get => _connectionName;
            set => SetProperty(ref _connectionName, value);
        }

        public ConnectionType Type
        {
            get => _type;
            protected set => SetProperty(ref _type, value);
        }

        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        public int ScanIntervalSeconds
        {
            get => _scanIntervalSeconds;
            set => SetProperty(ref _scanIntervalSeconds, value);
        }

        protected ConnectionConfigBase(ConnectionType type)
        {
            Type = type;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\LoggedTagValue.cs"
using System;
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class LoggedTagValue : ObservableObject
    {
        private string _tagName;
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private object _value;
        public object Value
        {
            get => _value;
            set
            {
                if (SetProperty(ref _value, value))
                {
                    OnPropertyChanged(nameof(FormattedValue));
                }
            }
        }

        private DateTime _timestamp;
        public DateTime Timestamp
        {
            get => _timestamp;
            set => SetProperty(ref _timestamp, value);
        }

        private bool _isGoodQuality = true;
        public bool IsGoodQuality
        {
            get => _isGoodQuality;
            set
            {
                if (SetProperty(ref _isGoodQuality, value))
                {
                    OnPropertyChanged(nameof(FormattedValue));
                }
            }
        }

        private string _errorMessage;
        public string ErrorMessage
        {
            get => _errorMessage;
            set
            {
                if (SetProperty(ref _errorMessage, value))
                {
                    OnPropertyChanged(nameof(FormattedValue));
                }
            }
        }

        public string FormattedValue
        {
            get
            {
                if (!IsGoodQuality)
                    return ErrorMessage ?? "Error";
                return Value?.ToString() ?? "N/A";
            }
        }

        private TagAlarmState _alarmState = TagAlarmState.Normal;
        public TagAlarmState AlarmState
        {
            get => _alarmState;
            set => SetProperty(ref _alarmState, value);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTagConfig.cs"



using Data_Logger.Core;
using Data_Logger.Enums;


namespace Data_Logger.Models
{
    public class ModbusTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe Modbus Tag"; 
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private ushort _address;
        public ushort Address
        {
            get => _address;
            set => SetProperty(ref _address, value);
        }

        private ModbusRegisterType _registerType = ModbusRegisterType.HoldingRegister;
        public ModbusRegisterType RegisterType
        {
            get => _registerType;
            set
            {
                if (SetProperty(ref _registerType, value))
                {
                    if (
                        _registerType == ModbusRegisterType.Coil ||
                        _registerType == ModbusRegisterType.DiscreteInput
                    )
                    {
                        
                        if (DataType != ModbusDataType.Boolean) 
                        {
                            DataType = ModbusDataType.Boolean;
                        }
                    }
                    OnPropertyChanged(nameof(IsDataTypeSelectionEnabled));
                }
            }
        }

        private ModbusDataType _dataType = ModbusDataType.UInt16;
        public ModbusDataType DataType
        {
            get => _dataType;
            set
            {
                
                if (RegisterType == ModbusRegisterType.Coil || RegisterType == ModbusRegisterType.DiscreteInput)
                {
                    if (value != ModbusDataType.Boolean) 
                    {
                        SetProperty(ref _dataType, ModbusDataType.Boolean, nameof(DataType));
                        return;
                    }
                }
                SetProperty(ref _dataType, value);
            }
        }

        public bool IsDataTypeSelectionEnabled =>
            RegisterType != ModbusRegisterType.Coil &&
            RegisterType != ModbusRegisterType.DiscreteInput;

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }

        
        private bool _isAlarmingEnabled;
        public bool IsAlarmingEnabled
        {
            get => _isAlarmingEnabled;
            set => SetProperty(ref _isAlarmingEnabled, value);
        }

        private double? _highHighLimit; 
        public double? HighHighLimit
        {
            get => _highHighLimit;
            set => SetProperty(ref _highHighLimit, value);
        }

        private double? _highLimit;
        public double? HighLimit
        {
            get => _highLimit;
            set => SetProperty(ref _highLimit, value);
        }

        private double? _lowLimit;
        public double? LowLimit
        {
            get => _lowLimit;
            set => SetProperty(ref _lowLimit, value);
        }

        private double? _lowLowLimit;
        public double? LowLowLimit
        {
            get => _lowLowLimit;
            set => SetProperty(ref _lowLowLimit, value);
        }

        private string _alarmMessageFormat = "{TagName} is in alarm ({AlarmState}) met waarde {Value}";
        public string AlarmMessageFormat
        {
            get => _alarmMessageFormat;
            set => SetProperty(ref _alarmMessageFormat, value);
        }

        
        private bool _isOutlierDetectionEnabled;
        public bool IsOutlierDetectionEnabled
        {
            get => _isOutlierDetectionEnabled;
            set => SetProperty(ref _isOutlierDetectionEnabled, value);
            
            
        }

        private int _baselineSampleSize = 20; 
        public int BaselineSampleSize
        {
            get => _baselineSampleSize;
            set => SetProperty(ref _baselineSampleSize, value);
        }

        private double _outlierStandardDeviationFactor = 3.0; 
        public double OutlierStandardDeviationFactor
        {
            get => _outlierStandardDeviationFactor;
            set => SetProperty(ref _outlierStandardDeviationFactor, value);
        }

        
        
        
        
        
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTcpConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTcpConnectionConfig : ConnectionConfigBase
    {
        private string _ipAddress = "127.0.0.1";
        private int _port = 502;
        private byte _unitId = 1;

        private ObservableCollection<ModbusTagConfig> _tagsToMonitor;
        public ObservableCollection<ModbusTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public string IpAddress
        {
            get => _ipAddress;
            set => SetProperty(ref _ipAddress, value);
        }

        public int Port
        {
            get => _port;
            set => SetProperty(ref _port, value);
        }

        public byte UnitId
        {
            get => _unitId;
            set => SetProperty(ref _unitId, value);
        }

        public ModbusTcpConnectionConfig()
            : base(ConnectionType.ModbusTcp)
        {
            ConnectionName = "Nieuwe Modbus TCP Verbinding";
            TagsToMonitor = new ObservableCollection<ModbusTagConfig>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;
using Data_Logger.Enums;
using Opc.Ua;

namespace Data_Logger.Models
{
    public class OpcUaConnectionConfig : ConnectionConfigBase
    {
        private string _endpointUrl = "opc.tcp://localhost:4840";
        public string EndpointUrl
        {
            get => _endpointUrl;
            set => SetProperty(ref _endpointUrl, value);
        }

        private MessageSecurityMode _securityMode = MessageSecurityMode.None;
        public MessageSecurityMode SecurityMode
        {
            get => _securityMode;
            set => SetProperty(ref _securityMode, value);
        }

        private string _securityPolicyUri = SecurityPolicies.None;
        public string SecurityPolicyUri
        {
            get => _securityPolicyUri;
            set => SetProperty(ref _securityPolicyUri, value);
        }

        private string _userName;
        public string UserName
        {
            get => _userName;
            set => SetProperty(ref _userName, value);
        }

        private string _password;
        public string Password
        {
            get => _password;
            set => SetProperty(ref _password, value);
        }

        private ObservableCollection<OpcUaTagConfig> _tagsToMonitor;
        public ObservableCollection<OpcUaTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public OpcUaConnectionConfig()
            : base(ConnectionType.OpcUa)
        {
            ConnectionName = "Nieuwe OPC UA Verbinding";
            TagsToMonitor = new ObservableCollection<OpcUaTagConfig>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaTagConfig.cs"
using System;
using System.Collections.Generic;
using Data_Logger.Core;
using Data_Logger.Enums;
using Newtonsoft.Json;

namespace Data_Logger.Models
{
    public class OpcUaTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe OPC UA Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private string _nodeId = "ns=2;s=MyVariable";
        public string NodeId
        {
            get => _nodeId;
            set => SetProperty(ref _nodeId, value);
        }

        private OpcUaDataType _dataType = OpcUaDataType.Variant;
        public OpcUaDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        private int _samplingInterval = 1000;
        public int SamplingInterval
        {
            get => _samplingInterval;
            set => SetProperty(ref _samplingInterval, value);
        }

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }

        private object _currentValue;
        public object CurrentValue
        {
            get => _currentValue;
            set
            {
                if (SetProperty(ref _currentValue, value))
                {
                    OnPropertyChanged(nameof(FormattedLiveValue));
                }
            }
        }

        private DateTime _timestamp;
        public DateTime Timestamp
        {
            get => _timestamp;
            set => SetProperty(ref _timestamp, value);
        }

        private bool _isGoodQuality = true;
        public bool IsGoodQuality
        {
            get => _isGoodQuality;
            set
            {
                if (SetProperty(ref _isGoodQuality, value))
                {
                    OnPropertyChanged(nameof(FormattedLiveValue));
                }
            }
        }

        private string _errorMessage;
        public string ErrorMessage
        {
            get => _errorMessage;
            set
            {
                if (SetProperty(ref _errorMessage, value))
                {
                    OnPropertyChanged(nameof(FormattedLiveValue));
                }
            }
        }

        public string FormattedLiveValue
        {
            get
            {
                if (!IsGoodQuality && !string.IsNullOrEmpty(ErrorMessage))
                    return ErrorMessage;
                if (!IsGoodQuality)
                    return "Bad Quality";
                return CurrentValue?.ToString() ?? "N/A";
            }
        }

        private bool _isAlarmingEnabled;
        public bool IsAlarmingEnabled
        {
            get => _isAlarmingEnabled;
            set => SetProperty(ref _isAlarmingEnabled, value);
        }

        private double? _highHighLimit;
        public double? HighHighLimit
        {
            get => _highHighLimit;
            set => SetProperty(ref _highHighLimit, value);
        }

        private double? _highLimit;
        public double? HighLimit
        {
            get => _highLimit;
            set => SetProperty(ref _highLimit, value);
        }

        private double? _lowLimit;
        public double? LowLimit
        {
            get => _lowLimit;
            set => SetProperty(ref _lowLimit, value);
        }

        private double? _lowLowLimit;
        public double? LowLowLimit
        {
            get => _lowLowLimit;
            set => SetProperty(ref _lowLowLimit, value);
        }

        private string _alarmMessageFormat =
            "{TagName} is in alarm ({AlarmState}) met waarde {Value}";
        public string AlarmMessageFormat
        {
            get => _alarmMessageFormat;
            set => SetProperty(ref _alarmMessageFormat, value);
        }

        private TagAlarmState _currentAlarmState = TagAlarmState.Normal;
        public TagAlarmState CurrentAlarmState
        {
            get => _currentAlarmState;
            set => SetProperty(ref _currentAlarmState, value);
        }

        private DateTime? _alarmTimestamp;
        public DateTime? AlarmTimestamp
        {
            get => _alarmTimestamp;
            set => SetProperty(ref _alarmTimestamp, value);
        }

        private bool _isOutlierDetectionEnabled;
        public bool IsOutlierDetectionEnabled
        {
            get => _isOutlierDetectionEnabled;
            set
            {
                if (SetProperty(ref _isOutlierDetectionEnabled, value))
                {
                    ResetBaselineState();
                }
            }
        }

        private int _baselineSampleSize = 20;
        public int BaselineSampleSize
        {
            get => _baselineSampleSize;
            set => SetProperty(ref _baselineSampleSize, value);
        }

        private double _outlierStandardDeviationFactor = 3.0;
        public double OutlierStandardDeviationFactor
        {
            get => _outlierStandardDeviationFactor;
            set => SetProperty(ref _outlierStandardDeviationFactor, value);
        }

        [JsonIgnore]
        public List<double> BaselineDataPoints { get; private set; } = new List<double>();

        [JsonIgnore]
        public bool IsBaselineEstablished { get; set; } = false;

        [JsonIgnore]
        public double BaselineMean { get; set; } = 0;

        [JsonIgnore]
        public double BaselineStandardDeviation { get; set; } = 0;

        public void ResetBaselineState()
        {
            BaselineDataPoints.Clear();
            IsBaselineEstablished = false;
            BaselineMean = 0;
            BaselineStandardDeviation = 0;
            CurrentBaselineCount = 0;
            SumOfValuesForBaseline = 0;
            SumOfSquaresForBaseline = 0;
            _logger?.Debug("Expanding baseline state gereset voor tag {TagName}", TagName);
        }

        [JsonIgnore]
        private Serilog.ILogger _logger = Serilog.Log.Logger.ForContext<OpcUaTagConfig>();

        [JsonIgnore]
        public int CurrentBaselineCount { get; set; } = 0;

        [JsonIgnore]
        public double SumOfValuesForBaseline { get; set; } = 0;

        [JsonIgnore]
        public double SumOfSquaresForBaseline { get; set; } = 0;
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\PlotDataPoint.cs"
using System;
using Data_Logger.Core;

namespace Data_Logger.Models;

public class PlotDataPoint : ObservableObject
{
    private DateTime _timestamp;
    public DateTime Timestamp
    {
        get => _timestamp;
        set => SetProperty(ref _timestamp, value);
    }

    private double _value;
    public double Value
    {
        get => _value;
        set => SetProperty(ref _value, value);
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\TagBaselineState.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using Serilog;

public class TagBaselineState
{
    public List<double> BaselineDataPoints { get; } = new List<double>();
    public bool IsBaselineEstablished { get; set; } = false;
    public double BaselineMean { get; set; } = 0;
    public double BaselineStandardDeviation { get; set; } = 0;
    private readonly ILogger _logger;
    private readonly string _tagName;

    public TagBaselineState(string tagName, ILogger logger = null)
    {
        _tagName = tagName;
        _logger = logger?.ForContext<TagBaselineState>().ForContext("MonitoredTag", tagName);
    }

    public void AddDataPoint(double value, int requiredSampleSize, out bool baselineJustEstablished)
    {
        baselineJustEstablished = false;
        if (IsBaselineEstablished)
            return;

        BaselineDataPoints.Add(value);
        _logger?.Debug(
            "Baseline voor {TagName}: datapunt {Count}/{Target} toegevoegd: {Value}",
            _tagName,
            BaselineDataPoints.Count,
            requiredSampleSize,
            value
        );

        if (BaselineDataPoints.Count >= requiredSampleSize)
        {
            if (requiredSampleSize > 0)
            {
                BaselineMean = BaselineDataPoints.Average();
                if (requiredSampleSize > 1)
                {
                    double sumOfSquaresOfDifferences = BaselineDataPoints
                        .Select(val => (val - BaselineMean) * (val - BaselineMean))
                        .Sum();
                    BaselineStandardDeviation = Math.Sqrt(
                        sumOfSquaresOfDifferences / (requiredSampleSize - 1)
                    );
                }
                else
                {
                    BaselineStandardDeviation = 0;
                }
            }
            IsBaselineEstablished = true;
            baselineJustEstablished = true;

            _logger?.Information(
                "Baseline vastgesteld voor tag {TagName}: Mean={Mean:F2}, StdDev={StdDev:F2} (samples={Samples})",
                _tagName,
                BaselineMean,
                BaselineStandardDeviation,
                requiredSampleSize
            );
        }
    }

    public void Reset()
    {
        BaselineDataPoints.Clear();
        IsBaselineEstablished = false;
        BaselineMean = 0;
        BaselineStandardDeviation = 0;
        _logger?.Debug("Baseline state gereset voor tag {TagName}", _tagName);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\UiLogEntry.cs"
using System;
using Serilog.Events;

namespace Data_Logger.Models
{
    public class UiLogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogEventLevel Level { get; set; }
        public string LevelDisplay => Level.ToString();
        public string Message { get; set; }
        public string RenderedMessage { get; set; }
        public string Exception { get; set; }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\UiLogSink.cs"
using System;
using System.IO;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog.Core;
using Serilog.Events;

namespace Data_Logger.Services
{
    public class UiLogSink : ILogEventSink
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly IFormatProvider _formatProvider;
        private bool _instanceIdLoggedFromEmit = false;

        public UiLogSink(
            ILoggingHostService loggingHostService,
            IFormatProvider formatProvider = null
        )
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _formatProvider = formatProvider;

            Console.WriteLine(
                $"[DIAGNOSTIC] UiLogSink Constructor: Gebruikt LoggingHostService met InstanceId: {_loggingHostService.InstanceId}"
            );
        }

        public void Emit(LogEvent logEvent)
        {
            if (!_instanceIdLoggedFromEmit)
            {
                Console.WriteLine(
                    $"[DIAGNOSTIC] UiLogSink.Emit: Eerste aanroep met LoggingHostService InstanceId: {_loggingHostService.InstanceId}"
                );
                _instanceIdLoggedFromEmit = true;
            }

            if (logEvent == null)
                return;

            var renderedMessage = RenderLogEvent(logEvent);

            var uiEntry = new UiLogEntry
            {
                Timestamp = logEvent.Timestamp.DateTime.ToLocalTime(),
                Level = logEvent.Level,
                Message = logEvent.MessageTemplate.Text,
                RenderedMessage = renderedMessage,
                Exception = logEvent.Exception?.ToString(),
            };

            _loggingHostService.AddLogEntry(uiEntry);
        }

        private string RenderLogEvent(LogEvent logEvent)
        {
            var writer = new StringWriter();
            logEvent.RenderMessage(writer, _formatProvider);
            if (logEvent.Exception != null)
            {
                writer.WriteLine();
                writer.Write(logEvent.Exception.ToString());
            }
            return writer.ToString();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IDataLoggingService.cs"
using System.Collections.Generic;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface IDataLoggingService
    {
        void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ILoggingHostService.cs"
using System.Collections.ObjectModel;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ILoggingHostService
    {
        string InstanceId { get; }

        ObservableCollection<UiLogEntry> LogEntries { get; }

        void AddLogEntry(UiLogEntry entry);

        void ClearLogs();
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IModbusService.cs"
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public class ModbusDataPoint
    {
        public ushort Address { get; set; }
        public ushort Value { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public interface IModbusService : IDisposable
    {
        bool IsConnected { get; }

        event EventHandler ConnectionStatusChanged;

        event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived; 

        Task<bool> ConnectAsync();

        Task DisconnectAsync();

        Task PollConfiguredTagsAsync();

        void Reconfigure(ModbusTcpConnectionConfig newConfig);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IOpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Models;
using Data_Logger.ViewModels;
using Opc.Ua;

namespace Data_Logger.Services.Abstractions
{
    public interface IOpcUaService : IDisposable
    {
        bool IsConnected { get; }

        NamespaceTable NamespaceUris { get; }

        event EventHandler ConnectionStatusChanged;

        event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        Task<bool> ConnectAsync();

        Task DisconnectAsync();

        void Reconfigure(OpcUaConnectionConfig newConfig);

        Task StartMonitoringTagsAsync();

        Task StopMonitoringTagsAsync();

        Task<IEnumerable<LoggedTagValue>> ReadCurrentTagValuesAsync();

        Task<ReferenceDescriptionCollection> BrowseAsync(
            NodeId nodeIdToBrowse,
            NodeId referenceTypeId = null,
            bool includeSubtypes = true,
            BrowseDirection direction = BrowseDirection.Forward,
            NodeClass nodeClassMask = NodeClass.Unspecified,
            CancellationToken ct = default
        );

        Task<ReferenceDescriptionCollection> BrowseRootAsync();

        Task<DataValue> ReadValueAsync(NodeId nodeId);

        Task<List<NodeAttributeViewModel>> ReadNodeAttributesAsync(NodeId nodeId);

        Task<ReferenceDescriptionCollection> BrowseAllReferencesAsync(
            NodeId nodeIdToBrowse,
            BrowseDirection direction = BrowseDirection.Both
        );

        Task<LocalizedText> ReadNodeDisplayNameAsync(NodeId nodeId);
        
        NodeId ParseNodeId(string nodeIdString);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ISettingsService.cs"
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ISettingsService
    {
        AppSettings CurrentSettings { get; }

        void LoadSettings();

        void SaveSettings();

        void LoadDefaultSettings();
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IStatusService.cs"
using Data_Logger.Enums;

namespace Data_Logger.Services.Abstractions
{
    public interface IStatusService
    {
        ApplicationStatus CurrentStatus { get; }

        string StatusMessage { get; }

        void SetStatus(ApplicationStatus status, string message);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\DataLoggingService.cs"
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class DataLoggingService : IDataLoggingService
    {
        private readonly ILogger _logger;
        private readonly string _baseLogDirectory;
        private readonly object _fileLock = new object();

        public DataLoggingService(ILogger logger)
        {
            _logger = logger.ForContext<DataLoggingService>();

            string executableLocation = Path.GetDirectoryName(
                System.Reflection.Assembly.GetExecutingAssembly().Location
            );
            _baseLogDirectory = Path.Combine(executableLocation, "LoggedData");

            try
            {
                if (!Directory.Exists(_baseLogDirectory))
                {
                    Directory.CreateDirectory(_baseLogDirectory);
                    _logger.Information(
                        "CSV Log data map aangemaakt: {LogDirectory}",
                        _baseLogDirectory
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het aanmaken van de CSV log data map: {LogDirectory}",
                    _baseLogDirectory
                );
            }
        }

        public void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues)
        {
            if (tagValues == null || !tagValues.Any())
            {
                return;
            }

            string sanitizedConnectionName = SanitizeFileName(connectionName);
            string fileName = $"{sanitizedConnectionName}_{DateTime.Now:yyyyMMdd}.csv";
            string filePath = Path.Combine(_baseLogDirectory, fileName);

            StringBuilder csvBuilder = new StringBuilder();
            bool fileExistsAndHasContent =
                File.Exists(filePath) && new FileInfo(filePath).Length > 0;

            if (!fileExistsAndHasContent)
            {
                csvBuilder.AppendLine("Timestamp,TagName,Value,IsGoodQuality,ErrorMessage");
            }

            foreach (var tagValue in tagValues)
            {
                string safeTagName = EscapeCsvField(tagValue.TagName);
                string safeValue = EscapeCsvField(tagValue.Value?.ToString() ?? string.Empty);
                string safeErrorMessage = EscapeCsvField(tagValue.ErrorMessage ?? string.Empty);

                csvBuilder.AppendFormat(
                    CultureInfo.InvariantCulture,
                    "{0},{1},{2},{3},{4}{5}",
                    tagValue.Timestamp.ToString(
                        "yyyy-MM-dd HH:mm:ss.fff",
                        CultureInfo.InvariantCulture
                    ),
                    safeTagName,
                    safeValue,
                    tagValue.IsGoodQuality,
                    safeErrorMessage,
                    Environment.NewLine
                );
            }

            string contentToWrite = csvBuilder.ToString();

            if (
                string.IsNullOrWhiteSpace(
                    contentToWrite
                        .Replace(
                            "Timestamp,TagName,Value,IsGoodQuality,ErrorMessage"
                                + Environment.NewLine,
                            ""
                        )
                        .Replace(Environment.NewLine, "")
                )
            )
            {
                if (!tagValues.Any() && !fileExistsAndHasContent)
                    return;
                if (
                    tagValues.Any()
                    && !fileExistsAndHasContent
                    && contentToWrite.StartsWith("Timestamp,TagName")
                )
                { /* Alleen header, wel schrijven als er data is */
                }
                else if (string.IsNullOrWhiteSpace(contentToWrite.Replace(Environment.NewLine, "")))
                {
                    return;
                }
            }

            try
            {
                lock (_fileLock)
                {
                    using (
                        FileStream stream = new FileStream(
                            filePath,
                            FileMode.Append,
                            FileAccess.Write,
                            FileShare.Read
                        )
                    )
                    using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8))
                    {
                        writer.Write(contentToWrite);
                    }
                }
                _logger.Debug(
                    "Data gelogd naar {FilePath} voor connectie {ConnectionName}. Aantal tags: {TagCount}",
                    filePath,
                    connectionName,
                    tagValues.Count()
                );
            }
            catch (IOException ioEx) when (IsFileLocked(ioEx))
            {
                _logger.Warning(
                    ioEx,
                    "CSV bestand {FilePath} is geblokkeerd (sharing violation/lock) tijdens poging tot schrijven. Data voor dit interval mogelijk niet gelogd.",
                    filePath
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout bij het wegschrijven van tag data naar CSV voor connectie {ConnectionName} naar bestand {FilePath}",
                    connectionName,
                    filePath
                );
            }
        }

        private bool IsFileLocked(IOException exception)
        {
            int errorCode = Marshal.GetHRForException(exception) & 0xFFFF;
            return errorCode == 32 || errorCode == 33;
        }

        private string SanitizeFileName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return "DefaultConnection";
            return Path.GetInvalidFileNameChars()
                .Aggregate(name, (current, c) => current.Replace(c.ToString(), string.Empty));
        }

        private string EscapeCsvField(string field)
        {
            if (string.IsNullOrEmpty(field))
                return string.Empty;
            if (
                field.Contains(",")
                || field.Contains("\"")
                || field.Contains("\r")
                || field.Contains("\n")
            )
            {
                return $"\"{field.Replace("\"", "\"\"")}\"";
            }
            return field;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\LoggingHostService.cs"
using System.Collections.ObjectModel;
using System.Threading;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;

namespace Data_Logger.Services.Implementations
{
    public class LoggingHostService : ILoggingHostService
    {
        public string InstanceId { get; }
        private static int _instanceCounter = 0;

        public ObservableCollection<UiLogEntry> LogEntries { get; }

        private const int MaxLogEntries = 1000;

        public LoggingHostService()
        {
            InstanceId = $"LHS_Instance_{Interlocked.Increment(ref _instanceCounter)}";

            LogEntries = new ObservableCollection<UiLogEntry>();
        }

        public void AddLogEntry(UiLogEntry entry)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (MaxLogEntries > 0 && LogEntries.Count >= MaxLogEntries)
                {
                    LogEntries.RemoveAt(LogEntries.Count - 1);
                }
                LogEntries.Insert(0, entry);
            });
        }

        public void ClearLogs()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                LogEntries.Clear();
            });
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\ModbusService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Modbus;
using Modbus.Device;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class ModbusService : IModbusService
    {
        private readonly ILogger _logger;
        private ModbusTcpConnectionConfig _config;
        private TcpClient _tcpClient;
        private ModbusIpMaster _master;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);

        private bool _isConnected;
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        public ModbusService(ILogger logger, ModbusTcpConnectionConfig config)
        {
            _logger = logger
                .ForContext<ModbusService>()
                .ForContext("ConnectionName", config.ConnectionName);
            _config = config;
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            _logger.Information(
                "Bezig met verbinden met Modbus server: {IpAddress}:{Port}",
                _config.IpAddress,
                _config.Port
            );
            try
            {
                _tcpClient = new TcpClient();
                Task connectTask = _tcpClient.ConnectAsync(_config.IpAddress, _config.Port);
                Task timeoutTask = Task.Delay(5000);

                Task completedTask = await Task.WhenAny(connectTask, timeoutTask);

                if (completedTask == connectTask)
                {
                    await connectTask;

                    if (_tcpClient.Connected)
                    {
                        _master = ModbusIpMaster.CreateIp(_tcpClient);
                        if (_master != null)
                        {
                            _master.Transport.ReadTimeout = 2000;
                            _master.Transport.WriteTimeout = 2000;
                            IsConnected = true;
                            _logger.Information("Succesvol verbonden met Modbus server.");
                            return true;
                        }
                        else
                        {
                            _logger.Error(
                                "Kon ModbusIpMaster niet aanmaken na succesvolle TCP verbinding."
                            );
                            _tcpClient?.Close();
                            _tcpClient = null;
                            IsConnected = false;
                            return false;
                        }
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon niet verbinden met Modbus server (ConnectAsync voltooid, maar niet verbonden). IP: {IpAddress}",
                            _config.IpAddress
                        );
                        _tcpClient?.Close();
                        _tcpClient = null;
                        IsConnected = false;
                        return false;
                    }
                }
                else
                {
                    _logger.Warning(
                        "Timeout ({Timeout}ms) tijdens verbinden met Modbus server: {IpAddress}:{Port}",
                        5000,
                        _config.IpAddress,
                        _config.Port
                    );

                    _tcpClient?.Close();
                    _tcpClient = null;
                    IsConnected = false;

                    return false;
                }
            }
            catch (SocketException sockEx)
            {
                _logger.Error(
                    sockEx,
                    "SocketException tijdens verbinden met Modbus server {IpAddress}:{Port}. Foutcode: {ErrorCode}",
                    _config.IpAddress,
                    _config.Port,
                    sockEx.SocketErrorCode
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout tijdens verbinden met Modbus server {IpAddress}:{Port}",
                    _config.IpAddress,
                    _config.Port
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;
            _logger.Information("Verbinding met Modbus server verbreken...");
            await _semaphore.WaitAsync().ConfigureAwait(false);
            try
            {
                _logger.Debug("DisconnectAsync: Semaphore verkregen. Resources sluiten.");

                _master?.Dispose();
                _tcpClient?.Close();
                _tcpClient?.Dispose();

                _master = null;
                _tcpClient = null;
                IsConnected = false;
                _logger.Information("Verbinding met Modbus server daadwerkelijk verbroken.");
            }
            catch (Exception ex)
            {
                _logger.Warning(
                    ex,
                    "Fout tijdens daadwerkelijk sluiten van Modbus resources in DisconnectAsync."
                );

                _master = null;
                _tcpClient = null;
                IsConnected = false;
            }
            finally
            {
                _semaphore.Release();
                _logger.Debug("DisconnectAsync: Semaphore vrijgegeven.");
            }
        }

        public void Reconfigure(ModbusTcpConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            _logger.Information(
                "Herconfigureren van ModbusService {ConnectionName} met nieuwe instellingen. Oude scan interval: {OldInterval}, Nieuw: {NewInterval}. Aantal oude tags: {OldTagCount}, Nieuw: {NewTagCount}",
                _config.ConnectionName,
                _config.ScanIntervalSeconds,
                newConfig.ScanIntervalSeconds,
                _config.TagsToMonitor.Count,
                newConfig.TagsToMonitor.Count
            );

            _config = newConfig;
        }

        public async Task PollConfiguredTagsAsync()
        {
            if (!IsConnected || _master == null)
            {
                _logger.Warning("Kan geconfigureerde tags niet pollen, niet verbonden.");
                return;
            }

            var results = new List<LoggedTagValue>();
            var now = DateTime.Now;

            foreach (var tag in _config.TagsToMonitor.Where(t => t.IsActive))
            {
                var loggedTag = new LoggedTagValue { TagName = tag.TagName, Timestamp = now };
                await _semaphore.WaitAsync();
                try
                {
                    object value = null;
                    ushort numRegistersToRead = 1;
                    if (
                        tag.DataType == ModbusDataType.Int32
                        || tag.DataType == ModbusDataType.UInt32
                        || tag.DataType == ModbusDataType.Float32
                    )
                    {
                        numRegistersToRead = 2;
                    }

                    switch (tag.RegisterType)
                    {
                        case ModbusRegisterType.Coil:
                            bool[] coilValues = await _master.ReadCoilsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (coilValues != null && coilValues.Length > 0)
                                value = coilValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Coil mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.DiscreteInput:
                            bool[] discreteValues = await _master.ReadInputsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (discreteValues != null && discreteValues.Length > 0)
                                value = discreteValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Discrete Input mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.HoldingRegister:
                            ushort[] holdingRegs = await _master.ReadHoldingRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (holdingRegs == null || holdingRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Holding Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(holdingRegs, tag.DataType);
                            break;

                        case ModbusRegisterType.InputRegister:
                            ushort[] inputRegs = await _master.ReadInputRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (inputRegs == null || inputRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Input Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(inputRegs, tag.DataType);
                            break;
                    }
                    loggedTag.Value = value;
                    loggedTag.IsGoodQuality = true;
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het lezen/interpreteren van Modbus tag: {TagName} (Adres: {Address}, Type: {RegisterType})",
                        tag.TagName,
                        tag.Address,
                        tag.RegisterType
                    );
                    loggedTag.IsGoodQuality = false;
                    loggedTag.ErrorMessage = ex.Message;
                }
                finally
                {
                    _semaphore.Release();
                }
                results.Add(loggedTag);
            }
            TagsDataReceived?.Invoke(this, results);
        }

        private object InterpretRegisterData(ushort[] registers, ModbusDataType dataType)
        {
            switch (dataType)
            {
                case ModbusDataType.Boolean:
                    return registers[0] != 0;
                case ModbusDataType.Int16:
                    return (short)registers[0];
                case ModbusDataType.UInt16:
                    return registers[0];

                case ModbusDataType.Int32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Int32.");

                    byte[] bytesInt32 = new byte[4];
                    bytesInt32[0] = (byte)(registers[0] >> 8);
                    bytesInt32[1] = (byte)(registers[0] & 0xFF);
                    bytesInt32[2] = (byte)(registers[1] >> 8);
                    bytesInt32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesInt32);
                    return BitConverter.ToInt32(bytesInt32, 0);

                case ModbusDataType.UInt32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor UInt32.");
                    byte[] bytesUInt32 = new byte[4];
                    bytesUInt32[0] = (byte)(registers[0] >> 8);
                    bytesUInt32[1] = (byte)registers[0];
                    bytesUInt32[2] = (byte)(registers[1] >> 8);
                    bytesUInt32[3] = (byte)registers[1];
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesUInt32);
                    return BitConverter.ToUInt32(bytesUInt32, 0);

                case ModbusDataType.Float32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Float32.");
                    byte[] bytesFloat32 = new byte[4];

                    bytesFloat32[0] = (byte)(registers[0] >> 8);
                    bytesFloat32[1] = (byte)(registers[0] & 0xFF);
                    bytesFloat32[2] = (byte)(registers[1] >> 8);
                    bytesFloat32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesFloat32);
                    return BitConverter.ToSingle(bytesFloat32, 0);

                default:
                    _logger.Warning(
                        "Niet-ondersteund ModbusDataType voor interpretatie: {DataType}. Geeft ruwe ushort[0] terug.",
                        dataType
                    );
                    return registers[0];
            }
        }

        private bool _disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (disposing)
            {
                _logger.Debug(
                    "ModbusService.Dispose({Disposing}) aangeroepen voor {ConnectionName}",
                    disposing,
                    _config.ConnectionName
                );

                bool acquired = false;
                try
                {
                    acquired = _semaphore.Wait(1000);
                    if (acquired)
                    {
                        _logger.Debug(
                            "ModbusService.Dispose: Semaphore verkregen. Resources sluiten."
                        );
                        _master?.Dispose();
                        _tcpClient?.Close();
                        _tcpClient?.Dispose();
                    }
                    else
                    {
                        _logger.Warning(
                            "ModbusService.Dispose: Timeout bij wachten op semaphore. Resources worden mogelijk niet correct vrijgegeven door deze Dispose aanroep."
                        );
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "ModbusService.Dispose: Fout bij vrijgeven resources.");
                }
                finally
                {
                    if (acquired)
                        _semaphore.Release();
                }

                _master = null;
                _tcpClient = null;
                IsConnected = false;

                _semaphore?.Dispose();
            }
            _disposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\OpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.ViewModels;
using Opc.Ua;
using Opc.Ua.Client;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class OpcUaService : IOpcUaService
    {
        #region Fields
        private readonly ILogger _logger;
        private OpcUaConnectionConfig _config;
        private Session _session;
        private Subscription _subscription;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);
        private readonly ApplicationConfiguration _appConfig;
        private bool _isConnected;

        private SessionReconnectHandler _reconnectHandler;
        private readonly object _sessionLock = new object();

        private const int InitialReconnectDelayMs = 2000;
        private const int MaxReconnectDelayMs = 30000;
        private Timer _reconnectTimer;
        #endregion

        #region Properties
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public NamespaceTable NamespaceUris => _session?.NamespaceUris;
        #endregion

        #region Events
        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;
        #endregion

        #region Constructor
        public OpcUaService(
            ILogger logger,
            OpcUaConnectionConfig config,
            ApplicationConfiguration appConfig
        )
        {
            _logger =
                logger
                    ?.ForContext<OpcUaService>()
                    .ForContext(
                        "ConnectionName",
                        config?.ConnectionName ?? "UnknownOpcUaConnection"
                    ) ?? throw new ArgumentNullException(nameof(logger));
            _config = config ?? throw new ArgumentNullException(nameof(config));
            _appConfig = appConfig ?? throw new ArgumentNullException(nameof(appConfig));
            _logger.Debug(
                "OpcUaService geïnstantieerd voor {ConnectionName}",
                _config.ConnectionName
            );
        }
        #endregion

        #region Connection Management
        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            await _semaphore.WaitAsync();
            try
            {
                if (IsConnected)
                    return true;

                _logger.Information(
                    "Bezig met verbinden met OPC UA server: {EndpointUrl} voor connectie {ConnectionName}",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );

                EndpointDescription endpointDescription = null;
                EndpointDescriptionCollection serverEndpoints = null;

                try
                {
                    var discoveryEndpointConfiguration = EndpointConfiguration.Create(_appConfig);
                    discoveryEndpointConfiguration.OperationTimeout = 5000;

                    using (
                        var discoveryClient = DiscoveryClient.Create(
                            _appConfig,
                            new Uri(_config.EndpointUrl),
                            discoveryEndpointConfiguration
                        )
                    )
                    {
                        _logger.Information(
                            "Probeert endpoints op te halen van {DiscoveryUrl} voor {ConnectionName}",
                            discoveryClient.Endpoint.EndpointUrl,
                            _config.ConnectionName
                        );
                        serverEndpoints = await discoveryClient
                            .GetEndpointsAsync(null)
                            .ConfigureAwait(false);
                        _logger.Information(
                            "{Count} endpoints ontvangen van server {EndpointUrl} voor {ConnectionName}.",
                            serverEndpoints?.Count ?? 0,
                            _config.EndpointUrl,
                            _config.ConnectionName
                        );
                    }

                    if (serverEndpoints == null || serverEndpoints.Count == 0)
                    {
                        _logger.Error(
                            "Geen endpoints ontvangen van server via {EndpointUrl} voor {ConnectionName}",
                            _config.EndpointUrl,
                            _config.ConnectionName
                        );
                        return false;
                    }

                    endpointDescription = CoreClientUtils.SelectEndpoint(
                        _appConfig,
                        new Uri(_config.EndpointUrl),
                        serverEndpoints,
                        _config.SecurityMode != MessageSecurityMode.None
                    );
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het ophalen of selecteren van het OPC UA endpoint voor {EndpointUrl} (Conn: {ConnectionName})",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );
                    return false;
                }

                if (endpointDescription == null)
                {
                    _logger.Error(
                        "Geen geschikt OPC UA endpoint gevonden voor {EndpointUrl} (Conn: {ConnectionName}) met huidige security instellingen.",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );
                    return false;
                }

                _logger.Information(
                    "Geselecteerd endpoint voor {ConnectionName}: {SelectedEndpointUrl}, SecurityMode: {SecurityMode}, SecurityPolicy: {SecurityPolicy}",
                    _config.ConnectionName,
                    endpointDescription.EndpointUrl,
                    endpointDescription.SecurityMode,
                    endpointDescription.SecurityPolicyUri
                );

                bool userSpecifiedSecurity =
                    !string.IsNullOrEmpty(_config.SecurityPolicyUri)
                    && _config.SecurityPolicyUri != SecurityPolicies.None;
                if (
                    userSpecifiedSecurity
                    && (
                        endpointDescription.SecurityMode != _config.SecurityMode
                        || endpointDescription.SecurityPolicyUri != _config.SecurityPolicyUri
                    )
                )
                {
                    _logger.Information(
                        "Gebruiker heeft specifieke security policy ({UserPolicy}) en mode ({UserMode}) opgegeven voor {ConnectionName}.",
                        _config.SecurityPolicyUri,
                        _config.SecurityMode,
                        _config.ConnectionName
                    );
                    var matchingEndpoint = serverEndpoints.FirstOrDefault(ep =>
                        IsEndpointUrlMatch(ep.EndpointUrl, endpointDescription.EndpointUrl)
                        && ep.SecurityMode == _config.SecurityMode
                        && ep.SecurityPolicyUri == _config.SecurityPolicyUri
                    );
                    if (matchingEndpoint != null)
                    {
                        endpointDescription = matchingEndpoint;
                        _logger.Information(
                            "Endpoint voor {ConnectionName} succesvol aangepast aan gebruikersspecificatie: Policy {SecurityPolicy}, Mode {SecurityMode}",
                            _config.ConnectionName,
                            endpointDescription.SecurityPolicyUri,
                            endpointDescription.SecurityMode
                        );
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon geen endpoint vinden voor {ConnectionName} dat exact overeenkomt met gespecificeerde SecurityMode '{UserMode}' en Policy '{UserPolicy}'. Valt terug op automatisch geselecteerd endpoint.",
                            _config.ConnectionName,
                            _config.SecurityMode,
                            _config.SecurityPolicyUri
                        );
                    }
                }

                var endpointConfiguration = EndpointConfiguration.Create(_appConfig);
                var configuredEndpoint = new ConfiguredEndpoint(
                    null,
                    endpointDescription,
                    endpointConfiguration
                );

                _session = await Session
                    .Create(
                        _appConfig,
                        configuredEndpoint,
                        updateBeforeConnect: false,
                        checkDomain: false,
                        sessionName: $"{_appConfig.ApplicationName} Session ({_config.ConnectionName})",
                        sessionTimeout: (uint)(
                            _appConfig.ClientConfiguration.DefaultSessionTimeout > 0
                                ? _appConfig.ClientConfiguration.DefaultSessionTimeout
                                : 60000
                        ),
                        identity: GetUserIdentity(),
                        preferredLocales: null
                    )
                    .ConfigureAwait(false);

                if (_session == null)
                {
                    _logger.Error(
                        "Kon geen OPC UA sessie aanmaken met {EndpointUrl} voor {ConnectionName}",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );
                    return false;
                }

                _session.KeepAlive += Session_KeepAlive;

                lock (_sessionLock)
                {
                    if (_reconnectHandler != null)
                    {
                        _reconnectHandler.Dispose();
                    }
                    _reconnectHandler = new SessionReconnectHandler(true, MaxReconnectDelayMs);
                }

                IsConnected = true;
                _logger.Information(
                    "Succesvol verbonden met OPC UA server: {EndpointUrl} voor {ConnectionName}",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );
                return true;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout bij verbinden met OPC UA server {EndpointUrl} (Conn: {ConnectionName})",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );
                IsConnected = false;
                _session?.Dispose();
                _session = null;
                return false;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;
            await _semaphore.WaitAsync();
            try
            {
                _logger.Information(
                    "Verbinding met OPC UA server verbreken: {EndpointUrl} (Conn: {ConnectionName})",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );
                await StopMonitoringTagsAsync();

                lock (_sessionLock)
                {
                    if (_reconnectHandler != null)
                    {
                        _reconnectHandler.Dispose();
                        _reconnectHandler = null;
                    }
                }

                _session?.Close();
                _session?.Dispose();
                _session = null;
                IsConnected = false;
                _logger.Information(
                    "Verbinding met OPC UA server verbroken voor {ConnectionName}.",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij verbreken van OPC UA verbinding voor {ConnectionName}.",
                    _config.ConnectionName
                );
                IsConnected = false;
                _session = null;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public void Reconfigure(OpcUaConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));
            _logger.Information(
                "Herconfigureren van OpcUaService {OldConnectionName} naar {NewConnectionName}. Endpoint: {NewEndpoint}",
                _config.ConnectionName,
                newConfig.ConnectionName,
                newConfig.EndpointUrl
            );

            bool endpointChanged =
                _config.EndpointUrl != newConfig.EndpointUrl
                || _config.SecurityMode != newConfig.SecurityMode
                || _config.SecurityPolicyUri != newConfig.SecurityPolicyUri
                || _config.UserName != newConfig.UserName
                || _config.Password != newConfig.Password;

            bool monitoringParametersChanged = false;
            if (!endpointChanged)
            {
                monitoringParametersChanged = HaveMonitoringParametersChanged(
                    _config.TagsToMonitor,
                    newConfig.TagsToMonitor
                );
            }

            _config = newConfig;

            if (IsConnected)
            {
                if (endpointChanged)
                {
                    _logger.Information(
                        "Endpoint parameters gewijzigd voor {ConnectionName}, verbinding wordt herstart.",
                        _config.ConnectionName
                    );
                    Task.Run(async () =>
                    {
                        await DisconnectAsync();
                        await ConnectAsync();
                    });
                }
                else if (monitoringParametersChanged)
                {
                    _logger.Information(
                        "OPC UA monitoring parameters (NodeIds, SamplingIntervals, Actieve status) gewijzigd voor {ConnectionName}, herstart monitoring.",
                        _config.ConnectionName
                    );
                    Task.Run(async () =>
                    {
                        await StopMonitoringTagsAsync();
                        await StartMonitoringTagsAsync();
                    });
                }
                else
                {
                    _logger.Information(
                        "Alleen client-side tag parameters (bijv. alarmgrenzen) gewijzigd voor {ConnectionName}. OPC UA Subscription wordt NIET herstart.",
                        _config.ConnectionName
                    );
                }
            }
        }

        private bool HaveMonitoringParametersChanged(
            ObservableCollection<OpcUaTagConfig> oldTags,
            ObservableCollection<OpcUaTagConfig> newTags
        )
        {
            var oldActiveMonitoringParams = oldTags
                .Where(t => t.IsActive)
                .Select(t => new { t.NodeId, t.SamplingInterval })
                .OrderBy(t => t.NodeId)
                .ToList();

            var newActiveMonitoringParams = newTags
                .Where(t => t.IsActive)
                .Select(t => new { t.NodeId, t.SamplingInterval })
                .OrderBy(t => t.NodeId)
                .ToList();

            if (!oldActiveMonitoringParams.SequenceEqual(newActiveMonitoringParams))
            {
                return true;
            }

            return false;
        }

        private IUserIdentity GetUserIdentity()
        {
            if (!string.IsNullOrEmpty(_config.UserName))
            {
                return new UserIdentity(_config.UserName, _config.Password ?? string.Empty);
            }
            return new UserIdentity();
        }

        private bool IsEndpointUrlMatch(string urlFromServerList, string selectedUrl)
        {
            if (string.Equals(urlFromServerList, selectedUrl, StringComparison.OrdinalIgnoreCase))
                return true;
            try
            {
                var uriFromServer = new Uri(urlFromServerList);
                var uriSelected = new Uri(selectedUrl);
                return uriFromServer.Scheme == uriSelected.Scheme
                    && string.Equals(
                        uriFromServer.DnsSafeHost,
                        uriSelected.DnsSafeHost,
                        StringComparison.OrdinalIgnoreCase
                    )
                    && uriFromServer.Port == uriSelected.Port;
            }
            catch (UriFormatException)
            {
                return false;
            }
        }

        private void Session_KeepAlive(ISession session, KeepAliveEventArgs e)
        {
            lock (_sessionLock)
            {
                if (
                    session == null
                    || _session == null
                    || session.SessionId != _session.SessionId
                    || _reconnectHandler == null
                )
                {
                    return;
                }

                if (ServiceResult.IsBad(e.Status))
                {
                    _logger.Warning(
                        "OPC UA Sessie KeepAlive mislukt voor {ConnectionName}: {Status}. Server status: {CurrentState}. Start Reconnect.",
                        _config.ConnectionName,
                        e.Status,
                        e.CurrentState
                    );

                    IsConnected = false;

                    if (_reconnectHandler.State == SessionReconnectHandler.ReconnectState.Ready)
                    {
                        _logger.Information(
                            "Session_KeepAlive: Reconnect wordt gestart met initiële vertraging {InitialReconnectDelayMs}ms omdat de handler 'Ready' is.",
                            InitialReconnectDelayMs
                        );
                        _reconnectHandler.BeginReconnect(
                            _session,
                            InitialReconnectDelayMs,
                            Client_ReconnectComplete
                        );
                    }
                    else
                    {
                        _logger.Debug(
                            "Session_KeepAlive: Reconnect NIET opnieuw gestart. Handler is al bezig of niet in de juiste staat. Huidige staat handler: {CurrentState}.",
                            _reconnectHandler.State
                        );
                    }

                    return;
                }

                _logger.Debug(
                    "OPC UA Sessie KeepAlive succesvol ontvangen voor {ConnectionName}. Server status: {CurrentState}",
                    _config.ConnectionName,
                    e.CurrentState
                );
            }
        }

        private void Client_BeginReconnect(object sender, EventArgs e)
        {
            if (sender is SessionReconnectHandler handler)
            {
                _logger.Information(
                    "Client_BeginReconnect: Reconnect proces gestart voor sessie. Huidige staat handler: {State}",
                    handler.State
                );
            }
        }

        private void Client_ReconnectComplete(object sender, EventArgs e)
        {
            lock (_sessionLock)
            {
                if (_reconnectHandler == null || !Object.ReferenceEquals(sender, _reconnectHandler))
                {
                    _logger.Debug(
                        "Client_ReconnectComplete: Callback van een oude of ongeldige ReconnectHandler genegeerd."
                    );
                    return;
                }

                _logger.Information(
                    "Client_ReconnectComplete: Reconnect poging voltooid. Nieuwe sessie staat: {SessionState}",
                    _reconnectHandler.Session?.SessionName ?? "NULL"
                );

                if (_reconnectHandler.Session != null && _reconnectHandler.Session.Connected)
                {
                    if (!Object.ReferenceEquals(_session, _reconnectHandler.Session))
                    {
                        _logger.Information(
                            "Nieuwe sessie instantie ({NewSessionName}) na reconnect. Oude sessie ({OldSessionName}) wordt opgeruimd.",
                            _reconnectHandler.Session.SessionName,
                            _session?.SessionName ?? "NULL"
                        );

                        if (_session != null)
                        {
                            _session.KeepAlive -= Session_KeepAlive;
                            Utils.SilentDispose(_session);
                        }
                        _session = (Session)_reconnectHandler.Session;
                        _session.KeepAlive += Session_KeepAlive;
                    }
                    else
                    {
                        _logger.Information(
                            "Bestaande sessie ({SessionName}) is gereactiveerd na reconnect.",
                            _session.SessionName
                        );

                        _session.KeepAlive -= Session_KeepAlive;
                        _session.KeepAlive += Session_KeepAlive;
                    }

                    IsConnected = true;
                    _logger.Information(
                        "Succesvol herverbonden met OPC UA server: {EndpointUrl} voor {ConnectionName}",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );

                    _logger.Information("Start monitoring opnieuw na succesvolle reconnect...");
                    Task.Run(async () =>
                        {
                            await StopMonitoringTagsAsync();
                            await StartMonitoringTagsAsync();
                        })
                        .ContinueWith(t =>
                        {
                            if (t.IsFaulted)
                            {
                                _logger.Error(
                                    t.Exception,
                                    "Fout tijdens herstarten monitoring na reconnect."
                                );
                            }
                        });
                }
                else
                {
                    _logger.Error(
                        "Client_ReconnectComplete: Herverbinden met OPC UA server MISLUKT voor {ConnectionName}. Sessie niet verbonden.",
                        _config.ConnectionName
                    );
                }
            }
        }
        #endregion

        #region Tag Monitoring (Subscriptions)
        public async Task StartMonitoringTagsAsync()
        {
            if (!IsConnected || _session == null)
            {
                _logger.Information(
                    "Kan monitoring niet starten voor {ConnectionName}: niet verbonden of geen sessie.",
                    _config.ConnectionName
                );
                return;
            }
            if (
                _config == null
                || _config.TagsToMonitor == null
                || !_config.TagsToMonitor.Any(t => t.IsActive)
            )
            {
                _logger.Information(
                    "Kan monitoring niet starten voor {ConnectionName}: geen actieve tags geconfigureerd.",
                    _config.ConnectionName
                );
                return;
            }

            await _semaphore.WaitAsync();
            try
            {
                if (_subscription != null)
                {
                    _logger.Information(
                        "Verwijdert bestaande subscription voor {ConnectionName} alvorens een nieuwe te starten.",
                        _config.ConnectionName
                    );
                    try
                    {
                        _subscription.Delete(true);
                    }
                    catch (Exception ex)
                    {
                        _logger.Warning(
                            ex,
                            "Fout bij verwijderen oude subscription voor {ConnectionName}.",
                            _config.ConnectionName
                        );
                    }
                    _subscription.Dispose();
                    _subscription = null;
                }

                _subscription = new Subscription(_session.DefaultSubscription)
                {
                    DisplayName = $"{_config.ConnectionName} Subscription",
                    PublishingInterval = _config
                        .TagsToMonitor.Where(t => t.IsActive && t.SamplingInterval > 0)
                        .Any()
                        ? _config
                            .TagsToMonitor.Where(t => t.IsActive && t.SamplingInterval > 0)
                            .Min(t => t.SamplingInterval)
                        : 1000,
                    KeepAliveCount = 10,
                    LifetimeCount = 30,
                    MaxNotificationsPerPublish = 0,
                    PublishingEnabled = true,
                    TimestampsToReturn = TimestampsToReturn.Both,
                };

                var itemsToMonitor = new List<MonitoredItem>();
                foreach (var tagConfig in _config.TagsToMonitor.Where(t => t.IsActive))
                {
                    try
                    {
                        var item = new MonitoredItem(_subscription.DefaultItem)
                        {
                            DisplayName = tagConfig.TagName,
                            StartNodeId = ParseNodeId(tagConfig.NodeId),
                            AttributeId = Attributes.Value,
                            SamplingInterval =
                                tagConfig.SamplingInterval > 0 ? tagConfig.SamplingInterval : -1,
                            QueueSize = 1,
                            DiscardOldest = true,
                        };
                        item.Notification += OnMonitoredItemNotification;
                        itemsToMonitor.Add(item);
                    }
                    catch (Exception ex)
                    {
                        _logger.Error(
                            ex,
                            "Fout bij voorbereiden MonitoredItem voor NodeId {NodeId} (Tag: {TagName}) voor {ConnectionName}.",
                            tagConfig.NodeId,
                            tagConfig.TagName,
                            _config.ConnectionName
                        );
                    }
                }

                if (!itemsToMonitor.Any())
                {
                    _logger.Information(
                        "Geen actieve en valide tags om te monitoren voor {ConnectionName}",
                        _config.ConnectionName
                    );
                    _subscription.Dispose();
                    _subscription = null;
                    return;
                }

                _subscription.AddItems(itemsToMonitor);
                _logger.Information(
                    "Probeert subscription aan te maken voor {ItemCount} items op {ConnectionName}",
                    itemsToMonitor.Count,
                    _config.ConnectionName
                );
                _session.AddSubscription(_subscription);
                await _subscription.CreateAsync().ConfigureAwait(false);

                _logger.Information(
                    "Subscription aangemaakt voor {ConnectionName}. Client ingesteld PublishingInterval: {ClientSetPubInt}ms. Server gereviseerd CurrentPublishingInterval: {RevisedPubInt}ms. Client ingesteld KeepAliveCount: {ClientSetKeepAlive}, Server gereviseerd CurrentKeepAliveCount: {RevisedKeepAlive}",
                    _config.ConnectionName,
                    _subscription.PublishingInterval,
                    _subscription.CurrentPublishingInterval,
                    _subscription.KeepAliveCount,
                    _subscription.CurrentKeepAliveCount
                );

                foreach (var monitoredItem in _subscription.MonitoredItems)
                {
                    _logger.Information(
                        "Tag: {DisplayName} (NodeId: {NodeId}) - Client gevraagd SamplingInterval: {RequestedSamplingInt}ms. Server gereviseerd SamplingInterval: {RevisedSamplingInt}ms. Client gevraagd QueueSize: {RequestedQueueSize}, Server gereviseerd QueueSize: {RevisedQueueSize}",
                        monitoredItem.DisplayName,
                        monitoredItem.StartNodeId,
                        monitoredItem.SamplingInterval,
                        monitoredItem.QueueSize
                    );
                }

                await _subscription.ApplyChangesAsync().ConfigureAwait(false);
                _logger.Information(
                    "Subscription succesvol aangemaakt en items worden gemonitord voor {ConnectionName}",
                    _config.ConnectionName
                );

                var initialReadValueIds = new ReadValueIdCollection();
                List<OpcUaTagConfig> tagsForInitialRead = new List<OpcUaTagConfig>();

                foreach (var item in _subscription.MonitoredItems.Where(mi => mi.Status.Created))
                {
                    var tagConfig = _config.TagsToMonitor.FirstOrDefault(tc =>
                        tc.NodeId == item.StartNodeId.ToString() && tc.IsActive
                    );
                    if (tagConfig != null)
                    {
                        initialReadValueIds.Add(
                            new ReadValueId
                            {
                                NodeId = item.StartNodeId,
                                AttributeId = Attributes.Value,
                            }
                        );
                        tagsForInitialRead.Add(tagConfig);
                        _logger.Debug(
                            "Voorbereiden initiele leesactie voor tag: {TagName} (NodeId: {NodeId})",
                            tagConfig.TagName,
                            tagConfig.NodeId
                        );
                    }
                }

                if (initialReadValueIds.Any())
                {
                    _logger.Information(
                        "Uitvoeren initiele leesactie voor {Count} tags na start monitoring.",
                        initialReadValueIds.Count
                    );
                    try
                    {
                        var response = await _session
                            .ReadAsync(
                                null,
                                0,
                                TimestampsToReturn.Source,
                                initialReadValueIds,
                                CancellationToken.None
                            )
                            .ConfigureAwait(false);

                        DataValueCollection results = response.Results;
                        ClientBase.ValidateResponse(results, initialReadValueIds);

                        List<LoggedTagValue> initialLoggedValues = new List<LoggedTagValue>();
                        for (int i = 0; i < results.Count; i++)
                        {
                            var tagConfig = tagsForInitialRead.FirstOrDefault(tc =>
                                initialReadValueIds[i].NodeId.ToString() == tc.NodeId
                            );
                            if (tagConfig != null)
                            {
                                var loggedValue = new LoggedTagValue
                                {
                                    TagName = tagConfig.TagName,
                                    Value = results[i].Value,
                                    Timestamp =
                                        results[i].SourceTimestamp != DateTime.MinValue
                                            ? results[i].SourceTimestamp
                                            : results[i].ServerTimestamp,
                                    IsGoodQuality = StatusCode.IsGood(results[i].StatusCode),
                                    ErrorMessage = StatusCode.IsBad(results[i].StatusCode)
                                        ? results[i].StatusCode.ToString()
                                        : null,
                                };
                                initialLoggedValues.Add(loggedValue);
                                _logger.Debug(
                                    "Initiele waarde voor {TagName}: {Value}, Kwaliteit: {Quality}, Tijd: {Timestamp}",
                                    loggedValue.TagName,
                                    loggedValue.Value,
                                    loggedValue.IsGoodQuality,
                                    loggedValue.Timestamp
                                );
                            }
                        }

                        TagsDataReceived?.Invoke(this, initialLoggedValues);
                    }
                    catch (Exception ex)
                    {
                        _logger.Error(
                            ex,
                            "Fout tijdens initiele leesactie na start monitoring voor {ConnectionName}",
                            _config.ConnectionName
                        );
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij starten van OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
                if (_subscription != null)
                {
                    try
                    {
                        _subscription.Delete(true);
                    }
                    catch
                    { /* ignore */
                    }
                    _subscription.Dispose();
                    _subscription = null;
                }
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public async Task StopMonitoringTagsAsync()
        {
            if (_subscription == null)
                return;
            await _semaphore.WaitAsync();
            try
            {
                if (_subscription == null || !_session.Subscriptions.Contains(_subscription))
                {
                    _logger.Debug(
                        "Subscription al verwijderd of niet aanwezig in sessie voor {ConnectionName}.",
                        _config.ConnectionName
                    );
                    _subscription?.Dispose();
                    _subscription = null;
                    return;
                }

                _logger.Information(
                    "Stopt OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
                _subscription.Delete(true);
                _session.RemoveSubscription(_subscription);
                _subscription.Dispose();
                _subscription = null;
                _logger.Information(
                    "OPC UA tag monitoring gestopt voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij stoppen van OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );

                _subscription?.Dispose();
                _subscription = null;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        private void OnMonitoredItemNotification(
            MonitoredItem monitoredItem,
            MonitoredItemNotificationEventArgs e
        )
        {
            if (
                !(e.NotificationValue is MonitoredItemNotification notification)
                || notification.Value == null
            )
                return;

            var loggedValue = new LoggedTagValue
            {
                TagName = monitoredItem.DisplayName,
                Value = notification.Value.Value,
                Timestamp =
                    notification.Value.SourceTimestamp != DateTime.MinValue
                        ? notification.Value.SourceTimestamp
                        : notification.Value.ServerTimestamp,
                IsGoodQuality = StatusCode.IsGood(notification.Value.StatusCode),
                ErrorMessage = StatusCode.IsBad(notification.Value.StatusCode)
                    ? notification.Value.StatusCode.ToString()
                    : null,
            };
            TagsDataReceived?.Invoke(this, new List<LoggedTagValue> { loggedValue });
        }
        #endregion

        #region Data Reading
        public async Task<IEnumerable<LoggedTagValue>> ReadCurrentTagValuesAsync()
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning(
                    "Kan tags niet lezen voor {ConnectionName}: niet verbonden of geen sessie.",
                    _config.ConnectionName
                );
                return Enumerable.Empty<LoggedTagValue>();
            }
            if (
                _config == null
                || _config.TagsToMonitor == null
                || !_config.TagsToMonitor.Any(t => t.IsActive)
            )
            {
                _logger.Warning(
                    "Kan tags niet lezen voor {ConnectionName}: geen actieve tags geconfigureerd.",
                    _config.ConnectionName
                );
                return Enumerable.Empty<LoggedTagValue>();
            }

            var loggedValues = new List<LoggedTagValue>();
            var nodesToRead = new ReadValueIdCollection();
            var activeTagConfigs = _config.TagsToMonitor.Where(t => t.IsActive).ToList();

            foreach (var tagConfig in activeTagConfigs)
            {
                try
                {
                    nodesToRead.Add(
                        new ReadValueId
                        {
                            NodeId = ParseNodeId(tagConfig.NodeId),
                            AttributeId = Attributes.Value,
                        }
                    );
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Ongeldige NodeId {NodeId} voor tag {TagName} (Conn: {ConnectionName})",
                        tagConfig.NodeId,
                        tagConfig.TagName,
                        _config.ConnectionName
                    );
                    loggedValues.Add(
                        new LoggedTagValue
                        {
                            TagName = tagConfig.TagName,
                            IsGoodQuality = false,
                            ErrorMessage = $"Ongeldige NodeId: {tagConfig.NodeId}",
                            Timestamp = DateTime.UtcNow,
                        }
                    );
                }
            }

            if (!nodesToRead.Any())
                return loggedValues;

            try
            {
                _logger.Debug(
                    "Leest {Count} OPC UA tags voor {ConnectionName}.",
                    nodesToRead.Count,
                    _config.ConnectionName
                );
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Source,
                        nodesToRead,
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                DataValueCollection results = response.Results;
                DiagnosticInfoCollection diagnosticInfos = response.DiagnosticInfos;

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                for (int i = 0; i < results.Count; i++)
                {
                    var correspondingTagConfig = activeTagConfigs.FirstOrDefault(tc =>
                    {
                        try
                        {
                            return ParseNodeId(tc.NodeId).Equals(nodesToRead[i].NodeId);
                        }
                        catch
                        {
                            return false;
                        }
                    });

                    if (correspondingTagConfig == null)
                    {
                        _logger.Warning(
                            "Kon geen overeenkomende tagConfig vinden voor gelezen NodeId {ReadNodeId} (Conn: {ConnectionName})",
                            nodesToRead[i].NodeId,
                            _config.ConnectionName
                        );
                        continue;
                    }

                    loggedValues.Add(
                        new LoggedTagValue
                        {
                            TagName = correspondingTagConfig.TagName,
                            Value = results[i].Value,
                            Timestamp =
                                results[i].SourceTimestamp != DateTime.MinValue
                                    ? results[i].SourceTimestamp
                                    : results[i].ServerTimestamp,
                            IsGoodQuality = StatusCode.IsGood(results[i].StatusCode),
                            ErrorMessage = StatusCode.IsBad(results[i].StatusCode)
                                ? results[i].StatusCode.ToString()
                                : null,
                        }
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens het lezen van OPC UA tags voor {ConnectionName}.",
                    _config.ConnectionName
                );
                foreach (var readValueIdWithError in nodesToRead)
                {
                    var tagConfig = activeTagConfigs.FirstOrDefault(tc =>
                    {
                        try
                        {
                            return ParseNodeId(tc.NodeId).Equals(readValueIdWithError.NodeId);
                        }
                        catch
                        {
                            return false;
                        }
                    });
                    if (
                        tagConfig != null
                        && !loggedValues.Any(lv =>
                            lv.TagName == tagConfig.TagName && !lv.IsGoodQuality
                        )
                    )
                    {
                        loggedValues.Add(
                            new LoggedTagValue
                            {
                                TagName = tagConfig.TagName,
                                IsGoodQuality = false,
                                ErrorMessage = $"Algemene leesfout: {ex.Message}",
                                Timestamp = DateTime.UtcNow,
                            }
                        );
                    }
                }
            }
            return loggedValues;
        }

        public async Task<DataValue> ReadValueAsync(NodeId nodeId)
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning(
                    "Kan waarde niet lezen voor {NodeId} (Conn: {ConnectionName}): geen actieve sessie.",
                    nodeId,
                    _config.ConnectionName
                );
                return new DataValue(StatusCodes.BadNotConnected);
            }
            ReadValueId nodeToRead = new ReadValueId
            {
                NodeId = nodeId,
                AttributeId = Attributes.Value,
            };
            ReadValueIdCollection nodesToRead = new ReadValueIdCollection { nodeToRead };
            try
            {
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Source,
                        nodesToRead,
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                ClientBase.ValidateResponse(response.Results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(response.DiagnosticInfos, nodesToRead);
                return (response.Results != null && response.Results.Count > 0)
                    ? response.Results[0]
                    : new DataValue(StatusCodes.BadNoDataAvailable);
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens lezen waarde voor NodeId: {NodeId} (Conn: {ConnectionName})",
                    nodeId,
                    _config.ConnectionName
                );
            }

            return null;
        }

        public async Task<List<NodeAttributeViewModel>> ReadNodeAttributesAsync(NodeId nodeId)
        {
            var attributes = new List<NodeAttributeViewModel>();
            if (!IsConnected || _session == null)
            {
                attributes.Add(
                    new NodeAttributeViewModel(
                        "Error",
                        "Niet verbonden",
                        StatusCodes.BadNotConnected
                    )
                );
                return attributes;
            }
            uint[] attributeIdsToRead = new uint[]
            {
                Attributes.NodeId,
                Attributes.NodeClass,
                Attributes.BrowseName,
                Attributes.DisplayName,
                Attributes.Description,
                Attributes.WriteMask,
                Attributes.UserWriteMask,
                Attributes.DataType,
                Attributes.ValueRank,
                Attributes.ArrayDimensions,
                Attributes.AccessLevel,
                Attributes.UserAccessLevel,
                Attributes.MinimumSamplingInterval,
                Attributes.Historizing,
                Attributes.Value,
            };
            var nodesToRead = new ReadValueIdCollection(
                attributeIdsToRead.Select(attrId => new ReadValueId
                {
                    NodeId = nodeId,
                    AttributeId = attrId,
                })
            );
            try
            {
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Neither,
                        nodesToRead,
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                ClientBase.ValidateResponse(response.Results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(response.DiagnosticInfos, nodesToRead);
                for (int i = 0; i < response.Results.Count; i++)
                {
                    string attrName =
                        Attributes.GetBrowseName(nodesToRead[i].AttributeId)
                        ?? $"AttrID {nodesToRead[i].AttributeId}";
                    object val = response.Results[i].Value;
                    if (nodesToRead[i].AttributeId == Attributes.NodeClass && val is int ncInt)
                        val = (NodeClass)ncInt;
                    else if (
                        nodesToRead[i].AttributeId == Attributes.DataType
                        && val is NodeId dtNodeId
                    )
                    {
                        var dtNode = _session.NodeCache.Find(dtNodeId);
                        val = dtNode?.DisplayName?.Text ?? dtNodeId.ToString();
                    }
                    attributes.Add(
                        new NodeAttributeViewModel(attrName, val, response.Results[i].StatusCode)
                    );
                }
            }
            catch (Exception ex)
            {
                attributes.Add(
                    new NodeAttributeViewModel("Error", ex.Message, StatusCodes.BadUnexpectedError)
                );
                _logger.Error(ex, "Error ReadNodeAttributesAsync");
            }
            return attributes;
        }

        public async Task<LocalizedText> ReadNodeDisplayNameAsync(NodeId nodeId)
        {
            if (!IsConnected || _session == null)
                return null;
            ReadValueId nodeToRead = new ReadValueId
            {
                NodeId = nodeId,
                AttributeId = Attributes.DisplayName,
            };
            try
            {
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Neither,
                        new ReadValueIdCollection { nodeToRead },
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                return (
                    response.Results != null
                    && response.Results.Count > 0
                    && StatusCode.IsGood(response.Results[0].StatusCode)
                )
                    ? response.Results[0].Value as LocalizedText
                    : null;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Error ReadNodeDisplayNameAsync for {NodeId}", nodeId);
                return null;
            }
        }

        public async Task<ReferenceDescriptionCollection> BrowseAllReferencesAsync(
            NodeId nodeIdToBrowse,
            BrowseDirection direction = BrowseDirection.Both
        )
        {
            return await BrowseAsync(
                nodeIdToBrowse,
                null,
                true,
                direction,
                NodeClass.Unspecified,
                CancellationToken.None
            );
        }
        #endregion

        #region Browse
        public async Task<ReferenceDescriptionCollection> BrowseAsync(
            NodeId nodeIdToBrowse,
            NodeId referenceTypeId = null,
            bool includeSubtypes = true,
            BrowseDirection direction = BrowseDirection.Forward,
            NodeClass nodeClassMask = NodeClass.Unspecified,
            CancellationToken ct = default
        )
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning("BrowseAsync: Not connected.");
                return new ReferenceDescriptionCollection();
            }
            try
            {
                BrowseDescription nodeToBrowseDesc = new BrowseDescription
                {
                    NodeId = nodeIdToBrowse,
                    BrowseDirection = direction,
                    ReferenceTypeId = referenceTypeId ?? ReferenceTypeIds.HierarchicalReferences,
                    IncludeSubtypes = includeSubtypes,
                    NodeClassMask = (uint)nodeClassMask,
                    ResultMask = (uint)BrowseResultMask.All,
                };
                BrowseResponse response = await _session
                    .BrowseAsync(
                        null,
                        null,
                        0,
                        new BrowseDescriptionCollection { nodeToBrowseDesc },
                        ct
                    )
                    .ConfigureAwait(false);
                ClientBase.ValidateResponse(
                    response.Results,
                    new BrowseDescriptionCollection { nodeToBrowseDesc }
                );
                ClientBase.ValidateDiagnosticInfos(
                    response.DiagnosticInfos,
                    new BrowseDescriptionCollection { nodeToBrowseDesc }
                );
                if (StatusCode.IsBad(response.Results[0].StatusCode))
                {
                    _logger.Error(
                        "Browse error for {NodeId}: {StatusCode}",
                        nodeIdToBrowse,
                        response.Results[0].StatusCode
                    );
                    return new ReferenceDescriptionCollection();
                }

                ReferenceDescriptionCollection references = response.Results[0].References;
                ByteStringCollection continuationPoints = new ByteStringCollection();
                if (response.Results[0].ContinuationPoint != null)
                    continuationPoints.Add(response.Results[0].ContinuationPoint);

                while (continuationPoints.Any() && continuationPoints[0] != null)
                {
                    var browseNextResponse = await _session
                        .BrowseNextAsync(null, false, continuationPoints, ct)
                        .ConfigureAwait(false);
                    ClientBase.ValidateResponse(browseNextResponse.Results, continuationPoints);
                    ClientBase.ValidateDiagnosticInfos(
                        browseNextResponse.DiagnosticInfos,
                        continuationPoints
                    );
                    if (StatusCode.IsBad(browseNextResponse.Results[0].StatusCode))
                    {
                        _logger.Error(
                            "BrowseNext error for {NodeId}: {StatusCode}",
                            nodeIdToBrowse,
                            browseNextResponse.Results[0].StatusCode
                        );
                        break;
                    }
                    references.AddRange(browseNextResponse.Results[0].References);
                    continuationPoints.Clear();
                    if (browseNextResponse.Results[0].ContinuationPoint != null)
                        continuationPoints.Add(browseNextResponse.Results[0].ContinuationPoint);
                }
                return references;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Exception during BrowseAsync for {NodeId}", nodeIdToBrowse);
                return new ReferenceDescriptionCollection();
            }
        }

        public async Task<ReferenceDescriptionCollection> BrowseRootAsync()
        {
            return await BrowseAsync(ObjectIds.ObjectsFolder, ct: CancellationToken.None);
        }

        public NodeId ParseNodeId(string nodeIdString)
        {
            if (_session == null || _session.MessageContext == null)
            {
                _logger.Warning(
                    "ParseNodeId: No active session/context, using default parse for '{NodeIdString}'.",
                    nodeIdString
                );
                return NodeId.Parse(nodeIdString);
            }
            return NodeId.Parse(_session.MessageContext, nodeIdString);
        }
        #endregion

        #region IDisposable
        public void Dispose()
        {
            _logger.Debug(
                "Dispose aangeroepen voor OpcUaService {ConnectionName}",
                _config.ConnectionName
            );
            bool waited = _semaphore.Wait(1000);
            try
            {
                if (IsConnected)
                {
                    Task.Run(async () => await DisconnectAsync()).Wait(TimeSpan.FromSeconds(2));
                }
                _subscription?.Dispose();
                _session?.Dispose();
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens Dispose van OpcUaService voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            finally
            {
                if (waited)
                    _semaphore.Release();
                _semaphore?.Dispose();
            }
        }
        #endregion
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\SettingsService.cs"
using System;
using System.IO;
using System.Reflection;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class SettingsService : ISettingsService
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private const string SettingsFileName = "DataLoggerSettings.json";
        private string _settingsFilePath;

        private AppSettings _currentSettings;
        public AppSettings CurrentSettings
        {
            get => _currentSettings;
            private set => _currentSettings = value;
        }

        public SettingsService(ILogger logger, IStatusService statusService)
        {
            _logger = logger;
            _statusService = statusService;

            string executableLocation = Path.GetDirectoryName(
                Assembly.GetExecutingAssembly().Location
            );
            _settingsFilePath = Path.Combine(executableLocation, SettingsFileName);
            _logger.Information(
                "Pad naar instellingenbestand: {SettingsFilePath}",
                _settingsFilePath
            );

            LoadSettings();
        }

        public void LoadSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Loading, "Instellingen laden...");
            try
            {
                if (File.Exists(_settingsFilePath))
                {
                    _logger.Information("Instellingenbestand gevonden. Bezig met laden...");
                    string json = File.ReadAllText(_settingsFilePath);

                    var serializerSettings = new JsonSerializerSettings
                    {
                        TypeNameHandling = TypeNameHandling.Objects,
                        Formatting = Formatting.Indented,
                    };

                    _currentSettings = JsonConvert.DeserializeObject<AppSettings>(
                        json,
                        serializerSettings
                    );
                    _logger.Information("Instellingen succesvol geladen.");
                }
                else
                {
                    _logger.Warning(
                        "Instellingenbestand niet gevonden op {SettingsFilePath}. Standaardinstellingen worden geladen.",
                        _settingsFilePath
                    );
                    LoadDefaultSettings();
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van instellingen. Standaardinstellingen worden geladen."
                );
                LoadDefaultSettings();
            }
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen verwerkt.");
        }

        public void SaveSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Saving, "Instellingen opslaan...");
            try
            {
                var serializerSettings = new JsonSerializerSettings
                {
                    TypeNameHandling = TypeNameHandling.Objects,
                    Formatting = Formatting.Indented,
                };

                string json = JsonConvert.SerializeObject(CurrentSettings, serializerSettings);
                File.WriteAllText(_settingsFilePath, json);
                _logger.Information(
                    "Instellingen succesvol opgeslagen in {SettingsFilePath}",
                    _settingsFilePath
                );
                _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het opslaan van instellingen naar {SettingsFilePath}",
                    _settingsFilePath
                );
                _statusService.SetStatus(
                    Enums.ApplicationStatus.Error,
                    "Fout bij opslaan instellingen."
                );
            }
        }

        public void LoadDefaultSettings()
        {
            _logger.Information("Standaardinstellingen worden geconfigureerd.");
            _currentSettings = new AppSettings();
            _currentSettings.Connections.Add(
                new ModbusTcpConnectionConfig
                {
                    ConnectionName = "Voorbeeld Modbus Device",
                    IpAddress = "192.168.1.100",
                    Port = 502,
                    IsEnabled = false,
                    ScanIntervalSeconds = 5,
                }
            );
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\StatusService.cs"
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class StatusService : ObservableObject, IStatusService
    {
        private readonly ILogger _logger;
        private ApplicationStatus _currentStatus;
        private string _statusMessage;

        public ApplicationStatus CurrentStatus
        {
            get => _currentStatus;
            private set => SetProperty(ref _currentStatus, value);
        }

        public string StatusMessage
        {
            get => _statusMessage;
            private set => SetProperty(ref _statusMessage, value);
        }

        public StatusService(ILogger logger)
        {
            _logger = logger;

            SetStatus(ApplicationStatus.Idle, "Applicatie gereed.");
        }

        public void SetStatus(ApplicationStatus status, string message)
        {
            CurrentStatus = status;
            StatusMessage = message;
            _logger.Information(
                "Applicatiestatus gewijzigd naar: {Status} - Bericht: {Message}",
                status,
                message
            );
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\LogViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;
using Serilog.Events;

namespace Data_Logger.ViewModels
{
    public class LogViewModel : ObservableObject
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly ILogger _logger;

        private string _filterText;
        private LogEventLevel? _selectedLogLevelFilter;

        public ObservableCollection<UiLogEntry> LogEntries => _loggingHostService.LogEntries;
        public ICollectionView FilteredLogEntries { get; }

        public string FilterText
        {
            get => _filterText;
            set
            {
                if (SetProperty(ref _filterText, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ObservableCollection<LogEventLevel?> LogLevels { get; } =
            new ObservableCollection<LogEventLevel?>(
                new LogEventLevel?[] { null }.Concat(
                    Enum.GetValues(typeof(LogEventLevel)).Cast<LogEventLevel?>()
                )
            );

        public LogEventLevel? SelectedLogLevelFilter
        {
            get => _selectedLogLevelFilter;
            set
            {
                if (SetProperty(ref _selectedLogLevelFilter, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ICommand ClearLogsCommand { get; }

        public LogViewModel(ILoggingHostService loggingHostService, ILogger logger)
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _logger =
                logger?.ForContext<LogViewModel>()
                ?? throw new ArgumentNullException(nameof(logger));

            FilteredLogEntries = CollectionViewSource.GetDefaultView(LogEntries);
            FilteredLogEntries.Filter = ApplyFilter;

            ClearLogsCommand = new RelayCommand(
                _ => _loggingHostService.ClearLogs(),
                _ => LogEntries.Any()
            );

            LogEntries.CollectionChanged += (sender, e) =>
            {
                ((RelayCommand)ClearLogsCommand).RaiseCanExecuteChanged();
            };
        }

        private bool ApplyFilter(object item)
        {
            if (item is UiLogEntry entry)
            {
                bool logLevelMatch =
                    !_selectedLogLevelFilter.HasValue
                    || entry.Level >= _selectedLogLevelFilter.Value;
                bool textMatch =
                    string.IsNullOrWhiteSpace(_filterText)
                    || entry.RenderedMessage.IndexOf(
                        _filterText,
                        StringComparison.OrdinalIgnoreCase
                    ) >= 0
                    || (
                        entry.Exception != null
                        && entry.Exception.IndexOf(_filterText, StringComparison.OrdinalIgnoreCase)
                            >= 0
                    );
                return logLevelMatch && textMatch;
            }
            return false;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\MainViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.Views;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private readonly ISettingsService _settingsService;
        private readonly Func<Action, SettingsViewModel> _settingsViewModelFactory;

        private readonly Func<ModbusTcpConnectionConfig, IModbusService> _modbusServiceFactory;
        private readonly Func<OpcUaConnectionConfig, IOpcUaService> _opcUaServiceFactory;

        private readonly IDataLoggingService _dataLoggingService;

        private string _applicationTitle = "Data Logger Applicatie";
        public string ApplicationTitle
        {
            get => _applicationTitle;
            set => SetProperty(ref _applicationTitle, value);
        }

        public LogViewModel LogVm { get; }
        public ApplicationStatus CurrentApplicationStatus => _statusService.CurrentStatus;
        public string CurrentStatusMessage => _statusService.StatusMessage;

        public ObservableCollection<TabViewModelBase> ActiveTabs { get; } =
            new ObservableCollection<TabViewModelBase>();

        private TabViewModelBase _selectedTab;
        public TabViewModelBase SelectedTab
        {
            get => _selectedTab;
            set => SetProperty(ref _selectedTab, value);
        }

        public ICommand OpenSettingsCommand { get; }

        public MainViewModel(
            ILogger logger,
            LogViewModel logViewModel,
            IStatusService statusService,
            ISettingsService settingsService,
            Func<Action, SettingsViewModel> settingsViewModelFactory,
            Func<ModbusTcpConnectionConfig, IModbusService> modbusServiceFactory,
            Func<OpcUaConnectionConfig, IOpcUaService> opcUaServiceFactory,
            IDataLoggingService dataLoggingService
        )
        {
            _logger = logger;
            LogVm = logViewModel;
            _statusService = statusService;
            _settingsService = settingsService;
            _settingsViewModelFactory = settingsViewModelFactory;

            _modbusServiceFactory = modbusServiceFactory;
            _opcUaServiceFactory = opcUaServiceFactory;

            _dataLoggingService = dataLoggingService;

            if (_statusService is INotifyPropertyChanged notifier)
            {
                notifier.PropertyChanged += StatusService_PropertyChanged;
            }

            OpenSettingsCommand = new RelayCommand(_ => OpenSettingsWindow());

            _logger.Information("MainViewModel geïnitialiseerd.");
            _statusService.SetStatus(ApplicationStatus.Idle, "Applicatie succesvol geladen.");

            LoadTabsFromSettings();
        }

        private void OpenSettingsWindow()
        {
            _logger.Information("Instellingenvenster wordt geopend...");
            _statusService.SetStatus(ApplicationStatus.Idle, "Instellingen openen...");

            var settingsView = new Views.SettingsView();
            Action closeAction = () => settingsView.Close();
            var settingsVm = _settingsViewModelFactory(closeAction);
            settingsView.DataContext = settingsVm;

            if (
                Application.Current.MainWindow != null
                && Application.Current.MainWindow != settingsView
            )
            {
                settingsView.Owner = Application.Current.MainWindow;
            }

            settingsView.ShowDialog();

            _logger.Information("Instellingenvenster gesloten.");

            UpdateTabsAfterSettingsChange();

            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar.");
        }

        private void UpdateTabsAfterSettingsChange()
        {
            _logger.Information("Tabs bijwerken na mogelijke instellingwijzigingen...");

            var newConfigsFromSettings = _settingsService.CurrentSettings.Connections.ToList();
            var currentActiveTabs = ActiveTabs.ToList();
            var handledNewConfigs = new HashSet<ConnectionConfigBase>();

            List<TabViewModelBase> tabsToRemove = new List<TabViewModelBase>();

            foreach (var tabVm in currentActiveTabs)
            {
                ConnectionConfigBase oldTabConfig = tabVm.ConnectionConfiguration;
                ConnectionConfigBase correspondingNewConfig = null;

                if (oldTabConfig is OpcUaConnectionConfig oldOpcUa)
                {
                    correspondingNewConfig = newConfigsFromSettings
                        .OfType<OpcUaConnectionConfig>()
                        .FirstOrDefault(newOpcUa =>
                            newOpcUa.IsEnabled
                            && oldOpcUa.EndpointUrl == newOpcUa.EndpointUrl
                            && oldOpcUa.SecurityMode == newOpcUa.SecurityMode
                            && oldOpcUa.SecurityPolicyUri == newOpcUa.SecurityPolicyUri
                            && oldOpcUa.UserName == newOpcUa.UserName
                        );
                }
                else if (oldTabConfig is ModbusTcpConnectionConfig oldModbus)
                {
                    correspondingNewConfig = newConfigsFromSettings
                        .OfType<ModbusTcpConnectionConfig>()
                        .FirstOrDefault(newModbus =>
                            newModbus.IsEnabled
                            && oldModbus.IpAddress == newModbus.IpAddress
                            && oldModbus.Port == newModbus.Port
                            && oldModbus.UnitId == newModbus.UnitId
                        );
                }

                if (correspondingNewConfig != null && correspondingNewConfig.IsEnabled)
                {
                    _logger.Information(
                        "Bestaande tab voor (oude naam) '{OldName}' wordt bijgewerkt met configuratie (nieuwe naam) '{NewName}'.",
                        oldTabConfig.ConnectionName,
                        correspondingNewConfig.ConnectionName
                    );

                    if (
                        tabVm is OpcUaTabViewModel opcUaTabVm
                        && correspondingNewConfig is OpcUaConnectionConfig newOpcConf
                    )
                    {
                        opcUaTabVm.UpdateConfiguration(newOpcConf);
                    }
                    else if (
                        tabVm is ModbusTabViewModel modbusTabVm
                        && correspondingNewConfig is ModbusTcpConnectionConfig newModConf
                    )
                    {
                        modbusTabVm.UpdateConfiguration(newModConf);
                    }
                    handledNewConfigs.Add(correspondingNewConfig);
                }
                else
                {
                    _logger.Information(
                        "Geen actieve overeenkomstige nieuwe configuratie gevonden voor tab: {ConnectionName}. Tab wordt verwijderd.",
                        oldTabConfig.ConnectionName
                    );
                    tabsToRemove.Add(tabVm);
                }
            }

            foreach (var tabVmToRemove in tabsToRemove)
            {
                if (tabVmToRemove is IDisposable disposable)
                    disposable.Dispose();
                ActiveTabs.Remove(tabVmToRemove);
            }

            foreach (
                var newConfig in newConfigsFromSettings.Where(nc =>
                    nc.IsEnabled && !handledNewConfigs.Contains(nc)
                )
            )
            {
                _logger.Information(
                    "Nieuwe actieve verbinding gevonden, tab aanmaken voor: {ConnectionName}",
                    newConfig.ConnectionName
                );
                CreateAndAddTab(newConfig);
            }

            if (ActiveTabs.Any() && SelectedTab == null)
                SelectedTab = ActiveTabs.First();
            else if (!ActiveTabs.Any())
                SelectedTab = null;
            else if (SelectedTab != null && !ActiveTabs.Contains(SelectedTab))
                SelectedTab = ActiveTabs.FirstOrDefault();
        }

        private void CreateAndAddTab(ConnectionConfigBase config)
        {
            TabViewModelBase tabVm = null;
            if (config is ModbusTcpConnectionConfig modbusConfig)
            {
                if (_modbusServiceFactory != null && _dataLoggingService != null)
                {
                    var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                    tabVm = new ModbusTabViewModel(
                        modbusConfig,
                        _logger,
                        modbusServiceInstance,
                        _statusService,
                        _dataLoggingService
                    );
                }
                else
                {
                    _logger.Error(
                        "Modbus service factory of data logging service niet geïnjecteerd. Kan ModbusTabViewModel niet aanmaken."
                    );
                }
            }
            else if (config is OpcUaConnectionConfig opcUaConfig)
            {
                if (_opcUaServiceFactory != null && _dataLoggingService != null)
                {
                    var opcUaServiceInstance = _opcUaServiceFactory(opcUaConfig);
                    tabVm = new OpcUaTabViewModel(
                        opcUaConfig,
                        _logger,
                        opcUaServiceInstance,
                        _statusService,
                        _dataLoggingService,
                        _settingsService
                    );
                }
                else
                {
                    _logger.Error(
                        "OPC UA service factory of data logging service niet geïnjecteerd. Kan OpcUaTabViewModel niet aanmaken."
                    );
                }
            }

            if (tabVm != null)
            {
                ActiveTabs.Add(tabVm);
                _logger.Information(
                    "Tab aangemaakt en toegevoegd voor {ConnectionName} ({ConnectionType})",
                    config.ConnectionName,
                    config.Type
                );
            }
        }

        private void LoadTabsFromSettings()
        {
            _logger.Information("Tabs laden op basis van huidige instellingen...");
            var currentSelectedTabName = SelectedTab?.ConnectionConfiguration?.ConnectionName;
            var currentTabs = ActiveTabs.ToList();

            foreach (var tab in currentTabs)
            {
                if (tab is IDisposable disposable)
                {
                    disposable.Dispose();
                }
                ActiveTabs.Remove(tab);
            }

            if (_settingsService.CurrentSettings?.Connections == null)
            {
                _logger.Warning(
                    "Geen verbindingen gevonden in de instellingen om tabs voor te laden."
                );
                SelectedTab = null;
                return;
            }

            foreach (var config in _settingsService.CurrentSettings.Connections)
            {
                if (config.IsEnabled)
                {
                    TabViewModelBase tabVm = null;
                    switch (config.Type)
                    {
                        case ConnectionType.ModbusTcp:
                            if (
                                config is ModbusTcpConnectionConfig modbusConfig
                                && _modbusServiceFactory != null
                            )
                            {
                                var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                                tabVm = new ModbusTabViewModel(
                                    modbusConfig,
                                    _logger,
                                    modbusServiceInstance,
                                    _statusService,
                                    _dataLoggingService
                                );
                                _logger.Debug(
                                    "Modbus TCP Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    modbusConfig.ConnectionName
                                );
                            }
                            else if (_modbusServiceFactory == null)
                            {
                                _logger.Error(
                                    "_modbusServiceFactory is niet geïnjecteerd in MainViewModel."
                                );
                            }
                            break;
                        case ConnectionType.OpcUa:
                            if (
                                config is OpcUaConnectionConfig opcUaConfig
                                && _opcUaServiceFactory != null
                            )
                            {
                                var opcUaServiceInstance = _opcUaServiceFactory(opcUaConfig);
                                tabVm = new OpcUaTabViewModel(
                                    opcUaConfig,
                                    _logger,
                                    opcUaServiceInstance,
                                    _statusService,
                                    _dataLoggingService,
                                    _settingsService
                                );
                                _logger.Debug(
                                    "OPC UA Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    opcUaConfig.ConnectionName
                                );
                            }
                            else if (_opcUaServiceFactory == null)
                            {
                                _logger.Error(
                                    "_opcUaServiceFactory is niet geïnjecteerd in MainViewModel."
                                );
                            }
                            break;
                        default:
                            _logger.Warning(
                                "Onbekend verbindingstype '{Type}' overgeslagen voor tab: {ConnectionName}",
                                config.Type,
                                config.ConnectionName
                            );
                            break;
                    }

                    if (tabVm != null)
                    {
                        ActiveTabs.Add(tabVm);
                    }
                }
                else
                {
                    _logger.Debug(
                        "Verbinding '{ConnectionName}' is uitgeschakeld en wordt niet als tab geladen.",
                        config.ConnectionName
                    );
                }
            }

            if (!string.IsNullOrEmpty(currentSelectedTabName))
            {
                SelectedTab = ActiveTabs.FirstOrDefault(t =>
                    t.ConnectionConfiguration.ConnectionName == currentSelectedTabName
                );
            }

            if (SelectedTab == null && ActiveTabs.Any())
            {
                SelectedTab = ActiveTabs.First();
            }
            else if (!ActiveTabs.Any())
            {
                SelectedTab = null;
            }
            _logger.Information("{Count} actieve tabs geladen.", ActiveTabs.Count);
        }

        private void StatusService_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(IStatusService.CurrentStatus))
            {
                OnPropertyChanged(nameof(CurrentApplicationStatus));
            }
            else if (e.PropertyName == nameof(IStatusService.StatusMessage))
            {
                OnPropertyChanged(nameof(CurrentStatusMessage));
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ModbusTabViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class ModbusTabViewModel : TabViewModelBase, IDisposable
    {
        private readonly ILogger _specificLogger;
        private readonly IModbusService _modbusService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;
        private DispatcherTimer _scanTimer;
        public ModbusTcpConnectionConfig ModbusConfig =>
            ConnectionConfiguration as ModbusTcpConnectionConfig;
        public bool IsConnected => _modbusService?.IsConnected ?? false;
        public ObservableCollection<LoggedTagValue> DataValues { get; } =
            new ObservableCollection<LoggedTagValue>();

        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }

        private readonly Dictionary<string, TagBaselineState> _tagBaselineStates =
            new Dictionary<string, TagBaselineState>();

        public ModbusTabViewModel(
            ModbusTcpConnectionConfig config,
            ILogger logger,
            IModbusService modbusService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService
        )
            : base(config)
        {
            _specificLogger = logger
                .ForContext<ModbusTabViewModel>()
                .ForContext("ConnectionName", config.ConnectionName);
            _modbusService =
                modbusService ?? throw new ArgumentNullException(nameof(modbusService));
            _statusService =
                statusService ?? throw new ArgumentNullException(nameof(statusService));
            _dataLoggingService =
                dataLoggingService ?? throw new ArgumentNullException(nameof(dataLoggingService));

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(
                async _ => await DisconnectAsync(),
                _ => IsConnected
            );

            _modbusService.ConnectionStatusChanged += OnModbusConnectionStatusChanged;
            _modbusService.TagsDataReceived += OnModbusTagsDataReceived;

            InitializeScanTimer();
            InitializeBaselineStates();
        }

        private void InitializeBaselineStates()
        {
            _tagBaselineStates.Clear();
            if (ModbusConfig?.TagsToMonitor != null)
            {
                foreach (
                    var tagConfig in ModbusConfig.TagsToMonitor.Where(tc =>
                        tc.IsActive && tc.IsOutlierDetectionEnabled
                    )
                )
                {
                    _tagBaselineStates[tagConfig.TagName] = new TagBaselineState(
                        tagConfig.TagName,
                        _specificLogger
                    );
                    _specificLogger.Debug(
                        "Baseline state geïnitialiseerd voor Modbus tag {TagName}",
                        tagConfig.TagName
                    );
                }
            }
        }

        private void ResetSpecificBaselineState(string tagName)
        {
            if (_tagBaselineStates.TryGetValue(tagName, out var baselineState))
            {
                baselineState.Reset();
            }
        }

        private void OnModbusTagsDataReceived(
            object sender,
            IEnumerable<LoggedTagValue> receivedTagValues
        )
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            if (!tagValuesList.Any())
                return;

            _specificLogger.Debug(
                "OnModbusTagsDataReceived: {Count} tag(s) ontvangen voor {ConnectionName}",
                tagValuesList.Count,
                DisplayName
            );

            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        foreach (var liveValue in tagValuesList)
                        {
                            var existingTagInUI = DataValues.FirstOrDefault(t =>
                                t.TagName == liveValue.TagName
                            );
                            if (existingTagInUI != null)
                            {
                                existingTagInUI.Value = liveValue.Value;
                                existingTagInUI.Timestamp = liveValue.Timestamp;
                                existingTagInUI.IsGoodQuality = liveValue.IsGoodQuality;
                                existingTagInUI.ErrorMessage = liveValue.ErrorMessage;
                            }
                            else
                            {
                                DataValues.Add(liveValue);
                                existingTagInUI = liveValue;
                            }

                            var configuredTag = ModbusConfig?.TagsToMonitor.FirstOrDefault(t =>
                                t.TagName == liveValue.TagName
                            );
                            if (configuredTag != null)
                            {
                                TagAlarmState finalAlarmState;
                                double? numericValueForAlarmCheck = null;
                                double? limitDetailsForThreshold = null;

                                if (!liveValue.IsGoodQuality)
                                {
                                    finalAlarmState = TagAlarmState.Error;
                                    if (configuredTag.IsOutlierDetectionEnabled)
                                        ResetSpecificBaselineState(configuredTag.TagName);
                                }
                                else if (
                                    !TryConvertToDouble(liveValue.Value, out double valForCheck)
                                )
                                {
                                    _specificLogger.Warning(
                                        "Waarde '{RawValue}' voor Modbus tag '{TagName}' kon niet naar double voor alarm/outlier check.",
                                        liveValue.Value,
                                        configuredTag.TagName
                                    );
                                    finalAlarmState = TagAlarmState.Error;
                                    if (configuredTag.IsOutlierDetectionEnabled)
                                        ResetSpecificBaselineState(configuredTag.TagName);
                                }
                                else
                                {
                                    numericValueForAlarmCheck = valForCheck;
                                    TagAlarmState thresholdState =
                                        DetermineThresholdAlarmStateModbus(
                                            configuredTag,
                                            numericValueForAlarmCheck.Value,
                                            out limitDetailsForThreshold
                                        );
                                    bool isOutlier = IsCurrentValueOutlierModbus(
                                        configuredTag,
                                        numericValueForAlarmCheck.Value
                                    );
                                    if (isOutlier)
                                    {
                                        finalAlarmState = TagAlarmState.Outlier;
                                    }
                                    else
                                    {
                                        finalAlarmState = thresholdState;
                                    }
                                }
                                UpdateAndLogFinalAlarmStateModbus(
                                    configuredTag,
                                    existingTagInUI,
                                    finalAlarmState,
                                    numericValueForAlarmCheck,
                                    limitDetailsForThreshold
                                );
                            }
                        }
                    }
                )
            );
            _dataLoggingService.LogTagValues(ModbusConfig.ConnectionName, tagValuesList);
        }

        private TagAlarmState DetermineThresholdAlarmStateModbus(
            ModbusTagConfig tagConfig,
            double numericValue,
            out double? limitDetails
        )
        {
            limitDetails = null;
            if (!tagConfig.IsAlarmingEnabled)
                return TagAlarmState.Normal;

            if (tagConfig.HighHighLimit.HasValue && numericValue >= tagConfig.HighHighLimit.Value)
            {
                limitDetails = tagConfig.HighHighLimit.Value;
                return TagAlarmState.HighHigh;
            }
            if (tagConfig.HighLimit.HasValue && numericValue >= tagConfig.HighLimit.Value)
            {
                limitDetails = tagConfig.HighLimit.Value;
                return TagAlarmState.High;
            }
            if (tagConfig.LowLowLimit.HasValue && numericValue <= tagConfig.LowLowLimit.Value)
            {
                limitDetails = tagConfig.LowLowLimit.Value;
                return TagAlarmState.LowLow;
            }
            if (tagConfig.LowLimit.HasValue && numericValue <= tagConfig.LowLimit.Value)
            {
                limitDetails = tagConfig.LowLimit.Value;
                return TagAlarmState.Low;
            }
            return TagAlarmState.Normal;
        }

        private bool IsCurrentValueOutlierModbus(ModbusTagConfig tagConfig, double numericValue)
        {
            if (!tagConfig.IsOutlierDetectionEnabled)
                return false;
            if (!_tagBaselineStates.TryGetValue(tagConfig.TagName, out var baselineState))
            {
                baselineState = new TagBaselineState(tagConfig.TagName, _specificLogger);
                _tagBaselineStates[tagConfig.TagName] = baselineState;
                _specificLogger.Warning(
                    "Baseline state voor Modbus tag {TagName} on-the-fly aangemaakt.",
                    tagConfig.TagName
                );
            }

            if (!baselineState.IsBaselineEstablished)
            {
                baselineState.AddDataPoint(
                    numericValue,
                    tagConfig.BaselineSampleSize,
                    out bool baselineJustEstablished
                );
                return false;
            }
            else
            {
                if (baselineState.BaselineStandardDeviation == 0)
                {
                    bool isDifferent = numericValue != baselineState.BaselineMean;
                    if (isDifferent)
                        _specificLogger.Verbose(
                            "Outlier (zero StdDev) Modbus: {TagName}, Waarde {NumVal} != BaselineMean {BMean}",
                            tagConfig.TagName,
                            numericValue,
                            baselineState.BaselineMean
                        );
                    return isDifferent;
                }
                double deviation = Math.Abs(numericValue - baselineState.BaselineMean);
                bool isOutlier =
                    deviation
                    > (
                        tagConfig.OutlierStandardDeviationFactor
                        * baselineState.BaselineStandardDeviation
                    );
                if (isOutlier)
                    _specificLogger.Verbose(
                        "Outlier Modbus: {TagName}, Waarde {NumVal}, Dev {Dev}, Factor {Factor}, StdDev {StdD}",
                        tagConfig.TagName,
                        numericValue,
                        deviation,
                        tagConfig.OutlierStandardDeviationFactor,
                        baselineState.BaselineStandardDeviation
                    );
                return isOutlier;
            }
        }

        private void UpdateAndLogFinalAlarmStateModbus(
            ModbusTagConfig tagConfig,
            LoggedTagValue liveDataPoint,
            TagAlarmState newFinalState,
            double? numericValueForLog,
            double? limitDetailsForLog
        )
        {
            TagAlarmState previousStateOnLiveData = liveDataPoint.AlarmState;
            liveDataPoint.AlarmState = newFinalState;

            if (previousStateOnLiveData != newFinalState)
            {
                string valueString = numericValueForLog.HasValue
                    ? numericValueForLog.Value.ToString(CultureInfo.InvariantCulture)
                    : liveDataPoint.Value?.ToString() ?? "N/A";

                if (newFinalState != TagAlarmState.Normal && newFinalState != TagAlarmState.Error)
                {
                    string alarmDetail = "";
                    if (
                        newFinalState == TagAlarmState.Outlier
                        && _tagBaselineStates.TryGetValue(tagConfig.TagName, out var baselineState)
                    )
                    {
                        alarmDetail =
                            $"Baseline (Mean: {baselineState.BaselineMean:F2}, StdDev: {baselineState.BaselineStandardDeviation:F2})";
                    }
                    else if (limitDetailsForLog.HasValue)
                    {
                        alarmDetail =
                            $"Limiet: {limitDetailsForLog.Value.ToString(CultureInfo.InvariantCulture)}";
                    }
                    string formattedMessage = tagConfig
                        .AlarmMessageFormat.Replace("{TagName}", tagConfig.TagName)
                        .Replace("{AlarmState}", newFinalState.ToString())
                        .Replace("{Value}", valueString)
                        .Replace(
                            "{Limit}",
                            limitDetailsForLog?.ToString(CultureInfo.InvariantCulture) ?? "N/A"
                        );
                    _specificLogger.Warning(
                        "ALARMSTAAT GEWIJZIGD (Modbus): Tag {TagName} van {PreviousState} naar {NewState}. Waarde: {LiveValue}. Details: {AlarmDetail}. Bericht: {Msg}",
                        tagConfig.TagName,
                        previousStateOnLiveData,
                        newFinalState,
                        valueString,
                        alarmDetail,
                        formattedMessage
                    );
                    _statusService.SetStatus(
                        ApplicationStatus.Warning,
                        $"Alarm (Modbus): {tagConfig.TagName} is {newFinalState}"
                    );
                }
                else if (
                    newFinalState == TagAlarmState.Normal
                    && (
                        previousStateOnLiveData != TagAlarmState.Normal
                        && previousStateOnLiveData != TagAlarmState.Error
                    )
                )
                {
                    _specificLogger.Information(
                        "ALARM HERSTELD (Modbus): Tag {TagName} van {PreviousState} naar Normaal. Waarde: {LiveValue}",
                        tagConfig.TagName,
                        previousStateOnLiveData,
                        valueString
                    );
                }
                else if (
                    newFinalState == TagAlarmState.Error
                    && previousStateOnLiveData != TagAlarmState.Error
                )
                {
                    _specificLogger.Error(
                        "FOUTSTATUS (Modbus): Tag {TagName} naar status Error. Waarde: {LiveValue}",
                        tagConfig.TagName,
                        valueString
                    );
                }
            }
        }

        public void UpdateConfiguration(ModbusTcpConnectionConfig newConfig)
        {
            var currentSpecificConfig = this.ModbusConfig;
            if (currentSpecificConfig == null)
            {
                _specificLogger.Error(
                    "UpdateConfig: Huidige ModbusConfig is null voor {DisplayName}",
                    DisplayName
                );
                return;
            }
            if (newConfig == null)
            {
                _specificLogger.Error(
                    "UpdateConfig: Nieuwe config is null voor {DisplayName}",
                    DisplayName
                );
                return;
            }

            _specificLogger.Information(
                "Warme configuratie update voor Modbus {ConnectionName}",
                newConfig.ConnectionName
            );
            bool tagsOrIntervalChanged =
                currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds
                || !TagsSequentiallyEqual(
                    currentSpecificConfig.TagsToMonitor,
                    newConfig.TagsToMonitor
                );

            ConnectionConfiguration = newConfig;
            OnPropertyChanged(nameof(ModbusConfig));
            if (DisplayName != newConfig.ConnectionName)
                DisplayName = newConfig.ConnectionName;
            _modbusService.Reconfigure(newConfig);

            bool reinitializeBaselines = false;
            if (currentSpecificConfig?.TagsToMonitor != null && newConfig?.TagsToMonitor != null)
            {
                var oldOutlierTags = currentSpecificConfig
                    .TagsToMonitor.Where(t => t.IsOutlierDetectionEnabled)
                    .Select(t => new
                    {
                        t.TagName,
                        t.BaselineSampleSize,
                        t.OutlierStandardDeviationFactor,
                        t.IsActive,
                    })
                    .OrderBy(t => t.TagName)
                    .ToList();
                var newOutlierTags = newConfig
                    .TagsToMonitor.Where(t => t.IsOutlierDetectionEnabled)
                    .Select(t => new
                    {
                        t.TagName,
                        t.BaselineSampleSize,
                        t.OutlierStandardDeviationFactor,
                        t.IsActive,
                    })
                    .OrderBy(t => t.TagName)
                    .ToList();
                if (!oldOutlierTags.SequenceEqual(newOutlierTags))
                {
                    reinitializeBaselines = true;
                }
            }
            else if (newConfig?.TagsToMonitor.Any(t => t.IsOutlierDetectionEnabled) == true)
            {
                reinitializeBaselines = true;
            }

            if (reinitializeBaselines)
            {
                _specificLogger.Information(
                    "Modbus configuratie gewijzigd, herinitialiseren baseline states voor {ConnectionName}",
                    DisplayName
                );
                InitializeBaselineStates();
            }

            if (
                _scanTimer != null
                && currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds
            )
            {
                _specificLogger.Information(
                    "Scan interval voor {DisplayName} gewijzigd van {OldInterval}s naar {NewInterval}s.",
                    DisplayName,
                    currentSpecificConfig.ScanIntervalSeconds,
                    newConfig.ScanIntervalSeconds
                );
                bool restartTimer = _scanTimer.IsEnabled;
                _scanTimer.Stop();
                _scanTimer.Interval = TimeSpan.FromSeconds(
                    newConfig.ScanIntervalSeconds > 0 ? newConfig.ScanIntervalSeconds : 5
                );
                if (restartTimer && IsConnected)
                {
                    _scanTimer.Start();
                }
            }
        }

        private bool TagsSequentiallyEqual(
            ObservableCollection<ModbusTagConfig> list1,
            ObservableCollection<ModbusTagConfig> list2
        )
        {
            if (ReferenceEquals(list1, list2))
                return true;
            if (list1 == null || list2 == null)
                return false;
            if (list1.Count != list2.Count)
                return false;
            for (int i = 0; i < list1.Count; i++)
            {
                if (
                    list1[i].TagName != list2[i].TagName
                    || list1[i].Address != list2[i].Address
                    || list1[i].DataType != list2[i].DataType
                    || list1[i].RegisterType != list2[i].RegisterType
                    || list1[i].IsActive != list2[i].IsActive
                )
                    return false;
            }
            return true;
        }

        private void InitializeScanTimer()
        {
            _scanTimer = new DispatcherTimer { IsEnabled = false };
            _scanTimer.Interval = TimeSpan.FromSeconds(
                ModbusConfig?.ScanIntervalSeconds > 0 ? ModbusConfig.ScanIntervalSeconds : 5
            );
            _scanTimer.Tick += async (s, e) => await ScanTimer_TickAsync();
        }

        private async Task ScanTimer_TickAsync()
        {
            if (IsConnected)
            {
                await ReadConfiguredTagsAsync();
            }
        }

        private async Task ConnectAsync()
        {
            _statusService.SetStatus(
                ApplicationStatus.Connecting,
                $"Verbinden met Modbus: {ModbusConfig?.ConnectionName}..."
            );
            _specificLogger.Information(
                "Verbindingspoging gestart voor {ConnectionName}...",
                DisplayName
            );

            InitializeBaselineStates();

            bool success = await _modbusService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(
                    ApplicationStatus.Logging,
                    $"Verbonden met Modbus: {ModbusConfig?.ConnectionName}."
                );
                _specificLogger.Information(
                    "Verbinding succesvol voor {ConnectionName}.",
                    DisplayName
                );
                ClearData();
                _scanTimer.Start();
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Kon niet verbinden met Modbus: {ModbusConfig?.ConnectionName}."
                );
                _specificLogger.Warning("Verbinding mislukt voor {ConnectionName}.", DisplayName);
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _scanTimer.Stop();
            _specificLogger.Information(
                "Verbinding verbreken voor {ConnectionName}...",
                DisplayName
            );
            await _modbusService.DisconnectAsync();
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"Modbus verbinding verbroken: {ModbusConfig?.ConnectionName}."
            );
            _specificLogger.Information("Verbinding verbroken voor {ConnectionName}.", DisplayName);
            UpdateCommandStates();
            ClearData();
        }

        private async Task ReadConfiguredTagsAsync()
        {
            if (!IsConnected)
                return;
            _specificLogger.Debug(
                "Bezig met pollen van geconfigureerde Modbus tags voor {ConnectionName}",
                ModbusConfig?.ConnectionName
            );
            await _modbusService.PollConfiguredTagsAsync();
        }

        private void OnModbusConnectionStatusChanged(object sender, EventArgs e)
        {
            _specificLogger.Debug(
                "ModbusConnectionStatusChanged. IsConnected: {IsConnected} voor {ConnectionName}",
                _modbusService.IsConnected,
                DisplayName
            );
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();
            if (!_modbusService.IsConnected)
            {
                _scanTimer.Stop();
                ClearData();
            }
            else
            {
                if (
                    !_scanTimer.IsEnabled
                    && (ModbusConfig?.TagsToMonitor?.Any(t => t.IsActive) ?? false)
                )
                {
                    ClearData();
                    _scanTimer.Start();
                }
            }
        }

        private void ClearData()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        DataValues.Clear();
                    }
                )
            );
        }

        private void UpdateCommandStates()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
                    }
                )
            );
        }

        protected bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null)
                return false;
            try
            {
                result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
                return true;
            }
            catch
            {
                return false;
            }
        }

        private bool _disposedValue;

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    _specificLogger.Debug(
                        "Dispose(true) aangeroepen voor ModbusTabViewModel: {ConnectionName}",
                        DisplayName
                    );
                    _scanTimer?.Stop();
                    _scanTimer = null;
                    if (_modbusService != null)
                    {
                        _modbusService.ConnectionStatusChanged -= OnModbusConnectionStatusChanged;
                        _modbusService.TagsDataReceived -= OnModbusTagsDataReceived;
                        _modbusService.Dispose();
                    }
                }
                _disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\NodeAttributeViewModel.cs"
using Data_Logger.Core;
using Opc.Ua;

namespace Data_Logger.ViewModels;

public class NodeAttributeViewModel : ObservableObject
{
    private string _attributeName;
    public string AttributeName
    {
        get => _attributeName;
        set => SetProperty(ref _attributeName, value);
    }

    private object _value;
    public object Value
    {
        get => _value;
        set => SetProperty(ref _value, value);
    }

    private StatusCode _statusCode;
    public StatusCode StatusCode
    {
        get => _statusCode;
        set => SetProperty(ref _statusCode, value);
    }

    public string StatusCodeDisplay => StatusCode.ToString();
    public bool IsGood => StatusCode.IsGood(StatusCode);

    public NodeAttributeViewModel(string attributeName, object value, StatusCode statusCode)
    {
        AttributeName = attributeName;
        Value = value;
        StatusCode = statusCode;
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaNodeViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using Data_Logger.Core;
using Data_Logger.Services.Abstractions;
using Opc.Ua;

namespace Data_Logger.ViewModels
{
    public class OpcUaNodeViewModel : ObservableObject
    {
        private readonly NodeId _nodeId;
        private readonly IOpcUaService _opcUaService;
        private readonly Serilog.ILogger _logger;

        private string _displayName;
        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        private NodeClass _nodeClass;
        public NodeClass NodeClass
        {
            get => _nodeClass;
            set => SetProperty(ref _nodeClass, value);
        }

        public NodeId NodeId => _nodeId;

        private bool _isExpanded;
        public bool IsExpanded
        {
            get => _isExpanded;
            set
            {
                if (SetProperty(ref _isExpanded, value))
                {
                    if (_isExpanded && !_childrenLoaded && Children.Any(c => c == null))
                    {
                        LoadChildren();
                    }
                }
            }
        }

        public ObservableCollection<OpcUaNodeViewModel> Children { get; }

        private bool _childrenLoaded = false;

        public OpcUaNodeViewModel(
            NodeId nodeId,
            string displayName,
            NodeClass nodeClass,
            IOpcUaService opcUaService,
            Serilog.ILogger logger,
            bool hasChildren
        )
        {
            _nodeId = nodeId;
            DisplayName = displayName;
            NodeClass = nodeClass;
            _opcUaService = opcUaService;
            _logger = logger;
            Children = new ObservableCollection<OpcUaNodeViewModel>();
            if (hasChildren)
            {
                Children.Add(null);
            }
        }

        private async void LoadChildren()
        {
            _childrenLoaded = true;
            Children.Clear();

            _logger.Debug(
                "Laden van children voor OPC UA Node: {NodeIdString} - {DisplayName}",
                _nodeId.ToString(),
                DisplayName
            );

            if (_opcUaService == null || !_opcUaService.IsConnected)
            {
                _logger.Warning("Kan children niet laden: OpcUaService is null of niet verbonden.");

                return;
            }

            try
            {
                ReferenceDescriptionCollection childReferences = await _opcUaService.BrowseAsync(
                    _nodeId,
                    ct: CancellationToken.None
                );

                if (childReferences != null)
                {
                    foreach (var childData in childReferences)
                    {
                        bool hasGrandChildren =
                            childData.NodeClass == Opc.Ua.NodeClass.Object
                            || childData.NodeClass == Opc.Ua.NodeClass.View;

                        NodeId actualNodeId = null;
                        if (_opcUaService.NamespaceUris != null)
                        {
                            try
                            {
                                actualNodeId = ExpandedNodeId.ToNodeId(
                                    childData.NodeId,
                                    _opcUaService.NamespaceUris
                                );
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(
                                    ex,
                                    "Fout bij het converteren van ExpandedNodeId {ExpandedNodeId} naar NodeId voor DisplayName {DisplayName}",
                                    childData.NodeId,
                                    childData.DisplayName?.Text
                                );
                                continue;
                            }
                        }
                        else
                        {
                            _logger.Warning(
                                "NamespaceUris is null in OpcUaService, kan ExpandedNodeId niet correct converteren voor {DisplayName}",
                                childData.DisplayName?.Text
                            );

                            try
                            {
                                actualNodeId = ExpandedNodeId.ToNodeId(childData.NodeId, null);
                            }
                            catch
                            {
                                continue;
                            }
                        }

                        if (actualNodeId == null)
                            continue;

                        System.Windows.Application.Current.Dispatcher.Invoke(
                            (Action)(
                                () =>
                                {
                                    Children.Add(
                                        new OpcUaNodeViewModel(
                                            actualNodeId,
                                            childData.DisplayName?.Text ?? "Unknown",
                                            childData.NodeClass,
                                            _opcUaService,
                                            _logger,
                                            hasGrandChildren
                                        )
                                    );
                                }
                            )
                        );
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van children voor node {NodeIdString}",
                    _nodeId.ToString()
                );
            }
            OnPropertyChanged(nameof(Children));
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaTabViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.ViewModels;
using Data_Logger.ViewModels.Plotting;
using Opc.Ua;
using ScottPlot.WPF;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class OpcUaTabViewModel : TabViewModelBase, IDisposable
    {
        #region Fields
        private readonly ILogger _logger;
        private readonly IOpcUaService _opcUaService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;
        private readonly ISettingsService _settingsService;
        private bool _isBrowse = false;
        private OpcUaNodeViewModel _selectedOpcUaNode;
        private string _lastReadNodeValue = "Nog geen waarde gelezen.";

        private bool _disposedValue;
        private bool _isLoadingNodeDetails = false;
        
        public ObservableCollection<PlotTabViewModel> ActivePlotTabs { get; }
        private PlotTabViewModel _selectedPlotTab;
        public PlotTabViewModel SelectedPlotTab
        {
            get => _selectedPlotTab;
            set => SetProperty(ref _selectedPlotTab, value);
        }

        public ICommand OpenOrSelectPlotTabCommand { get; }

        #endregion

        #region Properties
        public OpcUaConnectionConfig OpcUaConfig =>
            ConnectionConfiguration as OpcUaConnectionConfig;
        public bool IsConnected => _opcUaService?.IsConnected ?? false;

        public ObservableCollection<LoggedTagValue> DataValues { get; } =
            new ObservableCollection<LoggedTagValue>();
        public ObservableCollection<OpcUaNodeViewModel> RootNodes { get; } =
            new ObservableCollection<OpcUaNodeViewModel>();
        public bool IsBrowse
        {
            get => _isBrowse;
            set
            {
                if (SetProperty(ref _isBrowse, value))
                    UpdateCommandStates();
            }
        }

        public string LastReadNodeValue
        {
            get => _lastReadNodeValue;
            set => SetProperty(ref _lastReadNodeValue, value);
        }

        public ObservableCollection<NodeAttributeViewModel> SelectedNodeAttributes { get; } =
            new ObservableCollection<NodeAttributeViewModel>();
        public ObservableCollection<ReferenceDescriptionViewModel> SelectedNodeReferences { get; } =
            new ObservableCollection<ReferenceDescriptionViewModel>();
        public bool IsLoadingNodeDetails
        {
            get => _isLoadingNodeDetails;
            set => SetProperty(ref _isLoadingNodeDetails, value);
        }

        public OpcUaNodeViewModel SelectedOpcUaNode
        {
            get => _selectedOpcUaNode;
            set
            {
                if (SetProperty(ref _selectedOpcUaNode, value))
                {
                    _logger.Debug(
                        "Geselecteerde OPC UA Node in TreeView: {DisplayName}",
                        _selectedOpcUaNode?.DisplayName ?? "null"
                    );
                    UpdateCommandStates();
                    if (_selectedOpcUaNode != null && IsConnected)
                    {
                        Task.Run(async () => await LoadSelectedNodeDetailsAsync());
                    }
                    else
                    {
                        System.Windows.Application.Current.Dispatcher.Invoke(
                            (Action)(
                                () =>
                                {
                                    SelectedNodeAttributes.Clear();
                                    SelectedNodeReferences.Clear();
                                }
                            )
                        );
                    }
                }
            }
        }
        #endregion

        #region Commands
        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }
        public ICommand ReadAllConfiguredTagsCommand { get; }
        public ICommand LoadAddressSpaceCommand { get; }
        public ICommand AddSelectedNodeToMonitoringCommand { get; }
        public ICommand RemoveSelectedNodeFromMonitoringCommand { get; }
        public ICommand ReadSelectedNodeValueCommand { get; }

        public ICommand UnmonitorTagCommand { get; }
        #endregion

        #region Constructor
        public OpcUaTabViewModel(
            OpcUaConnectionConfig config,
            ILogger logger,
            IOpcUaService opcUaService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService,
            ISettingsService settingsService
        )
            : base(config)
        {
            _logger = logger
                .ForContext<OpcUaTabViewModel>()
                .ForContext("ConnectionName", config.ConnectionName);
            _opcUaService = opcUaService ?? throw new ArgumentNullException(nameof(opcUaService));
            _statusService =
                statusService ?? throw new ArgumentNullException(nameof(statusService));
            _dataLoggingService =
                dataLoggingService ?? throw new ArgumentNullException(nameof(dataLoggingService));
            _settingsService =
                settingsService ?? throw new ArgumentNullException(nameof(settingsService));
            
            ActivePlotTabs = new ObservableCollection<PlotTabViewModel>();
            OpenOrSelectPlotTabCommand = new RelayCommand(ExecuteOpenOrSelectPlotTab, CanExecuteOpenOrSelectPlotTab);

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(
                async _ => await DisconnectAsync(),
                _ => IsConnected
            );
            ReadAllConfiguredTagsCommand = new RelayCommand(
                async _ => await ReadAllConfiguredTagsAsync(),
                _ => IsConnected
            );
            LoadAddressSpaceCommand = new RelayCommand(
                async _ => await LoadInitialAddressSpaceAsync(),
                _ => IsConnected && !IsBrowse
            );
            AddSelectedNodeToMonitoringCommand = new RelayCommand(
                param => AddSelectedNodeToMonitoring(param as OpcUaNodeViewModel),
                param => CanAddSelectedNodeToMonitoring(param as OpcUaNodeViewModel)
            );
            RemoveSelectedNodeFromMonitoringCommand = new RelayCommand(
                param => RemoveSelectedNodeFromMonitoring(param as OpcUaNodeViewModel),
                param => CanRemoveSelectedNodeFromMonitoring(param as OpcUaNodeViewModel)
            );
            ReadSelectedNodeValueCommand = new RelayCommand(
                async param => await ReadSelectedNodeValueAsync(param as OpcUaNodeViewModel),
                param => CanReadSelectedNodeValue(param as OpcUaNodeViewModel)
            );
            UnmonitorTagCommand = new RelayCommand(
                param => UnmonitorTag(param as OpcUaTagConfig),
                param => param is OpcUaTagConfig
            );
            
            _opcUaService.ConnectionStatusChanged += OnOpcUaConnectionStatusChanged;
            _opcUaService.TagsDataReceived += OnOpcUaTagsDataReceived;

            _logger.Debug("OpcUaTabViewModel geïnitialiseerd voor {ConnectionName}", DisplayName);
        }
        #endregion

        #region Connection and Data Handling
        private async Task ConnectAsync()
        {
            _statusService.SetStatus(
                ApplicationStatus.Connecting,
                $"Verbinden met OPC UA: {OpcUaConfig.ConnectionName}..."
            );
            _logger.Information("Verbindingspoging gestart voor {ConnectionName}...", DisplayName);

            if (OpcUaConfig?.TagsToMonitor != null)
            {
                foreach (
                    var tag in OpcUaConfig.TagsToMonitor.Where(t =>
                        t.IsActive && t.IsOutlierDetectionEnabled
                    )
                )
                {
                    _logger.Debug(
                        "ConnectAsync: Reset baseline voor actieve tag {TagName}",
                        tag.TagName
                    );
                    tag.ResetBaselineState();
                }
            }

            bool success = await _opcUaService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(
                    ApplicationStatus.Logging,
                    $"Verbonden met OPC UA: {OpcUaConfig.ConnectionName}."
                );
                _logger.Information("Verbinding succesvol voor {ConnectionName}.", DisplayName);

                await LoadInitialAddressSpaceAsync();
                await _opcUaService.StartMonitoringTagsAsync();
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Kon niet verbinden met OPC UA: {OpcUaConfig.ConnectionName}."
                );
                _logger.Warning("Verbinding mislukt voor {ConnectionName}.", DisplayName);
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _logger.Information("Verbinding verbreken voor {ConnectionName}...", DisplayName);
            await _opcUaService.DisconnectAsync();
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"OPC UA verbinding verbroken: {OpcUaConfig.ConnectionName}."
            );
            _logger.Information("Verbinding verbroken voor {ConnectionName}.", DisplayName);
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        RootNodes.Clear();
                        DataValues.Clear();
                    }
                )
            );
            UpdateCommandStates();
        }

        private void OnOpcUaConnectionStatusChanged(object sender, EventArgs e)
        {
            _logger.Debug(
                "OpcUaConnectionStatusChanged. IsConnected: {IsConnected} voor {ConnectionName}",
                _opcUaService.IsConnected,
                DisplayName
            );
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();

            if (!_opcUaService.IsConnected)
            {

                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            ActivePlotTabs.Clear();
                            RootNodes.Clear();
                            DataValues.Clear();
                        }
                    )
                );
            }
            else
            {
                if (!RootNodes.Any() && !IsBrowse)
                {
                    Task.Run(async () => await LoadInitialAddressSpaceAsync());
                }

                if (OpcUaConfig?.TagsToMonitor != null)
                {
                    _logger.Information(
                        "Verbinding (her)steld, baseline wordt gereset voor relevante tags in {ConnectionName}.",
                        DisplayName
                    );
                    foreach (
                        var tag in OpcUaConfig.TagsToMonitor.Where(t =>
                            t.IsActive && t.IsOutlierDetectionEnabled
                        )
                    )
                    {
                        _logger.Debug(
                            "OnOpcUaConnectionStatusChanged: Reset baseline voor actieve tag {TagName}",
                            tag.TagName
                        );
                        tag.ResetBaselineState();
                    }
                }
            }
        }

        private void OnOpcUaTagsDataReceived(
            object sender,
            IEnumerable<LoggedTagValue> receivedTagValues
        )
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            if (!tagValuesList.Any())
                return;
            _logger.Debug(
                "OnOpcUaTagsDataReceived: {Count} tag(s) ontvangen voor {ConnectionName}",
                tagValuesList.Count,
                DisplayName
            );
            
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        foreach (var liveValue in tagValuesList)
                        {
                            var configuredTag = OpcUaConfig?.TagsToMonitor.FirstOrDefault(t =>
                                t.TagName == liveValue.TagName
                            );

                            if (configuredTag != null)
                            {
                                configuredTag.CurrentValue = liveValue.Value;
                                configuredTag.Timestamp = liveValue.Timestamp;
                                configuredTag.IsGoodQuality = liveValue.IsGoodQuality;
                                configuredTag.ErrorMessage = liveValue.ErrorMessage;

                                TagAlarmState finalAlarmState;
                                double? numericValueForAlarmCheck = null;
                                double? limitDetailsForThreshold = null;

                                if (!configuredTag.IsGoodQuality)
                                {
                                    finalAlarmState = TagAlarmState.Error;
                                    if (configuredTag.IsOutlierDetectionEnabled)
                                        configuredTag.ResetBaselineState();
                                }
                                else if (
                                    !TryConvertToDouble(liveValue.Value, out double valForCheck)
                                )
                                {
                                    _logger.Warning(
                                        "Waarde '{RawValue}' voor tag '{TagName}' kon niet naar double voor alarm/outlier check.",
                                        liveValue.Value,
                                        configuredTag.TagName
                                    );
                                    finalAlarmState = TagAlarmState.Error;
                                    if (configuredTag.IsOutlierDetectionEnabled)
                                        configuredTag.ResetBaselineState();
                                }
                                else
                                {
                                    numericValueForAlarmCheck = valForCheck;
                                    TagAlarmState thresholdState = DetermineThresholdAlarmState(
                                        configuredTag,
                                        numericValueForAlarmCheck.Value,
                                        out limitDetailsForThreshold
                                    );
                                    bool isOutlier = IsCurrentValueOutlier(
                                        configuredTag,
                                        numericValueForAlarmCheck.Value
                                    );
                                    if (isOutlier)
                                    {
                                        finalAlarmState = TagAlarmState.Outlier;
                                    }
                                    else
                                    {
                                        finalAlarmState = thresholdState;
                                    }
                                }

                                UpdateAndLogFinalAlarmState(
                                    configuredTag,
                                    liveValue,
                                    finalAlarmState,
                                    numericValueForAlarmCheck,
                                    limitDetailsForThreshold
                                );
                                
                                var plotTab = ActivePlotTabs.FirstOrDefault(pt => pt.TagIdentifier == configuredTag.NodeId);
                                if (plotTab != null && liveValue.IsGoodQuality)
                                {
                                    plotTab.AddDataPoint(liveValue.Timestamp, liveValue.Value);
                                }
                            }
                            else
                            {
                                _logger.Verbose(
                                    "OnOpcUaTagsDataReceived: Geen geconfigureerde tag gevonden voor TagName '{TagName}'",
                                    liveValue.TagName
                                );
                            }
                        }
                    }
                )
            );
            _dataLoggingService.LogTagValues(OpcUaConfig.ConnectionName, tagValuesList);
        }
        #endregion

        #region Simple Threshold Alarm Logic
        private void CheckAndSetThresholdAlarmState(
            OpcUaTagConfig tagConfig,
            LoggedTagValue liveValue
        )
        {
            if (
                tagConfig == null
                || !tagConfig.IsAlarmingEnabled
                || liveValue == null
                || !liveValue.IsGoodQuality
            )
            {
                TagAlarmState nonAlarmState = liveValue.IsGoodQuality
                    ? TagAlarmState.Normal
                    : TagAlarmState.Error;
                SetFinalAlarmState(tagConfig, liveValue, nonAlarmState, null, null);
                return;
            }

            if (!TryConvertToDouble(liveValue.Value, out double numericValue))
            {
                _logger.Warning(
                    "Waarde '{Value}' voor tag '{TagName}' kon niet naar double voor drempel alarmcheck.",
                    liveValue.Value,
                    tagConfig.TagName
                );
                SetFinalAlarmState(tagConfig, liveValue, TagAlarmState.Error, null, null);
                return;
            }

            TagAlarmState newAlarmState = TagAlarmState.Normal;
            double? limitExceeded = null;

            if (tagConfig.HighHighLimit.HasValue && numericValue >= tagConfig.HighHighLimit.Value)
            {
                newAlarmState = TagAlarmState.HighHigh;
                limitExceeded = tagConfig.HighHighLimit.Value;
            }
            else if (tagConfig.HighLimit.HasValue && numericValue >= tagConfig.HighLimit.Value)
            {
                newAlarmState = TagAlarmState.High;
                limitExceeded = tagConfig.HighLimit.Value;
            }
            else if (tagConfig.LowLowLimit.HasValue && numericValue <= tagConfig.LowLowLimit.Value)
            {
                newAlarmState = TagAlarmState.LowLow;
                limitExceeded = tagConfig.LowLowLimit.Value;
            }
            else if (tagConfig.LowLimit.HasValue && numericValue <= tagConfig.LowLimit.Value)
            {
                newAlarmState = TagAlarmState.Low;
                limitExceeded = tagConfig.LowLimit.Value;
            }

            SetFinalAlarmState(tagConfig, liveValue, newAlarmState, numericValue, limitExceeded);
        }

        private void SetFinalAlarmState(
            OpcUaTagConfig tagConfig,
            LoggedTagValue liveValue,
            TagAlarmState newFinalState,
            double? numericValueForLog,
            double? limitDetailsForLog
        )
        {
            liveValue.AlarmState = newFinalState;
            if (tagConfig.CurrentAlarmState != newFinalState)
            {
                var previousState = tagConfig.CurrentAlarmState;
                tagConfig.CurrentAlarmState = newFinalState;
                string valueString = numericValueForLog.HasValue
                    ? numericValueForLog.Value.ToString(CultureInfo.InvariantCulture)
                    : liveValue.Value?.ToString() ?? "N/A";

                if (newFinalState != TagAlarmState.Normal && newFinalState != TagAlarmState.Error)
                {
                    tagConfig.AlarmTimestamp = liveValue.Timestamp;
                    string formattedMessage = tagConfig
                        .AlarmMessageFormat.Replace("{TagName}", tagConfig.TagName)
                        .Replace("{AlarmState}", newFinalState.ToString())
                        .Replace("{Value}", valueString)
                        .Replace(
                            "{Limit}",
                            limitDetailsForLog?.ToString(CultureInfo.InvariantCulture) ?? "N/A"
                        );
                    _logger.Warning(
                        "ALARMSTAAT GEWIJZIGD: Tag {TagName} van {PreviousState} naar {NewState}. Waarde: {LiveValue}. Limiet: {Limit}. Bericht: {Msg}",
                        tagConfig.TagName,
                        previousState,
                        newFinalState,
                        valueString,
                        limitDetailsForLog?.ToString(CultureInfo.InvariantCulture) ?? "N/A",
                        formattedMessage
                    );
                    _statusService.SetStatus(
                        ApplicationStatus.Warning,
                        $"Alarm: {tagConfig.TagName} is {newFinalState}"
                    );
                }
                else if (
                    newFinalState == TagAlarmState.Normal
                    && (
                        previousState != TagAlarmState.Normal
                        && previousState != TagAlarmState.Error
                    )
                )
                {
                    tagConfig.AlarmTimestamp = null;
                    _logger.Information(
                        "ALARM HERSTELD: Tag {TagName} van {PreviousState} naar Normaal. Waarde: {LiveValue}",
                        tagConfig.TagName,
                        previousState,
                        valueString
                    );
                }
                else if (
                    newFinalState == TagAlarmState.Error
                    && previousState != TagAlarmState.Error
                )
                {
                    tagConfig.AlarmTimestamp = liveValue.Timestamp;
                    _logger.Error(
                        "FOUTSTATUS: Tag {TagName} naar status Error. Waarde: {LiveValue}",
                        tagConfig.TagName,
                        valueString
                    );
                }
            }
        }

        private bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null)
                return false;
            if (value is double d)
            {
                result = d;
                return true;
            }
            if (value is float f)
            {
                result = (double)f;
                return true;
            }
            if (value is int i)
            {
                result = i;
                return true;
            }
            if (value is uint ui)
            {
                result = ui;
                return true;
            }
            if (value is short s)
            {
                result = s;
                return true;
            }
            if (value is ushort us)
            {
                result = us;
                return true;
            }
            if (value is long l)
            {
                result = l;
                return true;
            }
            if (value is ulong ul)
            {
                result = ul;
                return true;
            }
            if (value is byte b)
            {
                result = b;
                return true;
            }
            if (value is sbyte sb)
            {
                result = sb;
                return true;
            }
            if (value is decimal dec)
            {
                result = (double)dec;
                return true;
            }
            try
            {
                result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
                return true;
            }
            catch
            {
                return false;
            }
        }
        #endregion

        #region Configuration Handling
        public void UpdateConfiguration(OpcUaConnectionConfig newConfig)
        {
            _logger.Information(
                "Warme configuratie update (via Settings) voor OPC UA verbinding {ConnectionName}",
                newConfig.ConnectionName
            );
            OpcUaConnectionConfig oldConfigTyped = OpcUaConfig;
            ConnectionConfiguration = newConfig;
            OnPropertyChanged(nameof(OpcUaConfig));
            if (DisplayName != newConfig.ConnectionName)
                DisplayName = newConfig.ConnectionName;
            _opcUaService.Reconfigure(newConfig);
        }

        private bool DidActiveMonitoringTagsChange(
            OpcUaConnectionConfig oldConfig,
            OpcUaConnectionConfig newConfig
        )
        {
            if (oldConfig == null || newConfig == null)
                return true;
            var oldActiveTags = oldConfig
                .TagsToMonitor.Where(t => t.IsActive)
                .Select(t => t.NodeId)
                .OrderBy(id => id)
                .ToList();
            var newActiveTags = newConfig
                .TagsToMonitor.Where(t => t.IsActive)
                .Select(t => t.NodeId)
                .OrderBy(id => id)
                .ToList();
            return !oldActiveTags.SequenceEqual(newActiveTags);
        }
        #endregion

        #region Node Browser Logic (Behouden)
        private async Task LoadInitialAddressSpaceAsync()
        {
            if (!IsConnected || _opcUaService == null)
                return;
            if (IsBrowse)
                return;
            IsBrowse = true;
            _logger.Information(
                "Laden van initiële OPC UA address space voor {ConnectionName}",
                DisplayName
            );
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() => RootNodes.Clear()));

            try
            {
                ReferenceDescriptionCollection rootItems = await _opcUaService.BrowseRootAsync();
                if (rootItems != null)
                {
                    var namespaceUris = _opcUaService.NamespaceUris;
                    foreach (var item in rootItems)
                    {
                        bool hasChildren =
                            item.NodeClass == NodeClass.Object || item.NodeClass == NodeClass.View;
                        NodeId nodeId = null;
                        if (namespaceUris != null)
                        {
                            try
                            {
                                nodeId = ExpandedNodeId.ToNodeId(item.NodeId, namespaceUris);
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(
                                    ex,
                                    "Fout bij converteren root ExpandedNodeId {ExpNodeId} voor {ItemDisplayName}",
                                    item.NodeId,
                                    item.DisplayName?.Text
                                );
                            }
                        }
                        else
                        {
                            _logger.Warning(
                                "NamespaceUris is null, kan ExpandedNodeId niet converteren voor {ItemDisplayName}",
                                item.DisplayName?.Text
                            );
                            try
                            {
                                nodeId = ExpandedNodeId.ToNodeId(item.NodeId, null);
                            }
                            catch
                            { /* ignore */
                            }
                        }

                        if (nodeId != null)
                        {
                            System.Windows.Application.Current.Dispatcher.Invoke(
                                (Action)(
                                    () =>
                                        RootNodes.Add(
                                            new OpcUaNodeViewModel(
                                                nodeId,
                                                item.DisplayName?.Text ?? "Unknown",
                                                item.NodeClass,
                                                _opcUaService,
                                                _logger,
                                                hasChildren
                                            )
                                        )
                                )
                            );
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van de initiële address space voor {ConnectionName}",
                    DisplayName
                );
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Fout bij laden address space: {ex.Message}"
                );
            }
            finally
            {
                IsBrowse = false;
            }
        }
        #endregion

        #region Node Details Logic (Behouden)
        private async Task LoadSelectedNodeDetailsAsync()
        {
            if (SelectedOpcUaNode == null || _opcUaService == null || !_opcUaService.IsConnected)
            {
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            SelectedNodeAttributes.Clear();
                            SelectedNodeReferences.Clear();
                        }
                    )
                );
                return;
            }
            IsLoadingNodeDetails = true;
            _logger.Information(
                "Laden van details voor geselecteerde node: {NodeId}",
                SelectedOpcUaNode.NodeId
            );
            try
            {
                var attributes = await _opcUaService.ReadNodeAttributesAsync(
                    SelectedOpcUaNode.NodeId
                );
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            SelectedNodeAttributes.Clear();
                            foreach (var attr in attributes)
                                SelectedNodeAttributes.Add(attr);
                        }
                    )
                );
                var references = await _opcUaService.BrowseAllReferencesAsync(
                    SelectedOpcUaNode.NodeId
                );
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            SelectedNodeReferences.Clear();
                            if (references != null)
                            {
                                var nsUris = _opcUaService.NamespaceUris;
                                foreach (var rd in references)
                                {
                                    NodeId targetId = null;
                                    if (nsUris != null)
                                        try
                                        {
                                            targetId = ExpandedNodeId.ToNodeId(rd.NodeId, nsUris);
                                        }
                                        catch (Exception ex)
                                        {
                                            _logger.Error(
                                                ex,
                                                "Fout conv target ExNId {ExNId} voor ref naar {DN}",
                                                rd.NodeId,
                                                rd.DisplayName?.Text
                                            );
                                        }
                                    else
                                        try
                                        {
                                            targetId = ExpandedNodeId.ToNodeId(rd.NodeId, null);
                                        }
                                        catch { }
                                    if (targetId != null)
                                    {
                                        string refTypeDisp = rd.ReferenceTypeId.ToString();
                                        Task.Run(async () =>
                                                await _opcUaService.ReadNodeDisplayNameAsync(
                                                    ExpandedNodeId.ToNodeId(
                                                        rd.ReferenceTypeId,
                                                        nsUris
                                                    )
                                                )
                                            )
                                            .ContinueWith(
                                                t =>
                                                {
                                                    if (
                                                        t.Result != null
                                                        && !LocalizedText.IsNullOrEmpty(t.Result)
                                                    )
                                                        refTypeDisp = t.Result.Text;
                                                },
                                                TaskScheduler.FromCurrentSynchronizationContext()
                                            )
                                            .Wait();
                                        SelectedNodeReferences.Add(
                                            new ReferenceDescriptionViewModel(
                                                rd,
                                                ExpandedNodeId.ToNodeId(rd.ReferenceTypeId, nsUris),
                                                refTypeDisp,
                                                rd.IsForward,
                                                targetId
                                            )
                                        );
                                    }
                                }
                            }
                        }
                    )
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van node details voor {NodeId}",
                    SelectedOpcUaNode.NodeId
                );
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Fout bij laden node details: {ex.Message}"
                );
            }
            finally
            {
                IsLoadingNodeDetails = false;
            }
        }
        #endregion

        #region Monitoring Configuration from TreeView & Auto-Save (Behouden)
        private bool CanAddSelectedNodeToMonitoring(OpcUaNodeViewModel node)
        {
            if (node == null)
                return false;
            bool isCorrectNodeClass = (
                node.NodeClass == NodeClass.Variable || node.NodeClass == NodeClass.VariableType
            );
            bool isAlreadyMonitored = IsNodeCurrentlyMonitored(node);
            return isCorrectNodeClass && !isAlreadyMonitored;
        }

        private bool CanRemoveSelectedNodeFromMonitoring(OpcUaNodeViewModel node)
        {
            if (node == null)
                return false;
            return IsNodeCurrentlyMonitored(node);
        }

        private bool IsNodeCurrentlyMonitored(OpcUaNodeViewModel node)
        {
            if (node == null || OpcUaConfig?.TagsToMonitor == null)
                return false;
            string nodeStringToCompare = node.NodeId.ToString();
            bool isFound = OpcUaConfig.TagsToMonitor.Any(monitoredTag =>
                monitoredTag.NodeId == nodeStringToCompare
            );

            return isFound;
        }

        private void AddSelectedNodeToMonitoring(OpcUaNodeViewModel nodeToAdd)
        {
            if (nodeToAdd == null || !CanAddSelectedNodeToMonitoring(nodeToAdd))
                return;
            var newTagConfig = new OpcUaTagConfig
            {
                TagName = nodeToAdd.DisplayName,
                NodeId = nodeToAdd.NodeId.ToString(),
                IsActive = true,
                SamplingInterval =
                    OpcUaConfig?.TagsToMonitor?.FirstOrDefault()?.SamplingInterval ?? 1000,
                DataType = OpcUaDataType.Variant,
            };
            OpcUaConfig.TagsToMonitor.Add(newTagConfig);
            _logger.Information(
                "Tag {NodeId} ({DisplayName}) toegevoegd aan monitoring.",
                newTagConfig.NodeId,
                newTagConfig.TagName
            );
            _statusService.SetStatus(
                ApplicationStatus.Saving,
                $"Tag '{newTagConfig.TagName}' toegevoegd & instellingen opslaan..."
            );
            SaveAndUpdateService();
            UpdateCommandStates();
        }

        private void RemoveSelectedNodeFromMonitoring(OpcUaNodeViewModel nodeToRemove)
        {
            if (nodeToRemove == null || !CanRemoveSelectedNodeFromMonitoring(nodeToRemove))
                return;
            var tagToRemove = OpcUaConfig.TagsToMonitor.FirstOrDefault(t =>
                t.NodeId == nodeToRemove.NodeId.ToString()
            );
            if (tagToRemove != null)
            {
                OpcUaConfig.TagsToMonitor.Remove(tagToRemove);
                _logger.Information(
                    "Tag {NodeId} ({DisplayName}) verwijderd uit monitoring.",
                    nodeToRemove.NodeId,
                    nodeToRemove.DisplayName
                );
                _statusService.SetStatus(
                    ApplicationStatus.Saving,
                    $"Tag '{nodeToRemove.DisplayName}' verwijderd & instellingen opslaan..."
                );
                SaveAndUpdateService();
                UpdateCommandStates();
            }
        }

        private void SaveAndUpdateService()
        {
            _settingsService.SaveSettings();
            _logger.Information("Instellingen automatisch opgeslagen na tag wijziging.");
            if (IsConnected)
            {
                _logger.Information(
                    "Monitoring herstarten na tag wijziging voor {ConnectionName}",
                    DisplayName
                );
                Task.Run(async () =>
                {
                    await _opcUaService.StopMonitoringTagsAsync();
                    _opcUaService.Reconfigure(OpcUaConfig);
                    await _opcUaService.StartMonitoringTagsAsync();
                    _statusService.SetStatus(
                        ApplicationStatus.Logging,
                        $"Monitoring geüpdatet voor {DisplayName}."
                    );
                });
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Idle,
                    "Tag configuratie gewijzigd en opgeslagen."
                );
            }
        }
        #endregion

        #region Node Interaction Commands (Read Value) - Plot gerelateerde commando's zijn verwijderd
        private bool CanReadSelectedNodeValue(OpcUaNodeViewModel node)
        {
            if (node == null)
                node = SelectedOpcUaNode;
            return node != null
                && IsConnected
                && (
                    node.NodeClass == NodeClass.Variable || node.NodeClass == NodeClass.VariableType
                );
        }

        private async Task ReadSelectedNodeValueAsync(OpcUaNodeViewModel nodeToRead)
        {
            if (nodeToRead == null || !CanReadSelectedNodeValue(nodeToRead))
            {
                LastReadNodeValue = "Kan waarde niet lezen.";
                return;
            }
            _logger.Information(
                "Lezen van waarde voor geselecteerde node: {NodeId}",
                nodeToRead.NodeId
            );
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Leest waarde van {nodeToRead.DisplayName}..."
            );
            try
            {
                DataValue dataValue = await _opcUaService.ReadValueAsync(nodeToRead.NodeId);
                if (dataValue != null)
                {
                    if (StatusCode.IsGood(dataValue.StatusCode))
                    {
                        LastReadNodeValue =
                            $"Waarde: {dataValue.Value?.ToString() ?? "null"} @ {dataValue.SourceTimestamp.ToLocalTime():HH:mm:ss.fff} (Kwaliteit: Goed)";
                        _logger.Information(
                            "Waarde gelezen voor {NodeId}: {Value}",
                            nodeToRead.NodeId,
                            dataValue.Value
                        );
                    }
                    else
                    {
                        LastReadNodeValue = $"Fout bij lezen: {dataValue.StatusCode}";
                        _logger.Warning(
                            "Fout bij lezen waarde voor {NodeId}: {StatusCode}",
                            nodeToRead.NodeId,
                            dataValue.StatusCode
                        );
                    }
                }
                else
                {
                    LastReadNodeValue = "Geen waarde object ontvangen.";
                    _logger.Warning(
                        "Geen DataValue object ontvangen bij lezen van {NodeId}",
                        nodeToRead.NodeId
                    );
                }
            }
            catch (Exception ex)
            {
                LastReadNodeValue = $"Fout: {ex.Message}";
                _logger.Error(
                    ex,
                    "Exception bij lezen van geselecteerde node {NodeId}",
                    nodeToRead.NodeId
                );
            }
            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar met lezen.");
        }

        private async Task ReadAllConfiguredTagsAsync()
        {
            if (!IsConnected)
            {
                _logger.Warning(
                    "Kan geconfigureerde tags niet lezen, niet verbonden: {DisplayName}",
                    DisplayName
                );
                return;
            }
            _logger.Information(
                "Eenmalige leesactie voor geconfigureerde tags gestart voor {DisplayName}",
                DisplayName
            );
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Leest geconfigureerde tags van {OpcUaConfig.ConnectionName}..."
            );
            var values = await _opcUaService.ReadCurrentTagValuesAsync();
            OnOpcUaTagsDataReceived(this, values);
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"Klaar met lezen van geconfigureerde tags van {OpcUaConfig.ConnectionName}."
            );
        }

        private void UnmonitorTag(OpcUaTagConfig tagConfig)
        {
            if (tagConfig == null || !OpcUaConfig.TagsToMonitor.Contains(tagConfig))
                return;
            _logger.Information(
                "Stopt monitoring en verwijdert tag: {TagName} ({NodeId})",
                tagConfig.TagName,
                tagConfig.NodeId
            );
            OpcUaConfig.TagsToMonitor.Remove(tagConfig);
            _statusService.SetStatus(
                ApplicationStatus.Saving,
                $"Tag '{tagConfig.TagName}' verwijderd & instellingen opslaan..."
            );
            SaveAndUpdateService();
        }

        public void SaveChangesForTagConfig(OpcUaTagConfig modifiedTagConfig)
        {
            if (modifiedTagConfig == null)
                return;
            _logger.Information(
                "Wijzigingen voor tag '{TagName}' (IsActive: {IsActive}, Interval: {Interval}) worden opgeslagen.",
                modifiedTagConfig.TagName,
                modifiedTagConfig.IsActive,
                modifiedTagConfig.SamplingInterval
            );
            _statusService.SetStatus(
                ApplicationStatus.Saving,
                $"Wijziging voor '{modifiedTagConfig.TagName}' opslaan..."
            );
            SaveAndUpdateService();
        }
        #endregion

        #region UI Update and Dispose
        private void UpdateCommandStates()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)ReadAllConfiguredTagsCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)LoadAddressSpaceCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)AddSelectedNodeToMonitoringCommand).RaiseCanExecuteChanged();
                        (
                            (RelayCommand)RemoveSelectedNodeFromMonitoringCommand
                        ).RaiseCanExecuteChanged();
                        ((RelayCommand)ReadSelectedNodeValueCommand).RaiseCanExecuteChanged();

                        ((RelayCommand)UnmonitorTagCommand).RaiseCanExecuteChanged();
                    }
                )
            );
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    _logger.Debug(
                        "Dispose(true) aangeroepen voor OpcUaTabViewModel: {ConnectionName}",
                        DisplayName
                    );
                    if (_opcUaService != null)
                    {
                        _opcUaService.ConnectionStatusChanged -= OnOpcUaConnectionStatusChanged;
                        _opcUaService.TagsDataReceived -= OnOpcUaTagsDataReceived;
                        _opcUaService.Dispose();
                    }
                    
                    System.Windows.Application.Current.Dispatcher.Invoke(
                        (Action)(
                            () =>
                            {
                                ActivePlotTabs.Clear();
                                RootNodes?.Clear();
                                DataValues?.Clear();
                            }
                        )
                    );
                }
                _disposedValue = true;
            }
        }
        #endregion

        private TagAlarmState DetermineThresholdAlarmState(
            OpcUaTagConfig tagConfig,
            double numericValue,
            out double? limitDetails
        )
        {
            limitDetails = null;
            if (!tagConfig.IsAlarmingEnabled)
            {
                return TagAlarmState.Normal;
            }
            if (tagConfig.HighHighLimit.HasValue && numericValue >= tagConfig.HighHighLimit.Value)
            {
                limitDetails = tagConfig.HighHighLimit.Value;
                return TagAlarmState.HighHigh;
            }
            if (tagConfig.HighLimit.HasValue && numericValue >= tagConfig.HighLimit.Value)
            {
                limitDetails = tagConfig.HighLimit.Value;
                return TagAlarmState.High;
            }
            if (tagConfig.LowLowLimit.HasValue && numericValue <= tagConfig.LowLowLimit.Value)
            {
                limitDetails = tagConfig.LowLowLimit.Value;
                return TagAlarmState.LowLow;
            }
            if (tagConfig.LowLimit.HasValue && numericValue <= tagConfig.LowLimit.Value)
            {
                limitDetails = tagConfig.LowLimit.Value;
                return TagAlarmState.Low;
            }
            return TagAlarmState.Normal;
        }

        private bool IsCurrentValueOutlier(OpcUaTagConfig tagConfig, double numericValue)
        {
            if (!tagConfig.IsOutlierDetectionEnabled)
            {
                return false;
            }

            tagConfig.CurrentBaselineCount++;
            tagConfig.SumOfValuesForBaseline += numericValue;
            tagConfig.SumOfSquaresForBaseline += (numericValue * numericValue);

            bool justEstablishedBaselineThisCall = false;
            if (tagConfig.CurrentBaselineCount >= 2)
            {
                tagConfig.BaselineMean =
                    tagConfig.SumOfValuesForBaseline / tagConfig.CurrentBaselineCount;
                double meanOfSquares =
                    tagConfig.SumOfSquaresForBaseline / tagConfig.CurrentBaselineCount;
                double variance = meanOfSquares - (tagConfig.BaselineMean * tagConfig.BaselineMean);

                if (variance < 0 && variance > -1e-9)
                    variance = 0;
                else if (variance < 0)
                {
                    _logger.Warning(
                        "Negatieve variantie ({Variance}) berekend voor {TagName}. Wordt op 0 gezet.",
                        variance,
                        tagConfig.TagName
                    );
                    variance = 0;
                }

                if (tagConfig.CurrentBaselineCount > 1)
                {
                    double sampleVariance =
                        variance
                        * (
                            (double)tagConfig.CurrentBaselineCount
                            / (tagConfig.CurrentBaselineCount - 1)
                        );
                    tagConfig.BaselineStandardDeviation = Math.Sqrt(sampleVariance);
                }
                else
                {
                    tagConfig.BaselineStandardDeviation = 0;
                }

                if (
                    !tagConfig.IsBaselineEstablished
                    && tagConfig.CurrentBaselineCount >= tagConfig.BaselineSampleSize
                )
                {
                    tagConfig.IsBaselineEstablished = true;
                    justEstablishedBaselineThisCall = true;
                    _logger.Information(
                        "Expanding baseline VASTGESTELD voor tag {TagName} na {Samples} samples: Mean={Mean:F2}, StdDev={StdDev:F2}",
                        tagConfig.TagName,
                        tagConfig.CurrentBaselineCount,
                        tagConfig.BaselineMean,
                        tagConfig.BaselineStandardDeviation
                    );
                }
                else if (tagConfig.IsBaselineEstablished)
                {
                    _logger.Verbose(
                        "Expanding baseline BIJGEWERKT voor {TagName} (N={N}): Mean={Mean:F2}, StdDev={StdDev:F2}",
                        tagConfig.TagName,
                        tagConfig.CurrentBaselineCount,
                        tagConfig.BaselineMean,
                        tagConfig.BaselineStandardDeviation
                    );
                }
            }
            else if (tagConfig.CurrentBaselineCount == 1)
            {
                tagConfig.BaselineMean = numericValue;
                tagConfig.BaselineStandardDeviation = 0;
                tagConfig.IsBaselineEstablished = false;
                _logger.Debug(
                    "Expanding Baseline voor {TagName}: Eerste datapunt (N=1) ontvangen: {Value}. Mean={Mean}, StdDev=0.",
                    tagConfig.TagName,
                    numericValue,
                    tagConfig.BaselineMean
                );
            }

            if (!tagConfig.IsBaselineEstablished)
            {
                return false;
            }

            if (tagConfig.BaselineStandardDeviation == 0)
            {
                bool isDifferent = numericValue != tagConfig.BaselineMean;
                if (isDifferent)
                {
                    _logger.Verbose(
                        "Outlier (zero StdDev) gedetecteerd voor {TagName}: Waarde {NumericValue} != BaselineMean {BaselineMean}",
                        tagConfig.TagName,
                        numericValue,
                        tagConfig.BaselineMean
                    );
                }
                return isDifferent;
            }

            double deviation = Math.Abs(numericValue - tagConfig.BaselineMean);
            bool isAnOutlier =
                deviation
                > (tagConfig.OutlierStandardDeviationFactor * tagConfig.BaselineStandardDeviation);
            if (isAnOutlier)
            {
                _logger.Verbose(
                    "Outlier gedetecteerd voor {TagName}: Waarde {NumericValue}. Afwijking: {Deviation:F2} > ({Factor} * {StdDev:F2} = {Threshold:F2})",
                    tagConfig.TagName,
                    numericValue,
                    deviation,
                    tagConfig.OutlierStandardDeviationFactor,
                    tagConfig.BaselineStandardDeviation,
                    (tagConfig.OutlierStandardDeviationFactor * tagConfig.BaselineStandardDeviation)
                );
            }
            return isAnOutlier;
        }

        private void UpdateAndLogFinalAlarmState(
            OpcUaTagConfig tagConfig,
            LoggedTagValue liveValue,
            TagAlarmState newFinalState,
            double? numericValueForLog,
            double? limitDetailsForLog
        )
        {
            liveValue.AlarmState = newFinalState;
            if (tagConfig.CurrentAlarmState != newFinalState)
            {
                var previousState = tagConfig.CurrentAlarmState;
                tagConfig.CurrentAlarmState = newFinalState;

                string valueString = numericValueForLog.HasValue
                    ? numericValueForLog.Value.ToString(CultureInfo.InvariantCulture)
                    : liveValue.Value?.ToString() ?? "N/A";

                if (newFinalState != TagAlarmState.Normal && newFinalState != TagAlarmState.Error)
                {
                    tagConfig.AlarmTimestamp = liveValue.Timestamp;
                    string alarmDetail = "";
                    if (newFinalState == TagAlarmState.Outlier)
                    {
                        alarmDetail =
                            $"Afwijking van baseline (Mean: {tagConfig.BaselineMean:F2}, StdDev: {tagConfig.BaselineStandardDeviation:F2}, Factor: {tagConfig.OutlierStandardDeviationFactor})";
                    }
                    else if (limitDetailsForLog.HasValue)
                    {
                        alarmDetail =
                            $"Limiet overschreden: {limitDetailsForLog.Value.ToString(CultureInfo.InvariantCulture)}";
                    }

                    string formattedMessage = tagConfig
                        .AlarmMessageFormat.Replace("{TagName}", tagConfig.TagName)
                        .Replace("{AlarmState}", newFinalState.ToString())
                        .Replace("{Value}", valueString)
                        .Replace(
                            "{Limit}",
                            limitDetailsForLog?.ToString(CultureInfo.InvariantCulture) ?? "N/A"
                        );

                    _logger.Warning(
                        "ALARMSTAAT GEWIJZIGD: Tag {TagName} van {PreviousState} naar {NewState}. Waarde: {LiveValue}. Details: {AlarmDetail}. Bericht: {FormattedMessage}",
                        tagConfig.TagName,
                        previousState,
                        newFinalState,
                        valueString,
                        alarmDetail,
                        formattedMessage
                    );
                    _statusService.SetStatus(
                        ApplicationStatus.Warning,
                        $"Alarm: {tagConfig.TagName} is {newFinalState}"
                    );
                }
                else if (
                    newFinalState == TagAlarmState.Normal
                    && (
                        previousState != TagAlarmState.Normal
                        && previousState != TagAlarmState.Error
                    )
                )
                {
                    tagConfig.AlarmTimestamp = null;
                    _logger.Information(
                        "ALARM HERSTELD: Tag {TagName} van {PreviousState} naar Normaal. Waarde: {LiveValue}",
                        tagConfig.TagName,
                        previousState,
                        valueString
                    );
                }
                else if (
                    newFinalState == TagAlarmState.Error
                    && previousState != TagAlarmState.Error
                )
                {
                    tagConfig.AlarmTimestamp = liveValue.Timestamp;
                    _logger.Error(
                        "FOUTSTATUS: Tag {TagName} naar status Error. Waarde: {LiveValue}",
                        tagConfig.TagName,
                        valueString
                    );
                }
            }
        }
        
        private bool CanExecuteOpenOrSelectPlotTab(object param)
        {
            return param is OpcUaTagConfig;
        }
        
        private void ExecuteOpenOrSelectPlotTab(object param)
        {
            if (param is OpcUaTagConfig tagConfig)
            {
                var existingPlotTab = ActivePlotTabs.FirstOrDefault(pt => pt.TagIdentifier == tagConfig.NodeId);
                if (existingPlotTab != null)
                {
                    SelectedPlotTab = existingPlotTab;
                }
                else
                {
                    // Geef het SamplingInterval van de tag mee (in ms)
                    // OpcUaTagConfig.SamplingInterval is al in ms [cite: 169]
                    int sourceIntervalMs = tagConfig.SamplingInterval > 0 ? tagConfig.SamplingInterval : 1000; // Default als 0 of negatief

                    var newPlotTab = new PlotTabViewModel(
                        tagConfig.NodeId, 
                        tagConfig.TagName,
                        _logger, 
                        RemovePlotTab
                    );
                    ActivePlotTabs.Add(newPlotTab);
                    SelectedPlotTab = newPlotTab;
                }
                _logger.Information("Plot tab geopend/geselecteerd voor: {TagName}", tagConfig.TagName);
            }
        }
        
        private void RemovePlotTab(PlotTabViewModel plotTabToRemove)
        {
            if (plotTabToRemove != null)
            {
                ActivePlotTabs.Remove(plotTabToRemove);
                _logger.Information("Plot tab gesloten voor: {Header}", plotTabToRemove.Header);
            }
        }

    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\PlotTabViewModel.cs"
// // PlotTabViewModel.cs AANGEPAST VOOR SCOTTPLOT 4 (SignalPlot met MaxRenderIndex)
// using System;
// using System.Collections.Generic;
// using System.Globalization;
// using System.Linq;
// using System.Windows.Input;
// using System.Windows.Threading;
// using Data_Logger.Core;
// using Data_Logger.Models;
// using ScottPlot; // Hoofd ScottPlot namespace
// // using ScottPlot.Plottable; // Voor specifieke plottables in SP4
// using Serilog;
//
// namespace Data_Logger.ViewModels.Plotting 
// {
//     public class PlotTabViewModel : ObservableObject, IDisposable
//     {
//         private readonly ILogger _logger;
//         private string _header;
//         private readonly Action<PlotTabViewModel> _closeAction;
//         
//         public string Header 
//         {
//             get => _header;
//             set => SetProperty(ref _header, value);
//         }
//         public string TagIdentifier { get; } 
//         public ScottPlot.Plot PlotModel { get; } = new ScottPlot.Plot(); 
//         
//         // Voor ScottPlot 4 SignalPlot met MaxRenderIndex
//         private ScottPlot.Plottable.SignalPlotXY _liveDataSignalPlot; // Of SignalPlot als X impliciet is
//         private double[] _signalXData; // Array voor X-waarden (timestamps)
//         private double[] _signalYData; // Array voor Y-waarden
//         private int _nextDataIndex = 0;
//         private const int InitialArraySize = 1000; // Begin grootte, kan later uitgebreid worden
//
//         private ScottPlot.Plottable.HLine _meanLinePlot; 
//         private ScottPlot.Plottable.Text _meanLineTextLabelPlot; 
//         private ScottPlot.Plottable.HLine _maxLinePlot;
//         private ScottPlot.Plottable.Text _maxLineTextLabelPlot;   
//         private ScottPlot.Plottable.HLine _minLinePlot;
//         private ScottPlot.Plottable.Text _minLineTextLabelPlot;   
//
//         // _historicalDataForCalculation blijft voor statistieken, maar wordt mogelijk ook gelimiteerd
//         private readonly List<PlotDataPoint> _historicalDataForCalculation = new List<PlotDataPoint>();
//         private const int MaxPointsForStats = 5000; // Limiteer voor performance van statistieken
//
//         public event EventHandler PlotModelChanged;
//         public ICommand CloseTabCommand { get; }
//         public ICommand FitDataToViewCommand { get; }
//
//         private readonly DispatcherTimer _renderTimer;
//         private bool _needsRenderUpdate = false;
//
//         public PlotTabViewModel(
//             string tagIdentifier,
//             string header,
//             ILogger logger,
//             Action<PlotTabViewModel> closeAction
//         )
//         {
//             TagIdentifier = tagIdentifier ?? throw new ArgumentNullException(nameof(tagIdentifier));
//             Header = header ?? tagIdentifier;
//             _logger = logger.ForContext<PlotTabViewModel>().ForContext("PlotTag", header);
//             _closeAction = closeAction;
//
//             CloseTabCommand = new RelayCommand(_ => _closeAction?.Invoke(this), _ => _closeAction != null);
//             FitDataToViewCommand = new RelayCommand(ExecuteFitDataToView);
//
//             // Plot en As Configuratie voor ScottPlot 4
//             PlotModel.Title(Header);
//             PlotModel.XAxis.Label("Tijd");
//             PlotModel.XAxis.DateTimeFormat(true); // Zegt de as dat het DateTime data is
//             PlotModel.YAxis.Label(""); // Linker Y-as geen label
//
//             var yAxis2 = PlotModel.YAxis2; // Rechter Y-as
//             PlotModel.YAxis2.Label("Waarde");
//             PlotModel.YAxis2.Ticks(true); // Maak rechteras zichtbaar
//             // In SP4 is het lastiger om ticks van YAxis2 te verbergen zonder de as onzichtbaar te maken.
//             // Vaak worden de kleuren van ticks/grid van YAxis2 transparant gemaakt.
//             yAxis2.TickLabelStyle(color: System.Drawing.Color.Transparent);
//             yAxis2.MajorGrid(enable: false);
//             yAxis2.MinorGrid(enable: false);
//             yAxis2.Line(false, System.Drawing.Color.Transparent, 0); // Verberg de aslijn zelf, alleen label blijft
//
//
//             // Initialiseer data arrays en SignalPlotXY
//             _signalXData = new double[InitialArraySize];
//             _signalYData = new double[InitialArraySize];
//             _liveDataSignalPlot = PlotModel.AddSignalXY(_signalXData, _signalYData);
//             _liveDataSignalPlot.Label = Header;
//             _liveDataSignalPlot.Color = System.Drawing.Color.Blue;
//             // _liveDataSignalPlot.MaxRenderIndex = -1; // Begin met niets renderen
//
//             // Hulplijnen (Mean, Min, Max) en hun labels
//             _meanLinePlot = PlotModel.AddHorizontalLine(0, color: System.Drawing.Color.Red, width: 2, style: LineStyle.Dot);
//             _meanLinePlot.Label = "Gemiddelde"; // Was .Label in SP5
//             _meanLinePlot.IsVisible = false;
//             _meanLineTextLabelPlot = PlotModel.AddText("Gem.: N/A", 0, 0, size: 10, color: System.Drawing.Color.Red);
//             _meanLineTextLabelPlot.IsVisible = false;
//             _meanLineTextLabelPlot.Alignment = Alignment.MiddleRight; // ScottPlot 4 Alignment
//             _meanLineTextLabelPlot.PixelOffsetX = -5; _meanLineTextLabelPlot.PixelOffsetY = 0;
//
//
//             _maxLinePlot = PlotModel.AddHorizontalLine(0, color: System.Drawing.Color.DarkGreen, width: 1.5f, style: LineStyle.Dash);
//             _maxLinePlot.Label = "Max Waarde"; _maxLinePlot.IsVisible = false;
//             _maxLineTextLabelPlot = PlotModel.AddText("Max: N/A", 0, 0, size: 10, color: System.Drawing.Color.DarkGreen);
//             _maxLineTextLabelPlot.IsVisible = false; _maxLineTextLabelPlot.Alignment = Alignment.UpperRight;
//             _maxLineTextLabelPlot.PixelOffsetX = -5; _maxLineTextLabelPlot.PixelOffsetY = -2;
//
//
//             _minLinePlot = PlotModel.AddHorizontalLine(0, color: System.Drawing.Color.OrangeRed, width: 1.5f, style: LineStyle.Dash);
//             _minLinePlot.Label = "Min Waarde"; _minLinePlot.IsVisible = false;
//             _minLineTextLabelPlot = PlotModel.AddText("Min: N/A", 0, 0, size: 10, color: System.Drawing.Color.OrangeRed);
//             _minLineTextLabelPlot.IsVisible = false; _minLineTextLabelPlot.Alignment = Alignment.LowerRight;
//             _minLineTextLabelPlot.PixelOffsetX = -5; _minLineTextLabelPlot.PixelOffsetY = 2;
//
//             PlotModel.Legend(true, Alignment.UpperRight);
//
//             _renderTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(50) };
//             _renderTimer.Tick += RenderTimer_Tick;
//             _renderTimer.Start();
//
//             _logger.Debug("PlotTabViewModel (ScottPlot 4 SignalXY) geïnitialiseerd voor Tag: {PlotHeader}", Header);
//             InitializePlotRender();
//         }
//
//         private void RenderTimer_Tick(object sender, EventArgs e)
//         {
//             if (_needsRenderUpdate)
//             {
//                 PlotModelChanged?.Invoke(this, EventArgs.Empty);
//                 _needsRenderUpdate = false;
//             }
//         }
//
//         private void RequestRender() { _needsRenderUpdate = true; }
//
//         private void ExecuteFitDataToView(object parameter)
//         {
//             if (PlotModel == null) return;
//
//             if (_nextDataIndex > 0) // Als er data is
//             {
//                 // PlotModel.AxisAuto(); // ScottPlot 4 manier voor volledige autoscale
//                 // Of, specifieker voor de data in SignalPlot:
//                 PlotModel.SetAxisLimits(xMin: _signalXData[0], xMax: _signalXData[_nextDataIndex -1], 
//                                         yMin: _signalYData.Take(_nextDataIndex).Min(), yMax: _signalYData.Take(_nextDataIndex).Max());
//
//                 _logger.Information("Zoom passend (X en Y) toegepast voor '{Header}'.", Header);
//             }
//             else
//             {
//                 PlotModel.SetAxisLimits( // ScottPlot 4 manier
//                     xMin: DateTime.Now.AddMinutes(-1).ToOADate(),
//                     xMax: DateTime.Now.ToOADate(),
//                     yMin: 0,
//                     yMax: 1);
//             }
//             UpdateAuxiliaryLinesAndLabels();
//             RequestRender();
//         }
//
//         public void AddDataPoint(DateTime timestamp, object valueObject)
//         {
//             if (!TryConvertToDouble(valueObject, out double numericValue))
//             {
//                 return;
//             }
//
//             // Elk punt wordt nu verwerkt (geen Nth point decimation meer)
//             System.Windows.Application.Current.Dispatcher.Invoke(() =>
//             {
//                 // Array uitbreiden indien nodig
//                 if (_nextDataIndex >= _signalXData.Length)
//                 {
//                     int newSize = _signalXData.Length * 2;
//                     _logger.Information("Plot '{Header}': Data array wordt uitgebreid naar {NewSize}", Header, newSize);
//                     Array.Resize(ref _signalXData, newSize);
//                     Array.Resize(ref _signalYData, newSize);
//                     // Belangrijk: ScottPlot opnieuw laten weten wat de data arrays zijn als ze veranderen van referentie!
//                     // Echter, SignalPlotXY (en SignalPlot) werken met de originele array referentie.
//                     // Door de array te resizen, maak je nieuwe arrays.
//                     // De SignalPlotXY moet dan opnieuw gemaakt worden of de data source moet geupdate kunnen worden.
//                     // Eenvoudiger voor nu: gebruik List<double> en converteer naar array bij renderen,
//                     // OF gebruik een DataLogger plottable als die beschikbaar is in jouw SP4 versie.
//                     // Voor nu, met SignalPlotXY en resize, moeten we de plottable data opnieuw toewijzen.
//                     // Dit is niet ideaal.
//                     // Een betere SP4 aanpak voor echt groeiende data (als DataLogger niet beschikbaar is)
//                     // is om een List<double> te gebruiken en steeds een nieuwe SignalXY toe te voegen na Clear(),
//                     // of een SignalConst te gebruiken als je X-as een vaste stap heeft.
//
//                     // **Correctie voor groeiende SignalPlotXY in ScottPlot 4 zonder steeds Clear()/Add()**:
//                     // Je kunt niet zomaar de arrays van een bestaande SignalPlotXY vervangen.
//                     // De "Partial Array Rendering" is ontworpen voor een *vaste, grote* array.
//                     // Als je echt "oneindig" wilt groeien met SignalPlotXY, moet je
//                     // periodiek de SignalPlotXY verwijderen en opnieuw toevoegen met grotere arrays.
//                     // Of, voor live data, is het vaak beter om de `DataLogger` of `DataStreamer`
//                     // types te gebruiken als die bestaan in je SP4 versie, of een Scatter met `AddPoint()`.
//
//                     // Voor nu: we houden de array resize, maar dit is suboptimaal voor SP4 SignalPlotXY.
//                     // De plottable moet mogelijk opnieuw worden toegevoegd, of de data anders beheerd.
//                 }
//
//                 _signalXData[_nextDataIndex] = timestamp.ToOADate();
//                 _signalYData[_nextDataIndex] = numericValue;
//                 _liveDataSignalPlot.MaxRenderIndex = _nextDataIndex; // Vertel de plot tot waar te renderen
//                 _nextDataIndex++;
//                 
//                 _historicalDataForCalculation.Add(new PlotDataPoint { Timestamp = timestamp, Value = numericValue });
//                 while (_historicalDataForCalculation.Count > MaxPointsForStats) // Limiteer voor statistieken
//                 {
//                     _historicalDataForCalculation.RemoveAt(0);
//                 }
//
//                 UpdateAuxiliaryLinesAndLabels();
//                 
//                 // Geen autoscale meer hier, tenzij de gebruiker "Fit Data" klikt.
//                 // De MaxRenderIndex update zorgt ervoor dat nieuwe data getoond wordt *als de assen al goed staan*.
//                 // Als de X-as niet meeschaalt, moet de gebruiker "Fit Data" gebruiken.
//                 // ScottPlot 4: PlotModel.AxisAutoX() zou de X-as kunnen aanpassen.
//                 // Laten we voor nu de X-as alleen via FitData aanpassen.
//                 // PlotModel.AxisAutoX(); // Optioneel: Alleen X-as auto-scalen
//
//                 RequestRender();
//             });
//         }
//
//         private void UpdateAuxiliaryLinesAndLabels()
//         {
//             if (!_historicalDataForCalculation.Any())
//             {
//                 _meanLinePlot.IsVisible = false; _meanLineTextLabelPlot.IsVisible = false; _meanLineTextLabelPlot.Label = "Gem.: N/A";
//                 _maxLinePlot.IsVisible = false; _maxLineTextLabelPlot.IsVisible = false; _maxLineTextLabelPlot.Label = "Max: N/A";
//                 _minLinePlot.IsVisible = false; _minLineTextLabelPlot.IsVisible = false; _minLineTextLabelPlot.Label = "Min: N/A";
//                 return;
//             }
//
//             var values = _historicalDataForCalculation.Select(pdp => pdp.Value).ToList();
//             var currentLimits = PlotModel.GetAxisLimits(); // ScottPlot 4 manier
//             double xLabelPosition = currentLimits.XMin;
//
//             if (values.Count > 1)
//             {
//                 double meanValue = values.Average();
//                 _meanLinePlot.Y = meanValue; _meanLinePlot.IsVisible = true;
//                 _meanLineTextLabelPlot.X = xLabelPosition; _meanLineTextLabelPlot.Y = meanValue;
//                 _meanLineTextLabelPlot.Label = $"Gem.: {meanValue:F2}"; _meanLineTextLabelPlot.IsVisible = true;
//             } else { /* ... */ }
//             
//             double maxValue = values.Max();
//             _maxLinePlot.Y = maxValue; _maxLinePlot.IsVisible = true;
//             _maxLineTextLabelPlot.X = xLabelPosition; _maxLineTextLabelPlot.Y = maxValue;
//             _maxLineTextLabelPlot.Label = $"Max: {maxValue:F2}"; _maxLineTextLabelPlot.IsVisible = true;
//             
//             double minValue = values.Min();
//             _minLinePlot.Y = minValue; _minLinePlot.IsVisible = true;
//             _minLineTextLabelPlot.X = xLabelPosition; _minLineTextLabelPlot.Y = minValue;
//             _minLineTextLabelPlot.Label = $"Min: {minValue:F2}"; _minLineTextLabelPlot.IsVisible = true;
//         }
//
//         public void InitializePlotRender()
//         {
//             ExecuteFitDataToView(null);
//         }
//
//         private bool TryConvertToDouble(object value, out double result)
//         {
//             // ... (Implementatie zoals eerder) ...
//             result = 0;
//             if (value == null) return false;
//             if (value is double d) { result = d; return true; }
//             if (value is float f) { result = (double)f; return true; }
//             if (value is int i1) { result = (double)i1; return true; } 
//             if (value is uint ui) { result = (double)ui; return true; }
//             if (value is long l) { result = (double)l; return true; }
//             if (value is ulong ul) { result = (double)ul; return true; }
//             if (value is short s) { result = (double)s; return true; }
//             if (value is ushort us) { result = (double)us; return true; }
//             if (value is byte b) { result = (double)b; return true; }
//             if (value is sbyte sb) { result = (double)sb; return true; }
//             if (value is decimal dec) { result = (double)dec; return true; }
//             if (value is string sValue)
//             {
//                 if (double.TryParse(sValue, NumberStyles.Any, CultureInfo.InvariantCulture, out double parsedDouble))
//                 { result = parsedDouble; return true; }
//                 else if (double.TryParse(sValue, NumberStyles.Any, CultureInfo.CurrentCulture, out parsedDouble))
//                 { result = parsedDouble; return true; }
//                 else if (double.TryParse(sValue, NumberStyles.Any, new CultureInfo("nl-NL"), out parsedDouble))
//                 { result = parsedDouble; return true; }
//             }
//             try
//             {
//                 result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
//                 return true;
//             }
//             catch (Exception ex)
//             {
//                 if (!(value is string)) 
//                 {
//                     _logger.Error( ex, "Fout bij converteren van type '{ValueType}' met waarde '{ValueObject}' naar double.", value.GetType().Name, value);
//                 }
//                 return false;
//             }
//         }
//         
//         private bool _disposedValue;
//         protected virtual void Dispose(bool disposing)
//         {
//             if (!_disposedValue)
//             {
//                 if (disposing)
//                 {
//                     _renderTimer?.Stop();
//                     if(_renderTimer != null) _renderTimer.Tick -= RenderTimer_Tick;
//                     // Geen AxesChanged handler meer van PlotModel om los te koppelen
//                     _logger.Debug("PlotTabViewModel voor '{Header}' wordt gedisposed.", Header);
//                 }
//                 _disposedValue = true;
//             }
//         }
//
//         public void Dispose()
//         {
//             Dispose(disposing: true);
//             GC.SuppressFinalize(this);
//         }
//     }
// }
//
// // using System;
// // using System.Collections.Generic;
// // using System.Globalization;
// // using System.Linq;
// // using System.Windows.Input;
// // using System.Windows.Threading;
// // using Data_Logger.Core;
// // using Data_Logger.Models;
// // using ScottPlot;
// // using ScottPlot.Plottables;
// // using Serilog;
// //
// // namespace Data_Logger.ViewModels
// // {
// //     public class PlotTabViewModel : ObservableObject, IDisposable
// //     {
// //         private readonly ILogger _logger;
// //         private string _header;
// //         private readonly Action<PlotTabViewModel> _closeAction;
// //
// //         public string Header
// //         {
// //             get => _header;
// //             set => SetProperty(ref _header, value);
// //         }
// //
// //         public string TagIdentifier { get; }
// //         public ScottPlot.Plot PlotModel { get; } = new ScottPlot.Plot();
// //
// //         private readonly DataLogger _liveDataPlot;
// //         private readonly HorizontalLine _meanLinePlot;
// //         private readonly HorizontalLine _maxLinePlot;
// //         private readonly HorizontalLine _minLinePlot;
// //
// //         private readonly List<PlotDataPoint> _historicalDataForCalculation =
// //             new List<PlotDataPoint>();
// //
// //         private int _dataPointCounter = 0;
// //
// //         public event EventHandler PlotModelChanged;
// //         public ICommand CloseTabCommand { get; }
// //         public ICommand FitDataToViewCommand { get; }
// //
// //         private DispatcherTimer _renderTimer;
// //         private bool _needsRenderUpdate = false;
// //
// //         public PlotTabViewModel(
// //             string tagIdentifier,
// //             string header,
// //             ILogger logger,
// //             Action<PlotTabViewModel> closeAction
// //         )
// //         {
// //             TagIdentifier = tagIdentifier ?? throw new ArgumentNullException(nameof(tagIdentifier));
// //             Header = header ?? tagIdentifier;
// //             _logger = logger.ForContext<PlotTabViewModel>().ForContext("PlotTag", header);
// //             _closeAction = closeAction;
// //
// //             CloseTabCommand = new RelayCommand(
// //                 _ => _closeAction?.Invoke(this),
// //                 _ => _closeAction != null
// //             );
// //             FitDataToViewCommand = new RelayCommand(ExecuteFitDataToView);
// //
// //             PlotModel.Axes.DateTimeTicksBottom();
// //             PlotModel.Title(Header);
// //
// //             _liveDataPlot = PlotModel.Add.DataLogger();
// //             _liveDataPlot.LegendText = Header;
// //             _liveDataPlot.ManageAxisLimits = false;
// //
// //             _meanLinePlot = PlotModel.Add.HorizontalLine(0);
// //             _meanLinePlot.LegendText = "Gemiddelde";
// //             _meanLinePlot.Color = Colors.Red;
// //             _meanLinePlot.LineWidth = 2;
// //             _meanLinePlot.LinePattern = LinePattern.Dotted;
// //             _meanLinePlot.IsVisible = false;
// //             _meanLinePlot.Text = $"Gem.: N/A";
// //
// //             _maxLinePlot = PlotModel.Add.HorizontalLine(0);
// //             _maxLinePlot.LegendText = "Max Waarde";
// //             _maxLinePlot.Color = Colors.DarkGreen;
// //             _maxLinePlot.LineWidth = 1.5f;
// //             _maxLinePlot.LinePattern = LinePattern.Dashed;
// //             _maxLinePlot.IsVisible = false;
// //             _meanLinePlot.Text = $"Max: N/A";
// //
// //             _minLinePlot = PlotModel.Add.HorizontalLine(0);
// //             _minLinePlot.LegendText = "Min Waarde";
// //             _minLinePlot.Color = Colors.OrangeRed;
// //             _minLinePlot.LineWidth = 1.5f;
// //             _minLinePlot.LinePattern = LinePattern.Dashed;
// //             _minLinePlot.IsVisible = false;
// //             _meanLinePlot.Text = $"Min: N/A";
// //
// //             PlotModel.Legend.IsVisible = true;
// //             PlotModel.Legend.Alignment = Alignment.UpperRight;
// //
// //             _logger.Debug(
// //                 "PlotTabViewModel (DataLogger) geïnitialiseerd voor Tag: {PlotHeader}",
// //                 Header
// //             );
// //
// //             _renderTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(50) };
// //             _renderTimer.Tick += RenderTimer_Tick;
// //             _renderTimer.Start();
// //
// //             InitializePlotRender();
// //         }
// //
// //         private void RenderTimer_Tick(object sender, EventArgs e)
// //         {
// //             if (_needsRenderUpdate)
// //             {
// //                 PlotModelChanged?.Invoke(this, EventArgs.Empty); // Signaleer de View
// //                 _needsRenderUpdate = false;
// //             }
// //         }
// //
// //         private void RequestRender()
// //         {
// //             _needsRenderUpdate = true;
// //         }
// //
// //         private void ExecuteFitDataToView(object parameter)
// //         {
// //             if (PlotModel == null)
// //                 return;
// //             AxisLimits dataLimits = _liveDataPlot.GetAxisLimits();
// //             try
// //             {
// //                 if (dataLimits.IsReal && dataLimits.HasArea)
// //                 {
// //                     PlotModel.Axes.SetLimits(dataLimits);
// //                 }
// //                 else if (_historicalDataForCalculation.Any())
// //                 {
// //                     PlotModel.Axes.AutoScale();
// //                 }
// //                 else
// //                 {
// //                     PlotModel.Axes.SetLimitsX(
// //                         DateTime.Now.AddMinutes(-1).ToOADate(),
// //                         DateTime.Now.ToOADate()
// //                     );
// //                     PlotModel.Axes.SetLimitsY(0, 1);
// //                 }
// //             }
// //             finally
// //             {
// //             }
// //             _logger.Information("Zoom passend (X en Y) toegepast voor '{Header}'.", Header);
// //             UpdateAuxiliaryLinesAndLabels();
// //             RequestRender();
// //         }
// //
// //         public void AddDataPoint(DateTime timestamp, object valueObject)
// //         {
// //             if (!TryConvertToDouble(valueObject, out double numericValue))
// //             {
// //                 _logger.Warning(
// //                     "Waarde '{ValueObject}' voor tag '{Header}' kon niet naar double voor plotting.",
// //                     valueObject,
// //                     Header
// //                 );
// //                 return;
// //             }
// //
// //             System.Windows.Application.Current.Dispatcher.Invoke(() =>
// //             {
// //                 Coordinates newCoord = new Coordinates(timestamp.ToOADate(), numericValue);
// //                 _liveDataPlot.Add(newCoord);
// //                 _historicalDataForCalculation.Add(
// //                     new PlotDataPoint { Timestamp = timestamp, Value = numericValue }
// //                 );
// //                 UpdateAuxiliaryLinesAndLabels();
// //                 RequestRender();
// //             });
// //         }
// //
// //         private void UpdateAuxiliaryLinesAndLabels()
// //         {
// //             if (!_historicalDataForCalculation.Any())
// //             {
// //                 _meanLinePlot.IsVisible = false;
// //                 _maxLinePlot.IsVisible = false;
// //                 _minLinePlot.IsVisible = false;
// //                 return;
// //             }
// //
// //             var values = _historicalDataForCalculation.Select(pdp => pdp.Value).ToList();
// //             AxisLimits currentLimits = PlotModel.Axes.GetLimits();
// //             double xLabelPosition = currentLimits.IsReal
// //                 ? currentLimits.XRange.Min
// //                 : DateTime.Now.ToOADate();
// //
// //             if (values.Count > 1)
// //             {
// //                 double meanValue = values.Average();
// //                 _meanLinePlot.Y = meanValue;
// //                 _meanLinePlot.IsVisible = true;
// //                 _meanLinePlot.LabelText = $"Gem: {meanValue:F0}";
// //             }
// //             else
// //             {
// //                 _meanLinePlot.IsVisible = false;
// //             }
// //
// //             double maxValue = values.Max();
// //             _maxLinePlot.Y = maxValue;
// //             _maxLinePlot.IsVisible = true;
// //
// //             _maxLinePlot.LabelText = $"Max: {maxValue:F0}";
// //             _maxLinePlot.IsVisible = true;
// //
// //             double minValue = values.Min();
// //             _minLinePlot.Y = minValue;
// //             _minLinePlot.IsVisible = true;
// //
// //             _minLinePlot.LabelText = $"Min: {minValue:F0}";
// //             _minLinePlot.IsVisible = true;
// //         }
// //
// //         // private void OnPlotModelChanged()
// //         // {
// //         //     PlotModelChanged?.Invoke(this, EventArgs.Empty);
// //         // }
// //
// //         public void InitializePlotRender()
// //         {
// //             ExecuteFitDataToView(null);
// //         }
// //
// //         private bool TryConvertToDouble(object value, out double result)
// //         {
// //             result = 0;
// //
// //             if (value == null)
// //                 return false;
// //
// //             if (value is double d)
// //             {
// //                 result = d;
// //
// //                 return true;
// //             }
// //
// //             if (value is float f)
// //             {
// //                 result = (double)f;
// //
// //                 return true;
// //             }
// //
// //             if (value is int i1)
// //             {
// //                 result = (double)i1;
// //
// //                 return true;
// //             }
// //
// //             if (value is uint ui)
// //             {
// //                 result = (double)ui;
// //
// //                 return true;
// //             }
// //
// //             if (value is long l)
// //             {
// //                 result = (double)l;
// //
// //                 return true;
// //             }
// //
// //             if (value is ulong ul)
// //             {
// //                 result = (double)ul;
// //
// //                 return true;
// //             }
// //
// //             if (value is short s)
// //             {
// //                 result = (double)s;
// //
// //                 return true;
// //             }
// //
// //             if (value is ushort us)
// //             {
// //                 result = (double)us;
// //
// //                 return true;
// //             }
// //
// //             if (value is byte b)
// //             {
// //                 result = (double)b;
// //
// //                 return true;
// //             }
// //
// //             if (value is sbyte sb)
// //             {
// //                 result = (double)sb;
// //
// //                 return true;
// //             }
// //
// //             if (value is decimal dec)
// //             {
// //                 result = (double)dec;
// //
// //                 return true;
// //             }
// //
// //             if (value is string sValue)
// //             {
// //                 if (
// //                     double.TryParse(
// //                         sValue,
// //                         NumberStyles.Any,
// //                         CultureInfo.InvariantCulture,
// //                         out double parsedDouble
// //                     )
// //                 )
// //                 {
// //                     result = parsedDouble;
// //
// //                     return true;
// //                 }
// //                 else if (
// //                     double.TryParse(
// //                         sValue,
// //                         NumberStyles.Any,
// //                         CultureInfo.CurrentCulture,
// //                         out parsedDouble
// //                     )
// //                 )
// //                 {
// //                     result = parsedDouble;
// //
// //                     return true;
// //                 }
// //                 else if (
// //                     double.TryParse(
// //                         sValue,
// //                         NumberStyles.Any,
// //                         new CultureInfo("nl-NL"),
// //                         out parsedDouble
// //                     )
// //                 )
// //                 {
// //                     result = parsedDouble;
// //
// //                     return true;
// //                 }
// //             }
// //
// //             try
// //             {
// //                 result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
// //                 return true;
// //             }
// //             catch (Exception ex)
// //             {
// //                 if (!(value is string))
// //                 {
// //                     _logger.Error(
// //                         ex,
// //                         "Fout bij converteren van type '{ValueType}' met waarde '{ValueObject}' naar double.",
// //                         value.GetType().Name,
// //                         value
// //                     );
// //                 }
// //
// //                 return false;
// //             }
// //         }
// //
// //         private bool _disposedValue;
// //
// //         protected virtual void Dispose(bool disposing)
// //         {
// //             if (!_disposedValue)
// //             {
// //                 if (disposing)
// //                 {
// //                     _renderTimer?.Stop();
// //                     if (_renderTimer != null)
// //                         _renderTimer.Tick -= RenderTimer_Tick;
// //
// //                     _logger.Debug("PlotTabViewModel voor '{Header}' wordt gedisposed.", Header);
// //                 }
// //                 _disposedValue = true;
// //             }
// //         }
// //
// //         public void Dispose()
// //         {
// //             Dispose(disposing: true);
// //             GC.SuppressFinalize(this);
// //         }
// //     }
// // }




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ReferenceDescriptionViewModel.cs"
using Data_Logger.Core;
using Opc.Ua;

namespace Data_Logger.ViewModels;

public class ReferenceDescriptionViewModel : ObservableObject
{
    public NodeId ReferenceTypeId { get; }
    public string ReferenceTypeDisplay { get; }
    public bool IsForward { get; }
    public NodeId TargetNodeId { get; }
    public string TargetNodeIdString => TargetNodeId?.ToString() ?? "N/A";
    public NodeClass TargetNodeClass { get; }
    public string TargetBrowseName { get; }
    public string TargetDisplayName { get; }

    public ReferenceDescriptionViewModel(
        ReferenceDescription rd,
        NodeId referenceTypeId,
        string referenceTypeDisplay,
        bool isForward,
        NodeId targetNodeId
    )
    {
        ReferenceTypeId = referenceTypeId;
        ReferenceTypeDisplay = referenceTypeDisplay;
        IsForward = isForward;
        TargetNodeId = targetNodeId;
        TargetNodeClass = rd.NodeClass;
        TargetBrowseName = rd.BrowseName?.ToString() ?? "N/A";
        TargetDisplayName = rd.DisplayName?.Text ?? "N/A";
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\SettingsViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class SettingsViewModel : ObservableObject
    {
        private readonly ISettingsService _settingsService;
        private readonly IStatusService _statusService;
        private readonly ILogger _logger;

        private ObservableCollection<ConnectionConfigBase> _workingConnections;
        public ObservableCollection<ConnectionConfigBase> WorkingConnections
        {
            get => _workingConnections;
            set => SetProperty(ref _workingConnections, value);
        }

        private ConnectionConfigBase _selectedConnection;
        public ConnectionConfigBase SelectedConnection
        {
            get => _selectedConnection;
            set
            {
                if (SetProperty(ref _selectedConnection, value))
                {
                    ((RelayCommand)RemoveConnectionCommand).RaiseCanExecuteChanged();
                }
            }
        }

        public ICommand AddOpcUaConnectionCommand { get; }
        public ICommand AddModbusTcpConnectionCommand { get; }
        public ICommand RemoveConnectionCommand { get; }
        public ICommand SaveCommand { get; }
        public ICommand CancelCommand { get; }

        private Action _closeWindowAction;

        private ModbusTagConfig _selectedModbusTagInGrid;
        public ModbusTagConfig SelectedModbusTagInGrid
        {
            get => _selectedModbusTagInGrid;
            set => SetProperty(ref _selectedModbusTagInGrid, value);
        }

        public ICommand AddNewModbusTagCommand { get; }
        public ICommand RemoveSelectedModbusTagCommand { get; }

        public SettingsViewModel(
            ISettingsService settingsService,
            IStatusService statusService,
            ILogger logger,
            Action closeWindowAction
        )
        {
            _settingsService = settingsService;
            _statusService = statusService;
            _logger = logger;
            _closeWindowAction =
                closeWindowAction ?? throw new ArgumentNullException(nameof(closeWindowAction));

            LoadWorkingCopyOfSettings();

            AddOpcUaConnectionCommand = new RelayCommand(_ => AddConnection(ConnectionType.OpcUa));
            AddModbusTcpConnectionCommand = new RelayCommand(_ =>
                AddConnection(ConnectionType.ModbusTcp)
            );
            RemoveConnectionCommand = new RelayCommand(
                _ => RemoveSelectedConnection(),
                _ => SelectedConnection != null
            );
            SaveCommand = new RelayCommand(_ => SaveSettingsAndClose());
            CancelCommand = new RelayCommand(_ => CancelAndClose());

            AddNewModbusTagCommand = new RelayCommand(
                param => AddNewModbusTag(param as ModbusTcpConnectionConfig),
                param => param is ModbusTcpConnectionConfig
            );

            RemoveSelectedModbusTagCommand = new RelayCommand(
                param => RemoveModbusTag(param as ModbusTagConfig),
                param => param is ModbusTagConfig && SelectedConnection is ModbusTcpConnectionConfig
            );

            _logger.Information("SettingsViewModel geïnitialiseerd.");
        }

        private void LoadWorkingCopyOfSettings()
        {
            _logger.Debug("Werkkopie van instellingen laden...");

            var originalConnections = _settingsService.CurrentSettings.Connections;
            var tempWorkingConnections = new ObservableCollection<ConnectionConfigBase>();

            var serializerSettings = new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Objects,
            };

            foreach (var conn in originalConnections)
            {
                try
                {
                    string jsonConn = JsonConvert.SerializeObject(conn, serializerSettings);
                    var clonedConn = JsonConvert.DeserializeObject<ConnectionConfigBase>(
                        jsonConn,
                        serializerSettings
                    );
                    if (clonedConn != null)
                    {
                        tempWorkingConnections.Add(clonedConn);
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het klonen van een ConnectionConfig object: {ConnectionName}",
                        conn.ConnectionName
                    );
                }
            }
            WorkingConnections = tempWorkingConnections;
            _logger.Information(
                "Werkkopie van {Count} verbindingen geladen.",
                WorkingConnections.Count
            );
        }

        private void AddConnection(ConnectionType type)
        {
            ConnectionConfigBase newConnection = null;
            switch (type)
            {
                case ConnectionType.ModbusTcp:
                    newConnection = new ModbusTcpConnectionConfig();
                    _logger.Information("Nieuwe Modbus TCP verbinding toegevoegd aan werkkopie.");
                    break;
                case ConnectionType.OpcUa:
                    newConnection = new OpcUaConnectionConfig();
                    _logger.Information("Nieuwe OPC UA verbinding toegevoegd aan werkkopie.");
                    break;
                default:
                    _logger.Warning("Onbekend verbindingstype gevraagd: {Type}", type);
                    return;
            }

            if (newConnection != null)
            {
                WorkingConnections.Add(newConnection);
                SelectedConnection = newConnection;
            }
        }

        private void RemoveSelectedConnection()
        {
            if (SelectedConnection != null)
            {
                _logger.Information(
                    "Verbinding '{ConnectionName}' verwijderd uit werkkopie.",
                    SelectedConnection.ConnectionName
                );
                WorkingConnections.Remove(SelectedConnection);
                SelectedConnection = null;
            }
        }

        private void SaveSettingsAndClose()
        {
            _logger.Information("Instellingen opslaan vanuit SettingsViewModel...");
            _statusService.SetStatus(
                Enums.ApplicationStatus.Saving,
                "Bezig met opslaan van gewijzigde instellingen..."
            );

            _settingsService.CurrentSettings.Connections.Clear();
            foreach (var conn in WorkingConnections)
            {
                _settingsService.CurrentSettings.Connections.Add(conn);
            }

            _settingsService.SaveSettings();
            _logger.Information("Instellingen succesvol opgeslagen.");
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            _closeWindowAction();
        }

        private void CancelAndClose()
        {
            _logger.Information("Wijzigingen in instellingen geannuleerd.");
            _statusService.SetStatus(
                Enums.ApplicationStatus.Idle,
                "Wijzigingen in instellingen geannuleerd."
            );
            _closeWindowAction();
        }

        private void AddNewModbusTag(ModbusTcpConnectionConfig connectionConfig)
        {
            if (connectionConfig == null)
                return;

            var newTag = new ModbusTagConfig
            {
                TagName = "Nieuwe Modbus Tag",
                Address = 0,
                RegisterType = ModbusRegisterType.HoldingRegister,
                DataType = ModbusDataType.UInt16,
                IsActive = true,
                IsAlarmingEnabled = false,
                IsOutlierDetectionEnabled = false,
                BaselineSampleSize = 20,
                OutlierStandardDeviationFactor = 3.0,
                AlarmMessageFormat = "{TagName} is {AlarmState}: {Value}",
            };
            connectionConfig.TagsToMonitor.Add(newTag);
            SelectedModbusTagInGrid = newTag;
        }

        private void RemoveModbusTag(ModbusTagConfig tagToRemove)
        {
            if (
                tagToRemove == null
                || !(SelectedConnection is ModbusTcpConnectionConfig modbusConnection)
            )
                return;

            modbusConnection.TagsToMonitor.Remove(tagToRemove);
            SelectedModbusTagInGrid = null;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\TabViewModelBase.cs"
using Data_Logger.Core;
using Data_Logger.Models;

namespace Data_Logger.ViewModels
{
    public abstract class TabViewModelBase : ObservableObject
    {
        private string _displayName;

        private ConnectionConfigBase _connectionConfiguration;

        public ConnectionConfigBase ConnectionConfiguration
        {
            get => _connectionConfiguration;
            protected set => SetProperty(ref _connectionConfiguration, value);
        }

        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        protected TabViewModelBase(ConnectionConfigBase connectionConfig)
        {
            ConnectionConfiguration = connectionConfig;
            DisplayName = connectionConfig.ConnectionName;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml"
<Window x:Class="Data_Logger.Views.BrowseOpcUaNodesView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        mc:Ignorable="d"
        Title="BrowseOpcUaNodesView" Height="450" Width="800">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>   <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,5">
            <Button Content="Omhoog" Command="{Binding GoUpCommand}" MinWidth="70" Margin="0,0,10,0"/>
            <TextBlock Text="{Binding CurrentBrowsePathDisplay}" VerticalAlignment="Center" FontWeight="SemiBold" TextTrimming="CharacterEllipsis"/>
        </StackPanel>
        
        <ListView Grid.Row="1" x:Name="NodesListView"
                  ItemsSource="{Binding CurrentNodes}" 
                  SelectedItem="{Binding SelectedNodeInView}" 
                  SelectionMode="Single" Margin="0,0,0,5"
                  HorizontalContentAlignment="Stretch">
            <ListView.InputBindings>
                <MouseBinding MouseAction="LeftDoubleClick" Command="{Binding BrowseDeeperCommand}" CommandParameter="{Binding SelectedItem, ElementName=NodesListView}"/>
            </ListView.InputBindings>
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding NodeClass}" Value="Variable">
                            <Setter Property="FontWeight" Value="Bold"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="Naam" Width="*">
                        <GridViewColumn.CellTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="{Binding DisplayName}" />
                                </StackPanel>
                            </DataTemplate>
                        </GridViewColumn.CellTemplate>
                    </GridViewColumn>
                    <GridViewColumn Header="NodeClass" DisplayMemberBinding="{Binding NodeClass}" Width="100"/>
                    <GridViewColumn Header="NodeId" DisplayMemberBinding="{Binding NodeId}" Width="200"/>
                </GridView>
            </ListView.View>
        </ListView>
        
        <TextBlock Grid.Row="1" Text="Laden..." FontSize="16" HorizontalAlignment="Center" VerticalAlignment="Center"
                   Visibility="{Binding IsLoading, Converter={StaticResource BooleanToVisibilityConverter}}"/>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
            <Button Content="Selecteer" Command="{Binding SelectNodeCommand}" IsDefault="True" MinWidth="80" Margin="0,0,10,0"/>
            <Button Content="Annuleren" Command="{Binding CancelCommand}" IsCancel="True" MinWidth="80"/>
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class BrowseOpcUaNodesView : Window
    {
        public BrowseOpcUaNodesView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance vm:LogViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="600"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.LogView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <StackPanel
            Grid.Row="0"
            Margin="5"
            Orientation="Horizontal">
            <TextBlock
                Margin="0,0,5,0"
                Text="Filter Tekst:"
                VerticalAlignment="Center" />
            <TextBox
                Margin="0,0,10,0"
                Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}"
                VerticalAlignment="Center"
                Width="150" />
            <TextBlock
                Margin="0,0,5,0"
                Text="Niveau:"
                VerticalAlignment="Center" />
            <ComboBox
                ItemsSource="{Binding LogLevels}"
                Margin="0,0,10,0"
                SelectedValue="{Binding SelectedLogLevelFilter}"
                VerticalAlignment="Center"
                Width="100" />
            <Button
                Command="{Binding ClearLogsCommand}"
                Content="Wis Logs"
                VerticalAlignment="Center" />
        </StackPanel>

        <ListView
            AlternationCount="2"
            Grid.Row="1"
            ItemsSource="{Binding LogEntries}"
            Margin="5,0,5,5">
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding Level}" Value="Error">
                            <Setter Property="Background" Value="LightPink" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Fatal">
                            <Setter Property="Background" Value="Red" />
                            <Setter Property="Foreground" Value="White" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Warning">
                            <Setter Property="Background" Value="LightYellow" />
                        </DataTrigger>
                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                            <Setter Property="Background" Value="#EFEFEF" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn
                        DisplayMemberBinding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}"
                        Header="Tijd"
                        Width="150" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding LevelDisplay}"
                        Header="Niveau"
                        Width="80" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding RenderedMessage}"
                        Header="Bericht"
                        Width="Auto" />
                </GridView>
            </ListView.View>
        </ListView>
    </Grid>
</UserControl>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml.cs"
using System.Windows.Controls;

namespace Data_Logger.Views
{
    public partial class LogView : UserControl
    {
        public LogView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml"
<Window
    Height="900"
    Title="{Binding ApplicationTitle}"
    Width="1600"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:views="clr-namespace:Data_Logger.Views"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Window.Resources>
        <DataTemplate DataType="{x:Type vm:ModbusTabViewModel}">
            <views:ModbusTabView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:OpcUaTabViewModel}"> <views:OpcUaTabView />
        </DataTemplate>
    </Window.Resources>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="200" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <Menu Grid.Row="0">
            <MenuItem Header="_Bestand">
                <MenuItem Command="{Binding OpenSettingsCommand}" Header="_Instellingen..." />
                <Separator />
                <MenuItem Click="Afsluiten_Click" Header="_Afsluiten" />
            </MenuItem>
        </Menu>

        <TabControl
            Grid.Row="1"
            ItemsSource="{Binding ActiveTabs}"
            Margin="5"
            SelectedItem="{Binding SelectedTab}">
            <TabControl.ItemTemplate>
                <DataTemplate DataType="{x:Type vm:TabViewModelBase}">
                    <TextBlock Text="{Binding DisplayName}" />
                </DataTemplate>
            </TabControl.ItemTemplate>
        </TabControl>

        <GridSplitter
            Background="LightGray"
            Grid.Row="2"
            Height="5"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Center" />

        <GroupBox
            Grid.Row="3"
            Header="Applicatie Logs"
            Margin="5">
            <views:LogView DataContext="{Binding LogVm}" />
        </GroupBox>

        <StatusBar Grid.Row="4" Padding="5,2">
            <StatusBar.ItemsPanel>
                <ItemsPanelTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                    </Grid>
                </ItemsPanelTemplate>
            </StatusBar.ItemsPanel>
            <StatusBarItem Grid.Column="0">
                <Ellipse
                    Height="15"
                    Margin="0,0,5,0"
                    Width="15">
                    <Ellipse.Style>
                        <Style TargetType="Ellipse">
                            <Setter Property="Fill" Value="Gray" />
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Idle}">
                                    <Setter Property="Fill" Value="LightGray" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Connecting}">
                                    <Setter Property="Fill" Value="Orange" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Logging}">
                                    <Setter Property="Fill" Value="Green" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Warning}">
                                    <Setter Property="Fill" Value="Yellow" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Error}">
                                    <Setter Property="Fill" Value="Red" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Loading}">
                                    <Setter Property="Fill" Value="SkyBlue" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Saving}">
                                    <Setter Property="Fill" Value="Plum" />
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </Ellipse.Style>
                </Ellipse>
            </StatusBarItem>
            <StatusBarItem Grid.Column="1">
                <TextBlock Text="{Binding CurrentStatusMessage}" VerticalAlignment="Center" />
            </StatusBarItem>
        </StatusBar>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class MainWindow
    {
        public MainWindow()
        {
            InitializeComponent();
        }
        
        private void Afsluiten_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml"
<UserControl x:Class="Data_Logger.Views.ModbusTabView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:Data_Logger.ViewModels"
             xmlns:converters="clr-namespace:Data_Logger.Converters"
             xmlns:enums="clr-namespace:Data_Logger.Enums"
             mc:Ignorable="d"
             d:DataContext="{d:DesignInstance Type=vm:ModbusTabViewModel, IsDesignTimeCreatable=False}"
             d:DesignHeight="600" d:DesignWidth="800">

    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
    </UserControl.Resources>

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="120"/> 
            <RowDefinition Height="*"/> 
            </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" HorizontalAlignment="Left" Margin="0,0,0,10">
            <TextBlock Text="{Binding ModbusConfig.ConnectionName}" FontSize="18" FontWeight="Bold"/>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="IP: " FontWeight="SemiBold"/><TextBlock Text="{Binding ModbusConfig.IpAddress}"/>
                <TextBlock Text=":" Margin="2,0,2,0"/><TextBlock Text="{Binding ModbusConfig.Port}" Margin="0,0,10,0"/>
                <TextBlock Text="Unit ID: " FontWeight="SemiBold"/><TextBlock Text="{Binding ModbusConfig.UnitId}"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                <TextBlock Text="Status: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" />
                <TextBlock Text=" (Scan Interval: " Margin="5,0,0,0" FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.ScanIntervalSeconds}" /><TextBlock Text="s)" />
            </StackPanel>
        </StackPanel>

        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="100" Margin="0,0,5,0"/>
            <Button Content="Verbinding Verbreken" Command="{Binding DisconnectCommand}" MinWidth="100"/>
        </StackPanel>

        <TextBlock Grid.Row="2" Text="Geconfigureerde Tags (uit Instellingen):" FontWeight="SemiBold" Margin="0,10,0,2"/>
        <DataGrid Grid.Row="3" ItemsSource="{Binding ModbusConfig.TagsToMonitor}" AutoGenerateColumns="False" CanUserAddRows="False" IsReadOnly="True" MaxHeight="120" VerticalScrollBarVisibility="Auto">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*"/>
                <DataGridTextColumn Header="Adres" Binding="{Binding Address}" Width="Auto"/>
                <DataGridTextColumn Header="Register Type" Binding="{Binding RegisterType}" Width="*"/>
                <DataGridTextColumn Header="Data Type" Binding="{Binding DataType}" Width="*"/>
                <DataGridCheckBoxColumn Header="Actief" Binding="{Binding IsActive, Mode=OneWay}" Width="Auto"/>
            </DataGrid.Columns>
        </DataGrid>

        <DataGrid Grid.Row="4" ItemsSource="{Binding DataValues}" Margin="0,5,0,0" AutoGenerateColumns="False" CanUserAddRows="False" IsReadOnly="True" AlternationCount="2" VerticalScrollBarVisibility="Auto">
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.High}"><Setter Property="Background" Value="LightGoldenrodYellow"/></DataTrigger>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Low}"><Setter Property="Background" Value="LightGoldenrodYellow"/></DataTrigger>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.HighHigh}"><Setter Property="Background" Value="LightPink"/><Setter Property="FontWeight" Value="Bold"/></DataTrigger>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.LowLow}"><Setter Property="Background" Value="LightPink"/><Setter Property="FontWeight" Value="Bold"/></DataTrigger>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Outlier}"><Setter Property="Background" Value="LightSkyBlue"/> <Setter Property="FontStyle" Value="Italic"/></DataTrigger>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Error}"><Setter Property="Background" Value="LightGray"/><Setter Property="Foreground" Value="DarkRed"/> <Setter Property="FontStyle" Value="Italic"/></DataTrigger>
                        <Trigger Property="ItemsControl.AlternationIndex" Value="1"><Setter Property="Background" Value="#EFEFEF" /></Trigger>
                        <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Normal}"></DataTrigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>

            <DataGrid.Columns>
                <DataGridTextColumn Header="Tijdstempel" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" Width="Auto" SortDirection="Descending"/>
                <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*"/>
                <DataGridTextColumn Header="Waarde" Binding="{Binding FormattedValue}" Width="Auto"/>
                <DataGridTextColumn Header="Kwaliteit" Width="Auto"> 
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True"><Setter Property="Foreground" Value="DarkGreen"/></DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Foreground" Value="DarkRed"/></DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.CellStyle>
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Center"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True"><Setter Property="Text" Value="Goed"/></DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Text" Value="Slecht"/></DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                <DataGridTextColumn Header="Alarm Status" Binding="{Binding AlarmState}" Width="Auto">
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Center"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Normal}"><Setter Property="Text" Value="Normaal"/></DataTrigger>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.High}"><Setter Property="Text" Value="Hoog"/></DataTrigger>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.HighHigh}"><Setter Property="Text" Value="Zeer Hoog"/></DataTrigger>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Low}"><Setter Property="Text" Value="Laag"/></DataTrigger>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.LowLow}"><Setter Property="Text" Value="Zeer Laag"/></DataTrigger>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Outlier}"><Setter Property="Text" Value="Outlier"/></DataTrigger>
                                <DataTrigger Binding="{Binding AlarmState}" Value="{x:Static enums:TagAlarmState.Error}"><Setter Property="Text" Value="Fout"/></DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
            </DataGrid.Columns>
        </DataGrid>
        
        </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml.cs"
using System.Windows.Controls;
using Data_Logger.ViewModels;

namespace Data_Logger.Views
{
    public partial class ModbusTabView : UserControl
    {
        private ModbusTabViewModel _viewModel;
        

        public ModbusTabView()
        {
            InitializeComponent();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml"
<UserControl x:Class="Data_Logger.Views.OpcUaTabView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:Data_Logger.ViewModels"
             xmlns:enums="clr-namespace:Data_Logger.Enums"
             xmlns:converters="clr-namespace:Data_Logger.Converters"
             xmlns:scottplot="clr-namespace:ScottPlot;assembly=ScottPlot.WPF"
             xmlns:wpf="http://schemas.scottplot.net/2008/xaml/presentation"
             xmlns:views="clr-namespace:Data_Logger.Views"
             xmlns:plottingVm="clr-namespace:Data_Logger.ViewModels"
             xmlns:plotting="clr-namespace:Data_Logger.ViewModels"
             xmlns:plotting1="clr-namespace:Data_Logger.ViewModels.Plotting"
             x:Name="OpcUaTabViewControl" mc:Ignorable="d"
             d:DataContext="{d:DesignInstance Type=vm:OpcUaTabViewModel, IsDesignTimeCreatable=False}"
             d:DesignHeight="700" d:DesignWidth="1000">

    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
        <converters:BooleanToForwardBackwardConverter x:Key="BooleanToForwardBackwardConverter"/>

        <Style TargetType="{x:Type TreeViewItem}">
            <Setter Property="Header" Value="{Binding DisplayName}" />
            <Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" />
            <Setter Property="ItemsSource" Value="{Binding Children}" />
            <Setter Property="ToolTip">
                <Setter.Value>
                    <StackPanel MaxWidth="300">
                        <TextBlock Text="{Binding NodeId, StringFormat='NodeId: {0}'}" TextWrapping="Wrap"/>
                        <TextBlock Text="{Binding NodeClass, StringFormat='Klasse: {0}'}" />
                    </StackPanel>
                </Setter.Value>
            </Setter>
            <Setter Property="ContextMenu">
                <Setter.Value>
                    <ContextMenu DataContext="{Binding Path=DataContext, Source={x:Reference Name=OpcUaTabViewControl}}">
                        <MenuItem Header="[DEBUG] ContextMenu DC Type">
                            <TextBlock Text="{Binding Path=., FallbackValue='CTX MENU DC IS NULL', TargetNullValue='CTX MENU DC IS TARGETNULL'}" Foreground="Red" FontWeight="Bold"/>
                        </MenuItem>
                        <MenuItem Header="Voeg toe aan Monitoring"
                                  Command="{Binding AddSelectedNodeToMonitoringCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                        
                        <MenuItem Header="Verwijder van Monitoring"
                                  Command="{Binding RemoveSelectedNodeFromMonitoringCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                        
                        <MenuItem Header="Lees Huidige Waarde"
                                  Command="{Binding ReadSelectedNodeValueCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                        
                        <Separator/>
                        </ContextMenu>
                </Setter.Value>
            </Setter>
        </Style>

        <HierarchicalDataTemplate DataType="{x:Type vm:OpcUaNodeViewModel}" ItemsSource="{Binding Children}">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding DisplayName}" />
                <TextBlock Text="{Binding NodeClass, StringFormat=' ({0})'}" Foreground="Gray" FontStyle="Italic" Margin="5,0,0,0" FontSize="10"/>
            </StackPanel>
        </HierarchicalDataTemplate>

        <ObjectDataProvider x:Key="OpcUaDataTypeEnumValuesForGrid" MethodName="GetValues" ObjectType="{x:Type sys:Enum}"
                            xmlns:sys="clr-namespace:System;assembly=mscorlib">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:OpcUaDataType"/>
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <Style x:Key="DataGridButtonStyleInCell" TargetType="Button">
            <Setter Property="Padding" Value="3,1"/>
            <Setter Property="Margin" Value="1"/>
            <Setter Property="MinWidth" Value="50"/>
            <Setter Property="FontSize" Value="10"/>
        </Style>
        
        <Style TargetType="{x:Type TabItem}" x:Key="PlotTabItemStyle">
            <Setter Property="Padding" Value="5,2"/>
            <Setter Property="HeaderTemplate">
                <Setter.Value>
                    <DataTemplate DataType="{x:Type plotting1:PlotTabViewModel}">
                        <StackPanel Orientation="Horizontal">
                            <TextBlock Text="{Binding Header}" VerticalAlignment="Center" Margin="0,0,8,0"/>
                            <Button Command="{Binding CloseTabCommand}" 
                                    Content="&#x2715;" Padding="4,0" 
                                    FontSize="10" 
                                    FontWeight="Bold"
                                    Background="Transparent" 
                                    BorderThickness="0" 
                                    Foreground="DimGray"
                                    Cursor="Hand"
                                    ToolTip="Sluit dit grafiektabblad">
                                <Button.Style>
                                    <Style TargetType="Button">
                                        <Setter Property="Template">
                                            <Setter.Value>
                                                <ControlTemplate TargetType="Button">
                                                    <Border Background="{TemplateBinding Background}">
                                                        <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                                    </Border>
                                                </ControlTemplate>
                                            </Setter.Value>
                                        </Setter>
                                        <Style.Triggers>
                                            <Trigger Property="IsMouseOver" Value="True">
                                                <Setter Property="Foreground" Value="Red"/>
                                            </Trigger>
                                        </Style.Triggers>
                                    </Style>
                                </Button.Style>
                            </Button>
                        </StackPanel>
                    </DataTemplate>
                </Setter.Value>
            </Setter>
        </Style>

    </UserControl.Resources>

    <Grid Margin="5">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Margin="0,0,0,5">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <StackPanel Grid.Column="0" HorizontalAlignment="Left" Margin="0,0,20,0">
                    <TextBlock Text="{Binding OpcUaConfig.ConnectionName}" FontSize="16" FontWeight="Bold"/>
                    <TextBlock Text="{Binding OpcUaConfig.EndpointUrl, StringFormat='Endpoint: {0}'}" FontSize="10" ToolTip="{Binding OpcUaConfig.EndpointUrl}" TextTrimming="CharacterEllipsis"/>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="Status: " FontSize="10" FontWeight="SemiBold"/>
                        <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" FontSize="10" />
                    </StackPanel>
                </StackPanel>
                <WrapPanel Grid.Column="1" Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top">
                    <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="70" Margin="0,0,5,2"/>
                    <Button Content="Verbreken" Command="{Binding DisconnectCommand}" MinWidth="70" Margin="0,0,5,2"/>
                    <Button Content="Lees Config Tags" Command="{Binding ReadAllConfiguredTagsCommand}" MinWidth="100" Margin="0,0,5,2" ToolTip="Leest waarden van tags in de huidige monitoring configuratie."/>
                    <Button Content="Refresh Address Space" Command="{Binding LoadAddressSpaceCommand}" MinWidth="100" Margin="0,0,5,2"/>
                    <TextBlock Text="Laden..." VerticalAlignment="Center" Margin="5,0,0,0" Visibility="{Binding IsBrowse, Converter={StaticResource BooleanToVisibilityConverter}}"/>
                </WrapPanel>
            </Grid>
            <TextBlock Text="{Binding LastReadNodeValue}" FontSize="10" TextWrapping="Wrap" Margin="0,5,0,0" MinHeight="15" FontStyle="Italic"/>
        </StackPanel>

        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="0.2*" MinWidth="280"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="0.65*" MinWidth="350"/>
            </Grid.ColumnDefinitions>

            <TabControl Grid.Column="0" Margin="0,0,2,0">
                <TabItem Header="Address Space">
                    <Border BorderBrush="LightGray" BorderThickness="1">
                        <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto">
                            <TreeView ItemsSource="{Binding RootNodes}" Padding="2"
                                      x:Name="OpcUaNodeTreeView" 
                                      SelectedItemChanged="TreeView_SelectedItemChanged"/>
                        </ScrollViewer>
                    </Border>
                </TabItem>
                <TabItem Header="Attributes &amp; References">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/> 
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>

                        <TextBlock Grid.Row="0" Text="Node Attributen:" FontWeight="Bold" Margin="5,5,5,2"/>
                        <ListView Grid.Row="1" ItemsSource="{Binding SelectedNodeAttributes}" Margin="5,0,5,5" AlternationCount="2">
                            <ListView.ItemContainerStyle>
                                <Style TargetType="ListViewItem">
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding IsGood}" Value="False">
                                            <Setter Property="Foreground" Value="Red"/>
                                        </DataTrigger>
                                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                                            <Setter Property="Background" Value="#F5F5F5" />
                                        </Trigger>
                                    </Style.Triggers>
                                </Style>
                            </ListView.ItemContainerStyle>
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Attribuut" DisplayMemberBinding="{Binding AttributeName}" Width="150"/>
                                    <GridViewColumn Header="Waarde" DisplayMemberBinding="{Binding Value}" Width="Auto"/>
                                    <GridViewColumn Header="Status" DisplayMemberBinding="{Binding StatusCodeDisplay}" Width="100"/>
                                </GridView>
                            </ListView.View>
                        </ListView>

                        <GridSplitter Grid.Row="2" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray" ShowsPreview="True"/>

                        <TextBlock Grid.Row="3" Text="Node Referenties:" FontWeight="Bold" Margin="5,5,5,2"/>
                        <ListView Grid.Row="4" ItemsSource="{Binding SelectedNodeReferences}" Margin="5,0,5,5" AlternationCount="2">
                             <ListView.ItemContainerStyle>
                                <Style TargetType="ListViewItem">
                                    <Style.Triggers>
                                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                                            <Setter Property="Background" Value="#F5F5F5" />
                                        </Trigger>
                                    </Style.Triggers>
                                </Style>
                            </ListView.ItemContainerStyle>
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Type" DisplayMemberBinding="{Binding ReferenceTypeDisplay}" Width="150"/>
                                    <GridViewColumn Header="Richting" Width="70">
                                        <GridViewColumn.CellTemplate>
                                            <DataTemplate>
                                                <TextBlock Text="{Binding IsForward, Converter={StaticResource BooleanToForwardBackwardConverter}}"/>
                                            </DataTemplate>
                                        </GridViewColumn.CellTemplate>
                                    </GridViewColumn>
                                    <GridViewColumn Header="Target Naam" DisplayMemberBinding="{Binding TargetDisplayName}" Width="Auto"/>
                                    <GridViewColumn Header="Target Klasse" DisplayMemberBinding="{Binding TargetNodeClass}" Width="100"/>
                                </GridView>
                            </ListView.View>
                        </ListView>
                        
                        <TextBlock Grid.Row="1" Grid.RowSpan="4" Text="Details laden..." 
                                   HorizontalAlignment="Center" VerticalAlignment="Center"
                                   Visibility="{Binding IsLoadingNodeDetails, Converter={StaticResource BooleanToVisibilityConverter}}"
                                   IsEnabled="{Binding IsLoadingNodeDetails}"/>
                    </Grid>
                </TabItem>
            </TabControl>

            <GridSplitter Grid.Column="1" Width="5" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Background="LightGray"/>

            <Grid Grid.Column="2" Margin="2,0,0,0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="0.4*" MinHeight="150"/> <RowDefinition Height="Auto"/>
                    <RowDefinition Height="0.6*" MinHeight="10"/> </Grid.RowDefinitions>

                <GroupBox Grid.Row="0" Header="Gemonitorde OPC UA Tags (Configuratie Live Waarden)" Padding="2"
                          Visibility="{Binding IsConnected, Converter={StaticResource BooleanToVisibilityConverter}}"> 
                    <DataGrid ItemsSource="{Binding OpcUaConfig.TagsToMonitor}"
                              AutoGenerateColumns="False"
                              CanUserAddRows="False" 
                              CanUserDeleteRows="False" 
                              AlternationCount="2" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto"
                              SelectionUnit="FullRow" SelectionMode="Single">
                        <DataGrid.RowStyle>
                            <Style TargetType="DataGridRow">
                                <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                                <Style.Triggers>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.High}"><Setter Property="Background" Value="LightGoldenrodYellow"/></DataTrigger>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.Low}"><Setter Property="Background" Value="LightGoldenrodYellow"/></DataTrigger>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.HighHigh}"><Setter Property="Background" Value="LightPink"/><Setter Property="FontWeight" Value="Bold"/></DataTrigger>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.LowLow}"><Setter Property="Background" Value="LightPink"/><Setter Property="FontWeight" Value="Bold"/></DataTrigger>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.Error}"><Setter Property="Background" Value="LightGray"/><Setter Property="FontStyle" Value="Italic"/></DataTrigger>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.Outlier}"><Setter Property="Background" Value="LightSkyBlue"/><Setter Property="FontStyle" Value="Italic"/></DataTrigger>
                                    <Trigger Property="ItemsControl.AlternationIndex" Value="1"><Setter Property="Background" Value="#EFEFEF" /></Trigger>
                                    <DataTrigger Binding="{Binding CurrentAlarmState}" Value="{x:Static enums:TagAlarmState.Normal}"><Setter Property="Background" Value="{Binding RelativeSource={RelativeSource Self}, Path=Background}"/></DataTrigger>
                                </Style.Triggers>
                            </Style>
                        </DataGrid.RowStyle>
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*" IsReadOnly="True"/>
                            <DataGridTextColumn Header="NodeID" Binding="{Binding NodeId}" Width="1.5*" IsReadOnly="True"/>
                            <DataGridTextColumn Header="Data Type (Config)" Binding="{Binding DataType, Mode=OneWay}" Width="Auto" IsReadOnly="True"/>
                            
                            <DataGridTextColumn Header="Sampling (ms)" Width="Auto">
                                <DataGridTextColumn.Binding>
                                    <Binding Path="SamplingInterval" UpdateSourceTrigger="LostFocus">
                                        <Binding.ValidationRules><ExceptionValidationRule/></Binding.ValidationRules>
                                    </Binding>
                                </DataGridTextColumn.Binding>
                                <DataGridTextColumn.EditingElementStyle>
                                    <Style TargetType="TextBox">
                                        <EventSetter Event="LostFocus" Handler="ConfigTagTextBox_LostFocus_SaveChanges"/>
                                    </Style>
                                </DataGridTextColumn.EditingElementStyle>
                            </DataGridTextColumn>

                            <DataGridCheckBoxColumn Header="Actief" Width="50">
                                <DataGridCheckBoxColumn.Binding>
                                    <Binding Path="IsActive" UpdateSourceTrigger="PropertyChanged"/>
                                </DataGridCheckBoxColumn.Binding>
                                <DataGridCheckBoxColumn.CellStyle>
                                    <Style TargetType="DataGridCell">
                                        <EventSetter Event="CheckBox.Checked" Handler="ConfigTagCheckBox_Changed_SaveChanges"/>
                                        <EventSetter Event="CheckBox.Unchecked" Handler="ConfigTagCheckBox_Changed_SaveChanges"/>
                                        <Setter Property="HorizontalAlignment" Value="Center"/>
                                    </Style>
                                </DataGridCheckBoxColumn.CellStyle>
                            </DataGridCheckBoxColumn>

                            <DataGridTextColumn Header="Waarde" Binding="{Binding FormattedLiveValue}" Width="*" IsReadOnly="True"/>
                            <DataGridTextColumn Header="Tijdstempel" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff', Mode=OneWay}" Width="Auto" IsReadOnly="True"/>
                            <DataGridTextColumn Header="Kwaliteit" Width="Auto" IsReadOnly="True">
                                <DataGridTextColumn.ElementStyle>
                                    <Style TargetType="TextBlock">
                                        <Setter Property="HorizontalAlignment" Value="Center"/>
                                        <Style.Triggers>
                                            <DataTrigger Binding="{Binding IsGoodQuality}" Value="True"><Setter Property="Text" Value="Goed"/><Setter Property="Foreground" Value="Green"/></DataTrigger>
                                            <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Text" Value="Slecht"/><Setter Property="Foreground" Value="Red"/></DataTrigger>
                                        </Style.Triggers>
                                    </Style>
                                </DataGridTextColumn.ElementStyle>
                                <DataGridTextColumn.CellStyle>
                                    <Style TargetType="DataGridCell">
                                        <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                                     </Style>
                                </DataGridTextColumn.CellStyle>
                            </DataGridTextColumn>
                            
                            <DataGridTemplateColumn Header="Grafiek" Width="Auto">
                                <DataGridTemplateColumn.CellTemplate>
                                    <DataTemplate>
                                        <Button Content="Toon Grafiek" 
                                                Command="{Binding DataContext.OpenOrSelectPlotTabCommand, 
                                      RelativeSource={RelativeSource AncestorType={x:Type UserControl}}}"
                                                CommandParameter="{Binding}"
                                                Style="{StaticResource DataGridButtonStyleInCell}"
                                                Padding="5,2"
                                                Margin="2"/>
                                    </DataTemplate>
                                </DataGridTemplateColumn.CellTemplate>
                            </DataGridTemplateColumn>

                            <DataGridTemplateColumn Header="Actie" Width="Auto">
                                <DataGridTemplateColumn.CellTemplate>
                                    <DataTemplate>
                                        <Button Content="Stop" ToolTip="Stop Monitoring" Style="{StaticResource DataGridButtonStyleInCell}"
                                                Command="{Binding DataContext.UnmonitorTagCommand, RelativeSource={RelativeSource AncestorType={x:Type UserControl}}}"
                                                CommandParameter="{Binding}"/>
                                    </DataTemplate>
                                </DataGridTemplateColumn.CellTemplate>
                            </DataGridTemplateColumn>
                        </DataGrid.Columns>
                    </DataGrid>
                </GroupBox>

                <GridSplitter Grid.Row="1" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray"/>
                
                <TabControl Grid.Row="2" ItemsSource="{Binding ActivePlotTabs}" SelectedItem="{Binding SelectedPlotTab}" Margin="0,5,0,0" Padding="2">
                    <TabControl.ItemContainerStyle>
                        <StaticResource ResourceKey="PlotTabItemStyle"/>
                    </TabControl.ItemContainerStyle>
                    <TabControl.ContentTemplate>
                        <DataTemplate DataType="{x:Type plotting1:PlotTabViewModel}">
                            <views:SinglePlotView Margin="2"/>
                        </DataTemplate>
                    </TabControl.ContentTemplate>
                </TabControl>

                </Grid>
        </Grid>
    </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml.cs"
using System.Windows;
using System.Windows.Controls;
using Data_Logger.Models;
using Data_Logger.ViewModels;

namespace Data_Logger.Views
{
    public partial class OpcUaTabView : UserControl
    {
        private OpcUaTabViewModel _viewModel;

        public OpcUaTabView()
        {
            InitializeComponent();
        }

        private void TreeView_SelectedItemChanged(
            object sender,
            RoutedPropertyChangedEventArgs<object> e
        )
        {
            if (
                this.DataContext is OpcUaTabViewModel viewModel
                && e.NewValue is OpcUaNodeViewModel selectedNode
            )
            {
                viewModel.SelectedOpcUaNode = selectedNode;
            }
            else if (this.DataContext is OpcUaTabViewModel viewModelWithNull && e.NewValue == null)
            {
                viewModelWithNull.SelectedOpcUaNode = null;
            }
        }

        private void ConfigTagTextBox_LostFocus_SaveChanges(object sender, RoutedEventArgs e)
        {
            if (
                this.DataContext is OpcUaTabViewModel viewModel
                && sender is FrameworkElement element
            )
            {
                if (element.DataContext is OpcUaTagConfig tagConfig)
                {
                    viewModel.SaveChangesForTagConfig(tagConfig);
                }
            }
        }

        private void ConfigTagCheckBox_Changed_SaveChanges(object sender, RoutedEventArgs e)
        {
            if (
                this.DataContext is OpcUaTabViewModel viewModel
                && sender is FrameworkElement element
            )
            {
                if (element.DataContext is OpcUaTagConfig tagConfig)
                {
                    viewModel.SaveChangesForTagConfig(tagConfig);
                }
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml"
<Window
    Height="500"
    MinHeight="400"
    MinWidth="600"
    Title="Instellingen"
    Width="800"
    WindowStartupLocation="CenterOwner"
    d:DataContext="{d:DesignInstance Type=vm:SettingsViewModel,
                                     IsDesignTimeCreatable=False}"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.SettingsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:System="clr-namespace:System;assembly=mscorlib"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:models="clr-namespace:Data_Logger.Models"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:Data_Logger.Views"
    xmlns:opcua="clr-namespace:Opc.Ua;assembly=Opc.Ua.Core"
    xmlns:converters="clr-namespace:Data_Logger.Converters">
    <Window.Resources>
        <converters:InverseBooleanConverter x:Key="InverseBooleanConverter"/>
        
        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusRegisterTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusRegisterType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusDataTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusDataType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>
        
        <ObjectDataProvider x:Key="OpcUaDataTypeEnumValues" MethodName="GetValues" ObjectType="{x:Type System:Enum}">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:OpcUaDataType"/>
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>
        
        <ObjectDataProvider MethodName="GetValues"
                            ObjectType="{x:Type System:Enum}"
                            x:Key="MessageSecurityModeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="opcua:MessageSecurityMode" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider ObjectType="{x:Type local:OpcUaSecurityPolicyValues}"
                            MethodName="GetInstance"
                            x:Key="SecurityPolicyUriValues"/>

        <DataTemplate DataType="{x:Type models:OpcUaConnectionConfig}">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel Margin="10">
                    <TextBlock Text="OPC UA Verbinding Details" FontWeight="Bold" Margin="0,0,0,10"/>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto" MinWidth="180"/> <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

                        <Label Grid.Row="0" Grid.Column="0" Content="Naam:" VerticalAlignment="Center"/>
                        <TextBox Grid.Row="0" Grid.Column="1" Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                        <Label Grid.Row="1" Grid.Column="0" Content="Endpoint URL:" VerticalAlignment="Center"/>
                        <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding EndpointUrl, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                        <Label Grid.Row="2" Grid.Column="0" Content="Security Mode:" VerticalAlignment="Center"/>
                        <ComboBox Grid.Row="2" Grid.Column="1" Margin="5"
                                  ItemsSource="{Binding Source={StaticResource MessageSecurityModeEnumValues}}"
                                  SelectedValue="{Binding SecurityMode, UpdateSourceTrigger=PropertyChanged}"/>

                        <Label Grid.Row="3" Grid.Column="0" Content="Security Policy URI:" VerticalAlignment="Center"/>
                        <ComboBox Grid.Row="3" Grid.Column="1" Margin="5"
                                  ItemsSource="{Binding Source={StaticResource SecurityPolicyUriValues}}"
                                  SelectedValue="{Binding SecurityPolicyUri, UpdateSourceTrigger=PropertyChanged}"/>

                        <Label Grid.Row="4" Grid.Column="0" Content="Gebruikersnaam:" VerticalAlignment="Center"/>
                        <TextBox Grid.Row="4" Grid.Column="1" Text="{Binding UserName, UpdateSourceTrigger=PropertyChanged, ValidatesOnExceptions=True, NotifyOnValidationError=True}" Margin="5"/>

                        <Label Grid.Row="5" Grid.Column="0" Content="Wachtwoord:" VerticalAlignment="Center"/>
                        <TextBox Grid.Row="5" Grid.Column="1" Text="{Binding Password, UpdateSourceTrigger=PropertyChanged, ValidatesOnExceptions=True, NotifyOnValidationError=True}" Margin="5"/>

                        <Label Grid.Row="6" Grid.Column="0" Content="Scan Interval (sec):" VerticalAlignment="Center"/>
                        <TextBox Grid.Row="6" Grid.Column="1" Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                        <CheckBox Grid.Row="7" Grid.Column="1" IsChecked="{Binding IsEnabled}" Content="Actief" Margin="5" VerticalAlignment="Center"/>
                    </Grid>

                    <GroupBox Header="Tags en Alarmen (OPC UA)" Margin="0,15,0,0" Padding="5">
                        <StackPanel>
                            <TextBlock Text="Gemonitorde OPC UA Tags (alarmen en outlier detectie hier instellen):" Margin="0,0,0,5" FontStyle="Italic" TextWrapping="Wrap"/>
                            <DataGrid ItemsSource="{Binding TagsToMonitor}" AutoGenerateColumns="False" CanUserAddRows="False" CanUserDeleteRows="False" MaxHeight="300" VerticalScrollBarVisibility="Auto">
                                <DataGrid.Columns>
                                    <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="1.2*" IsReadOnly="True"/>
                                    <DataGridTextColumn Header="NodeID" Binding="{Binding NodeId}" Width="1.5*" IsReadOnly="True"/>
                                    <DataGridTextColumn Header="Sampling (ms)" Binding="{Binding SamplingInterval, UpdateSourceTrigger=LostFocus}" Width="Auto"/>
                                    <DataGridCheckBoxColumn Header="Tag Actief?" Binding="{Binding IsActive, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                                    
                                    <DataGridCheckBoxColumn Header="Drempel Alarm?" Binding="{Binding IsAlarmingEnabled, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                                    <DataGridTextColumn Header="HH Lim." Binding="{Binding HighHighLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    <DataGridTextColumn Header="H Lim." Binding="{Binding HighLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    <DataGridTextColumn Header="L Lim." Binding="{Binding LowLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    <DataGridTextColumn Header="LL Lim." Binding="{Binding LowLowLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    
                                    <DataGridCheckBoxColumn Header="Outlier Detectie?" Binding="{Binding IsOutlierDetectionEnabled, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                                    <DataGridTextColumn Header="Baseline N" Binding="{Binding BaselineSampleSize, UpdateSourceTrigger=LostFocus, TargetNullValue='20'}" Width="0.7*"/>
                                    <DataGridTextColumn Header="StdDev Factor" Binding="{Binding OutlierStandardDeviationFactor, UpdateSourceTrigger=LostFocus, TargetNullValue='3.0'}" Width="0.8*"/>
                                    
                                    <DataGridTextColumn Header="Alarm Bericht Format" Binding="{Binding AlarmMessageFormat, UpdateSourceTrigger=LostFocus}" Width="2*"/>
                                </DataGrid.Columns>
                            </DataGrid>
                        </StackPanel>
                    </GroupBox>
                </StackPanel>
            </ScrollViewer>
        </DataTemplate>

        <DataTemplate DataType="{x:Type models:ModbusTcpConnectionConfig}">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel Margin="10">
                    <TextBlock Text="Modbus TCP Verbinding Details" FontWeight="Bold" Margin="0,0,0,10" />
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition MinWidth="150" Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" /> <RowDefinition Height="Auto" /> <RowDefinition Height="Auto" /> <RowDefinition Height="Auto" /> <RowDefinition Height="Auto" /> <RowDefinition Height="Auto" /> </Grid.RowDefinitions>

                        <Label Grid.Row="0" Grid.Column="0" Content="Naam:" VerticalAlignment="Center" />
                        <TextBox Grid.Row="0" Grid.Column="1" Margin="5" Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" />

                        <Label Grid.Row="1" Grid.Column="0" Content="IP Adres:" VerticalAlignment="Center" />
                        <TextBox Grid.Row="1" Grid.Column="1" Margin="5" Text="{Binding IpAddress, UpdateSourceTrigger=PropertyChanged}" />

                        <Label Grid.Row="2" Grid.Column="0" Content="Poort:" VerticalAlignment="Center" />
                        <TextBox Grid.Row="2" Grid.Column="1" Margin="5" Text="{Binding Port, UpdateSourceTrigger=PropertyChanged}" />

                        <Label Grid.Row="3" Grid.Column="0" Content="Unit ID:" VerticalAlignment="Center" />
                        <TextBox Grid.Row="3" Grid.Column="1" Margin="5" Text="{Binding UnitId, UpdateSourceTrigger=PropertyChanged}" />

                        <Label Grid.Row="4" Grid.Column="0" Content="Scan Interval (sec):" VerticalAlignment="Center" />
                        <TextBox Grid.Row="4" Grid.Column="1" Margin="5" Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" />

                        <CheckBox Grid.Row="5" Grid.Column="1" Content="Actief" IsChecked="{Binding IsEnabled}" Margin="5" VerticalAlignment="Center" />
                    </Grid>

                    <GroupBox Header="Tags Alarmen (Modbus)" Margin="0,15,0,0" Padding="5">
                        <StackPanel>
                            <TextBlock Text="Gemonitorde Modbus Tags (alarmen en outlier detectie hier instellen):" Margin="0,0,0,5" FontStyle="Italic" TextWrapping="Wrap"/>
                            <DataGrid ItemsSource="{Binding TagsToMonitor}" AutoGenerateColumns="False" CanUserAddRows="True" CanUserDeleteRows="True" MaxHeight="300" VerticalScrollBarVisibility="Auto"
                                      AddingNewItem="DataGrid_AddingNewItem_ModbusTag"> <DataGrid.Columns>
                                    <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName, UpdateSourceTrigger=PropertyChanged}" Width="1.2*"/>                                    <DataGridTextColumn Header="Adres" Binding="{Binding Address, UpdateSourceTrigger=LostFocus}" Width="Auto"/>
                                    <DataGridComboBoxColumn Header="Register Type" SelectedValueBinding="{Binding RegisterType}" ItemsSource="{Binding Source={StaticResource ModbusRegisterTypeEnumValues}}" Width="*"/>
                                    <DataGridComboBoxColumn Header="Data Type" SelectedValueBinding="{Binding DataType}" ItemsSource="{Binding Source={StaticResource ModbusDataTypeEnumValues}}" IsReadOnly="{Binding IsDataTypeSelectionEnabled, Converter={StaticResource InverseBooleanConverter}}" Width="*"/>
                                    <DataGridCheckBoxColumn Header="Tag Actief?" Binding="{Binding IsActive, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>

                                    <DataGridCheckBoxColumn Header="Drempel Alarm?" Binding="{Binding IsAlarmingEnabled, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                                    <DataGridTextColumn Header="HH Lim." Binding="{Binding HighHighLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    <DataGridTextColumn Header="H Lim." Binding="{Binding HighLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    <DataGridTextColumn Header="L Lim." Binding="{Binding LowLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>
                                    <DataGridTextColumn Header="LL Lim." Binding="{Binding LowLowLimit, UpdateSourceTrigger=LostFocus, TargetNullValue=''}" Width="0.6*"/>

                                    <DataGridCheckBoxColumn Header="Outlier Detectie?" Binding="{Binding IsOutlierDetectionEnabled, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                                    <DataGridTextColumn Header="Baseline N" Binding="{Binding BaselineSampleSize, UpdateSourceTrigger=LostFocus, TargetNullValue='20'}" Width="0.7*"/>
                                    <DataGridTextColumn Header="StdDev Factor" Binding="{Binding OutlierStandardDeviationFactor, UpdateSourceTrigger=LostFocus, TargetNullValue='3.0'}" Width="0.8*"/>
                                    
                                    <DataGridTextColumn Header="Alarm Bericht Format" Binding="{Binding AlarmMessageFormat, UpdateSourceTrigger=LostFocus}" Width="2*"/>
                                </DataGrid.Columns>
                            </DataGrid>
                        </StackPanel>
                    </GroupBox>
                </StackPanel>
            </ScrollViewer>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition MinWidth="200" Width="250" />
            <ColumnDefinition Width="5" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <ToolBar
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="0"
            Padding="5">
            <Button
                Command="{Binding AddOpcUaConnectionCommand}"
                Content="Nieuwe OPC UA"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding AddModbusTcpConnectionCommand}"
                Content="Nieuwe Modbus TCP"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding RemoveConnectionCommand}"
                Content="Verwijder Geselecteerde"
                Foreground="Red" />
        </ToolBar>

        <GroupBox
            Grid.Column="0"
            Grid.Row="1"
            Header="Verbindingen"
            Margin="5">
            <ListView
                DisplayMemberPath="ConnectionName"
                ItemsSource="{Binding WorkingConnections}"
                SelectedItem="{Binding SelectedConnection}" />
        </GroupBox>

        <GridSplitter
            Background="LightGray"
            Grid.Column="1"
            Grid.Row="1"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Stretch"
            Width="5" />

        <GroupBox
            Grid.Column="2"
            Grid.Row="1"
            Header="Details"
            Margin="5">
            <ContentControl Content="{Binding SelectedConnection}" />
        </GroupBox>

        <StackPanel
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="2"
            HorizontalAlignment="Right"
            Margin="10"
            Orientation="Horizontal">
            <Button
                Command="{Binding SaveCommand}"
                Content="Opslaan"
                IsDefault="True"
                Margin="0,0,10,0"
                MinWidth="80" />
            <Button
                Command="{Binding CancelCommand}"
                Content="Annuleren"
                IsCancel="True"
                MinWidth="80" />
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using Data_Logger.Models;
using Opc.Ua;

namespace Data_Logger.Views
{
    public partial class SettingsView : Window
    {
        public SettingsView()
        {
            InitializeComponent();
        }

        private void DataGrid_AddingNewItem_ModbusTag(object sender, AddingNewItemEventArgs e)
        {
            e.NewItem = new ModbusTagConfig
            {
                TagName = "Nieuwe Modbus Tag",
                Address = 0,
                IsActive = true,
                IsAlarmingEnabled = false, 
                IsOutlierDetectionEnabled = false, 
                BaselineSampleSize = 20,
                OutlierStandardDeviationFactor = 3.0
                
            };
        }
    }
    
    public static class OpcUaSecurityModeValues
    {
        
        public static IEnumerable<MessageSecurityMode> Instance => 
            Enum.GetValues(typeof(MessageSecurityMode)).Cast<MessageSecurityMode>();
    }

    public static class OpcUaSecurityPolicyValues
    {
        public static IEnumerable<string> GetInstance()
        {
            return new List<string>
            {
                SecurityPolicies.None,
                SecurityPolicies.Basic256Sha256,
            };
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SinglePlotView.xaml"
<UserControl x:Class="Data_Logger.Views.SinglePlotView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:local="clr-namespace:Data_Logger.Views"
             xmlns:scottplot="http://schemas.scottplot.net/2008/xaml/presentation"
             mc:Ignorable="d"
             d:DesignHeight="300" d:DesignWidth="300">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/> <RowDefinition Height="Auto"/> </Grid.RowDefinitions>
        <WpfPlot x:Name="ChartControl"/>
        
        <Border Grid.Row="1" Background="#EEEEEE" Padding="5">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                <Button Command="{Binding FitDataToViewCommand}" 
                        Content="Zoom Passend" 
                        MinWidth="100" Margin="5,0"/>

            </StackPanel>
        </Border>
    </Grid>
</UserControl>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SinglePlotView.xaml.cs"
using System;
using System.Windows;
using System.Windows.Controls;
using Data_Logger.ViewModels;
using Data_Logger.ViewModels;
using Data_Logger.ViewModels.Plotting;

namespace Data_Logger.Views
{
    public partial class SinglePlotView : UserControl
    {
        private PlotTabViewModel _viewModel;

        public SinglePlotView()
        {
            InitializeComponent();
            this.DataContextChanged += OnDataContextChanged;
            this.IsVisibleChanged += OnIsVisibleChanged;
            this.Unloaded += UserControl_Unloaded;
        }

        private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            UpdateViewModelReferences(e.OldValue as PlotTabViewModel, e.NewValue as PlotTabViewModel);
            // if (_viewModel != null)
            // {
            //     _viewModel.PlotModelChanged -= OnViewModelPlotModelChanged;
            // }
            //
            // if (e.NewValue is PlotTabViewModel newVm)
            // {
            //     _viewModel = newVm;
            //     ChartControl.Reset(_viewModel.PlotModel);
            //     _viewModel.PlotModelChanged += OnViewModelPlotModelChanged;
            //     _viewModel.InitializePlotRender();
            // }
            // else
            // {
            //     var cleanPlot = new ScottPlot.Plot();
            //     cleanPlot.Title("Geen data geladen");
            //     ChartControl.Reset(cleanPlot);
            // }
        }
        
        private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            // Wanneer de control zichtbaar wordt, zorg ervoor dat de plot correct is ingesteld en gerenderd.
            if (this.IsVisible && _viewModel != null && ChartControl != null)
            {
                // _viewModel.PlotModel is het bestaande model, we willen zeker zijn dat de ChartControl het gebruikt.
                // ChartControl.Reset() zorgt ervoor dat de WpfPlot control intern het juiste Plot object gebruikt.
                ChartControl.Reset(_viewModel.PlotModel); 
                
                // Vraag een render aan om de huidige staat van _viewModel.PlotModel te tonen.
                // InitializePlotRender zou dit ook moeten doen, of direct OnViewModelPlotModelChanged aanroepen.
                _viewModel.InitializePlotRender(); // Dit roept intern ExecuteFitDataToView -> OnPlotModelChanged
                // Of direct: OnViewModelPlotModelChanged(this, EventArgs.Empty);
                
                _viewModel.PlotModelChanged += OnViewModelPlotModelChanged; // Her-abonneer voor de zekerheid (als het in Unloaded was losgekoppeld)
                
                // _logger?.Debug("SinglePlotView voor {Header} is zichtbaar geworden, plot gereset en render aangevraagd.", _viewModel.Header);
            }
            else if (!this.IsVisible && _viewModel != null)
            {
                // Optioneel: Afmelden van events wanneer niet zichtbaar om resources te sparen,
                // maar dan moet je je weer abonneren in OnIsVisibleChanged.
                // _viewModel.PlotModelChanged -= OnViewModelPlotModelChanged;
            }
        }
        
        private void UpdateViewModelReferences(PlotTabViewModel oldVm, PlotTabViewModel newVm)
        {
            if (oldVm != null)
            {
                oldVm.PlotModelChanged -= OnViewModelPlotModelChanged;
            }

            _viewModel = newVm; // Sla de nieuwe ViewModel op

            if (_viewModel != null)
            {
                ChartControl.Reset(_viewModel.PlotModel); 
                _viewModel.PlotModelChanged += OnViewModelPlotModelChanged;
                // Forceer een initiële render gebaseerd op de huidige staat van de nieuwe ViewModel.
                // InitializePlotRender is ontworpen om de plot correct op te zetten.
                _viewModel.InitializePlotRender(); 
            }
            else
            {
                // Geen ViewModel, toon een lege/default plot
                var cleanPlot = new ScottPlot.Plot();
                cleanPlot.Title("Geen data geladen");
                ChartControl.Reset(cleanPlot); 
                ChartControl.Refresh(); // Render de lege plot
            }
        }



        private void OnViewModelPlotModelChanged(object sender, EventArgs e)
        {
            if (ChartControl != null && ChartControl.IsVisible && Application.Current != null)
            {
                Application.Current.Dispatcher.Invoke(() =>
                {
                    if (ChartControl.IsVisible)
                        ChartControl.Refresh();
                });
            }
        }

        private void UserControl_Unloaded(object sender, RoutedEventArgs e)
        {
            if (_viewModel != null)
            {
                _viewModel.PlotModelChanged -= OnViewModelPlotModelChanged;
            }
            _viewModel = null;
        }
    }
}




