// Basis map repository: "C:\Development\Projects\Afstudeeropdracht\Data Logger"
// Script uitgevoerd op: "05/11/2025 15:45:33"
// Inclusie relatieve mappen: Converters, Models, Services, ViewModels, Windows, Assets, Config, Core, Enums, Views, Opc.Ua.Client, .
// Exclusie subpad patronen (-like): \bin\, \obj\, \packages\, \.idea\, \.vs\, \.git\, \output\
// Bestanden verder gefilterd op toegestane extensies en bestandsnamen.

// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml"
<Application
    x:Class="Data_Logger.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:converters1="clr-namespace:Data_Logger.Converters"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Application.Resources>
        <converters1:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" xmlns:converters="clr-namespace:Data_Logger.Converters" />
    </Application.Resources>
</Application>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml.cs"
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Threading.Tasks;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services;
using Data_Logger.Services.Abstractions;
using Data_Logger.Services.Implementations;
using Data_Logger.ViewModels;
using Data_Logger.Views;
using Microsoft.Extensions.DependencyInjection;
using Opc.Ua;
using Opc.Ua.Configuration;
using Serilog;

namespace Data_Logger
{
    public partial class App
    {
        public IServiceProvider ServiceProvider { get; private set; }

        private ILoggingHostService _theActualLoggingHostService;

        private ApplicationConfiguration _opcUaAppConfig;

        public App()
        {
            _theActualLoggingHostService = new LoggingHostService();

            string logsDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
            if (!Directory.Exists(logsDirectory))
                Directory.CreateDirectory(logsDirectory);
            string logFilePath = Path.Combine(logsDirectory, "DataLoggerApp_.log");

            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.Console()
                .WriteTo.File(
                    logFilePath,
                    rollingInterval: RollingInterval.Day,
                    retainedFileCountLimit: 7,
                    outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
                )
                .WriteTo.Sink(new UiLogSink(_theActualLoggingHostService))
                .CreateLogger();

            _opcUaAppConfig = CreateOpcUaApplicationConfiguration();

            var serviceCollection = new ServiceCollection();
            ConfigureServices(serviceCollection);
            ServiceProvider = serviceCollection.BuildServiceProvider();

            var loggerFromDI = ServiceProvider.GetService<ILogger>();
            loggerFromDI?.Information(
                "Applicatie initialisatie voltooid in App constructor (ServiceProvider is gebouwd)."
            );
        }

        private void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<ILogger>(Log.Logger);
            services.AddSingleton<ILoggingHostService>(_theActualLoggingHostService);

            services.AddSingleton<IStatusService, StatusService>();
            services.AddSingleton<ISettingsService, SettingsService>();
            services.AddSingleton<IDataLoggingService, DataLoggingService>();

            services.AddSingleton<ApplicationConfiguration>(_opcUaAppConfig);

            services.AddSingleton<LogViewModel>(serviceProvider => new LogViewModel(
                serviceProvider.GetRequiredService<ILoggingHostService>(),
                serviceProvider.GetRequiredService<ILogger>()
            ));

            services.AddTransient<Func<ModbusTcpConnectionConfig, IModbusService>>(
                serviceProvider =>
                    config => new ModbusService(
                        serviceProvider.GetRequiredService<ILogger>(),
                        config
                    )
            );

            services.AddTransient<Func<OpcUaConnectionConfig, IOpcUaService>>(serviceProvider =>
                config => new OpcUaService(
                    serviceProvider.GetRequiredService<ILogger>(),
                    config,
                    serviceProvider.GetRequiredService<ApplicationConfiguration>()
                )
            );

            services.AddSingleton<MainViewModel>(serviceProvider => new MainViewModel(
                serviceProvider.GetRequiredService<ILogger>(),
                serviceProvider.GetRequiredService<LogViewModel>(),
                serviceProvider.GetRequiredService<IStatusService>(),
                serviceProvider.GetRequiredService<ISettingsService>(),
                serviceProvider.GetRequiredService<Func<Action, SettingsViewModel>>(),
                serviceProvider.GetRequiredService<
                    Func<ModbusTcpConnectionConfig, IModbusService>
                >(),
                serviceProvider.GetRequiredService<Func<OpcUaConnectionConfig, IOpcUaService>>(),
                serviceProvider.GetRequiredService<IDataLoggingService>()
            ));

            services.AddTransient<Func<Action, SettingsViewModel>>(serviceProvider =>
                closeAction => new SettingsViewModel(
                    serviceProvider.GetRequiredService<ISettingsService>(),
                    serviceProvider.GetRequiredService<IStatusService>(),
                    serviceProvider.GetRequiredService<ILogger>(),
                    closeAction
                )
            );
        }

        protected override void OnStartup(StartupEventArgs e)
        {
            Log.Information("App.OnStartup: Begin van OnStartup.");

            var mainWindow = new MainWindow
            {
                DataContext = ServiceProvider.GetRequiredService<MainViewModel>(),
            };
            mainWindow.Show();

            Log.Debug("App.OnStartup: MainWindow getoond.");

            base.OnStartup(e);
        }

        private ApplicationConfiguration CreateOpcUaApplicationConfiguration()
        {
            var localLogger = Serilog.Log.Logger.ForContext<App>();

            string applicationName = "DataLogger";
            string hostName = Dns.GetHostName();

            string executableLocation = Assembly.GetExecutingAssembly().Location;
            string applicationDirectory = Path.GetDirectoryName(executableLocation);

            string certStoresBasePath = Path.Combine(applicationDirectory, "CertificateStores");
            string ownCertStorePath = Path.Combine(certStoresBasePath, "own");
            string trustedPeersStorePath = Path.Combine(certStoresBasePath, "trusted", "certs");
            string trustedIssuerStorePath = Path.Combine(certStoresBasePath, "issuer", "certs");
            string rejectedCertStorePath = Path.Combine(certStoresBasePath, "rejected", "certs");

            string trustedPeersCrlPath = Path.Combine(certStoresBasePath, "trusted", "crl");
            string trustedIssuerCrlPath = Path.Combine(certStoresBasePath, "issuer", "crl");

            localLogger.Information(
                "OPC UA Client Cert Store Base Path: {Path}",
                certStoresBasePath
            );

            var config = new ApplicationConfiguration
            {
                ApplicationName = applicationName,
                ApplicationUri = Utils.Format(@"urn:{0}:{1}", hostName, applicationName),
                ApplicationType = ApplicationType.Client,
                ProductUri = "urn:DataLogger:OpcUaClient",
                SecurityConfiguration = new SecurityConfiguration
                {
                    ApplicationCertificate = new CertificateIdentifier
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = ownCertStorePath,
                        SubjectName = Utils.Format(@"CN={0}, DC={1}", applicationName, hostName),
                    },
                    TrustedIssuerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = trustedIssuerStorePath,
                    },
                    TrustedPeerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = trustedPeersStorePath,
                    },
                    RejectedCertificateStore = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = rejectedCertStorePath,
                    },
                    AutoAcceptUntrustedCertificates = true,
                    AddAppCertToTrustedStore = true,
                    RejectSHA1SignedCertificates = false,
                    MinimumCertificateKeySize = 2048,
                },
                TransportConfigurations = new TransportConfigurationCollection(),
                TransportQuotas = new TransportQuotas { OperationTimeout = 15000 },
                ClientConfiguration = new ClientConfiguration { DefaultSessionTimeout = 60000 },
                TraceConfiguration = new TraceConfiguration
                {
                    OutputFilePath = Path.Combine(
                        applicationDirectory,
                        "Logs",
                        $"{applicationName}.OpcUaClient.log.txt"
                    ),
                    DeleteOnLoad = true,
                    TraceMasks =
                        Utils.TraceMasks.Error
                        | Utils.TraceMasks.Security
                        | Utils.TraceMasks.StackTrace,
                },
            };
            config.Validate(ApplicationType.Client).GetAwaiter().GetResult();

            if (config.SecurityConfiguration.AutoAcceptUntrustedCertificates)
            {
                config.CertificateValidator.CertificateValidation += (s, e) =>
                {
                    e.Accept = (e.Error.StatusCode == StatusCodes.BadCertificateUntrusted);
                };
            }

            var application = new ApplicationInstance
            {
                ApplicationName = "DataLogger",
                ApplicationType = ApplicationType.Client,
                ApplicationConfiguration = config,
            };

            application.CheckApplicationInstanceCertificates(false, 24).GetAwaiter().GetResult();

            return config;
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Log.CloseAndFlush();
            base.OnExit(e);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\BooleanToConnectionStatusConverter.cs"
using System;
using System.Globalization;
using System.Windows.Data;

namespace Data_Logger.Converters
{
    public class BooleanToConnectionStatusConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isConnected)
            {
                return isConnected ? "Verbonden" : "Niet Verbonden";
            }
            return "Onbekend";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\ObservableObject.cs"
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Data_Logger.Core
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\RelayCommand.cs"
using System;
using System.Windows.Input;

namespace Data_Logger.Core
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;
        
        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }
        
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
        
        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ApplicationStatus.cs"
namespace Data_Logger.Enums
{
    public enum ApplicationStatus
    {
        Idle,        
        Connecting,  
        Logging,     
        Warning,     
        Error,       
        Loading,     
        Saving       
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ConnectionType.cs"
namespace Data_Logger.Enums
{
    public enum ConnectionType
    {
        OpcUa,
        ModbusTcp
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusDataType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusDataType
    {
        Boolean,

        Int16,
        UInt16,

        Int32,
        UInt32,
        Float32,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusRegisterType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusRegisterType
    {
        HoldingRegister,  
        InputRegister,    
        Coil,             
        DiscreteInput     
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\OpcUaDataType.cs"
namespace Data_Logger.Enums
{
    public enum OpcUaDataType
    {
        Variant,
        Boolean,
        SByte,
        Byte,
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,
        Double,
        String,
        DateTime,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\AppSettings.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;

namespace Data_Logger.Models
{
    public class AppSettings : ObservableObject
    {
        private ObservableCollection<ConnectionConfigBase> _connections;

        public ObservableCollection<ConnectionConfigBase> Connections
        {
            get => _connections;
            set => SetProperty(ref _connections, value);
        }

        public AppSettings()
        {
            Connections = new ObservableCollection<ConnectionConfigBase>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ConnectionConfigBase.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public abstract class ConnectionConfigBase : ObservableObject
    {
        private string _connectionName;
        private ConnectionType _type;
        private bool _isEnabled = true;
        private int _scanIntervalSeconds = 5;

        public string ConnectionName
        {
            get => _connectionName;
            set => SetProperty(ref _connectionName, value);
        }

        public ConnectionType Type
        {
            get => _type;
            protected set => SetProperty(ref _type, value);
        }

        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        public int ScanIntervalSeconds
        {
            get => _scanIntervalSeconds;
            set => SetProperty(ref _scanIntervalSeconds, value);
        }

        protected ConnectionConfigBase(ConnectionType type)
        {
            Type = type;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\LoggedTagValue.cs"
using System;

namespace Data_Logger.Models
{
    public class LoggedTagValue
    {
        public string TagName { get; set; }
        public object Value { get; set; }
        public DateTime Timestamp { get; set; }
        public bool IsGoodQuality { get; set; } = true;
        public string ErrorMessage { get; set; }

        public string FormattedValue
        {
            get
            {
                if (!IsGoodQuality)
                    return ErrorMessage ?? "Error";
                return Value?.ToString() ?? "N/A";
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTagConfig.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private ushort _address;
        public ushort Address
        {
            get => _address;
            set => SetProperty(ref _address, value);
        }

        private ModbusRegisterType _registerType = ModbusRegisterType.HoldingRegister;
        public ModbusRegisterType RegisterType
        {
            get => _registerType;
            set
            {
                if (SetProperty(ref _registerType, value))
                {
                    if (
                        _registerType == ModbusRegisterType.Coil
                        || _registerType == ModbusRegisterType.DiscreteInput
                    )
                    {
                        DataType = ModbusDataType.Boolean;
                    }
                    OnPropertyChanged(nameof(IsDataTypeSelectionEnabled));
                }
            }
        }

        private ModbusDataType _dataType = ModbusDataType.UInt16;
        public ModbusDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        public bool IsDataTypeSelectionEnabled =>
            RegisterType != ModbusRegisterType.Coil
            && RegisterType != ModbusRegisterType.DiscreteInput;

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTcpConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTcpConnectionConfig : ConnectionConfigBase
    {
        private string _ipAddress = "127.0.0.1";
        private int _port = 502;
        private byte _unitId = 1;

        private ObservableCollection<ModbusTagConfig> _tagsToMonitor;
        public ObservableCollection<ModbusTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public string IpAddress
        {
            get => _ipAddress;
            set => SetProperty(ref _ipAddress, value);
        }

        public int Port
        {
            get => _port;
            set => SetProperty(ref _port, value);
        }

        public byte UnitId
        {
            get => _unitId;
            set => SetProperty(ref _unitId, value);
        }

        public ModbusTcpConnectionConfig()
            : base(ConnectionType.ModbusTcp)
        {
            ConnectionName = "Nieuwe Modbus TCP Verbinding";
            TagsToMonitor = new ObservableCollection<ModbusTagConfig>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;
using Data_Logger.Enums;
using Opc.Ua;

namespace Data_Logger.Models
{
    public class OpcUaConnectionConfig : ConnectionConfigBase
    {
        private string _endpointUrl = "opc.tcp://localhost:4840";
        public string EndpointUrl
        {
            get => _endpointUrl;
            set => SetProperty(ref _endpointUrl, value);
        }

        private MessageSecurityMode _securityMode = MessageSecurityMode.None;
        public MessageSecurityMode SecurityMode
        {
            get => _securityMode;
            set => SetProperty(ref _securityMode, value);
        }

        private string _securityPolicyUri = SecurityPolicies.None;
        public string SecurityPolicyUri
        {
            get => _securityPolicyUri;
            set => SetProperty(ref _securityPolicyUri, value);
        }

        private string _userName;
        public string UserName
        {
            get => _userName;
            set => SetProperty(ref _userName, value);
        }

        private string _password;
        public string Password
        {
            get => _password;
            set => SetProperty(ref _password, value);
        }

        private ObservableCollection<OpcUaTagConfig> _tagsToMonitor;
        public ObservableCollection<OpcUaTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public OpcUaConnectionConfig()
            : base(ConnectionType.OpcUa)
        {
            ConnectionName = "Nieuwe OPC UA Verbinding";
            TagsToMonitor = new ObservableCollection<OpcUaTagConfig>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaTagConfig.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class OpcUaTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe OPC UA Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private string _nodeId = "ns=2;s=MyVariable";
        public string NodeId
        {
            get => _nodeId;
            set => SetProperty(ref _nodeId, value);
        }

        private OpcUaDataType _dataType = OpcUaDataType.Variant;
        public OpcUaDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        private int _samplingInterval = 1000;
        public int SamplingInterval
        {
            get => _samplingInterval;
            set => SetProperty(ref _samplingInterval, value);
        }

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\UiLogEntry.cs"
using System;
using Serilog.Events;

namespace Data_Logger.Models
{
    public class UiLogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogEventLevel Level { get; set; }
        public string LevelDisplay => Level.ToString();
        public string Message { get; set; }
        public string RenderedMessage { get; set; }
        public string Exception { get; set; }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\UiLogSink.cs"
using System;
using System.IO;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog.Core;
using Serilog.Events;

namespace Data_Logger.Services
{
    public class UiLogSink : ILogEventSink
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly IFormatProvider _formatProvider;
        private bool _instanceIdLoggedFromEmit = false;

        public UiLogSink(
            ILoggingHostService loggingHostService,
            IFormatProvider formatProvider = null
        )
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _formatProvider = formatProvider;

            Console.WriteLine(
                $"[DIAGNOSTIC] UiLogSink Constructor: Gebruikt LoggingHostService met InstanceId: {_loggingHostService.InstanceId}"
            );
        }

        public void Emit(LogEvent logEvent)
        {
            if (!_instanceIdLoggedFromEmit)
            {
                Console.WriteLine(
                    $"[DIAGNOSTIC] UiLogSink.Emit: Eerste aanroep met LoggingHostService InstanceId: {_loggingHostService.InstanceId}"
                );
                _instanceIdLoggedFromEmit = true;
            }

            if (logEvent == null)
                return;

            var renderedMessage = RenderLogEvent(logEvent);

            var uiEntry = new UiLogEntry
            {
                Timestamp = logEvent.Timestamp.DateTime.ToLocalTime(),
                Level = logEvent.Level,
                Message = logEvent.MessageTemplate.Text,
                RenderedMessage = renderedMessage,
                Exception = logEvent.Exception?.ToString(),
            };

            _loggingHostService.AddLogEntry(uiEntry);
        }

        private string RenderLogEvent(LogEvent logEvent)
        {
            var writer = new StringWriter();
            logEvent.RenderMessage(writer, _formatProvider);
            if (logEvent.Exception != null)
            {
                writer.WriteLine();
                writer.Write(logEvent.Exception.ToString());
            }
            return writer.ToString();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IDataLoggingService.cs"
using System.Collections.Generic;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface IDataLoggingService
    {
        void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ILoggingHostService.cs"
using System.Collections.ObjectModel;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ILoggingHostService
    {
        string InstanceId { get; }
        ObservableCollection<UiLogEntry> LogEntries { get; }
        void AddLogEntry(UiLogEntry entry);
        void ClearLogs();
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IModbusService.cs"
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public class ModbusDataPoint
    {
        public ushort Address { get; set; }
        public ushort Value { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public interface IModbusService : IDisposable
    {
        bool IsConnected { get; }
        event EventHandler ConnectionStatusChanged;
        event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        Task<bool> ConnectAsync();
        Task DisconnectAsync();
        Task PollConfiguredTagsAsync();
        void Reconfigure(ModbusTcpConnectionConfig newConfig);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IOpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Models;
using Opc.Ua;

namespace Data_Logger.Services.Abstractions;

public interface IOpcUaService : IDisposable
{
    bool IsConnected { get; }
    NamespaceTable NamespaceUris { get; }
    event EventHandler ConnectionStatusChanged;

    event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

    Task<bool> ConnectAsync();
    Task DisconnectAsync();
    void Reconfigure(OpcUaConnectionConfig newConfig);
    Task StartMonitoringTagsAsync();
    Task StopMonitoringTagsAsync();
    Task<IEnumerable<LoggedTagValue>> ReadCurrentTagValuesAsync();

    Task<ReferenceDescriptionCollection> BrowseAsync(
        NodeId nodeIdToBrowse,
        NodeId referenceTypeId = null,
        bool includeSubtypes = true,
        BrowseDirection direction = BrowseDirection.Forward,
        NodeClass nodeClassMask = NodeClass.Unspecified,
        CancellationToken ct = default
    );
    
    Task<ReferenceDescriptionCollection> BrowseRootAsync();
    
    Task<DataValue> ReadValueAsync(NodeId nodeId); 
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ISettingsService.cs"
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ISettingsService
    {
        AppSettings CurrentSettings { get; }
        void LoadSettings();
        void SaveSettings();
        void LoadDefaultSettings();
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IStatusService.cs"
using Data_Logger.Enums;

namespace Data_Logger.Services.Abstractions
{
    public interface IStatusService
    {
        ApplicationStatus CurrentStatus { get; }
        string StatusMessage { get; }
        void SetStatus(ApplicationStatus status, string message);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\DataLoggingService.cs"
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class DataLoggingService : IDataLoggingService
    {
        private readonly ILogger _logger;
        private readonly string _baseLogDirectory;
        private readonly object _fileLock = new object();

        public DataLoggingService(ILogger logger)
        {
            _logger = logger.ForContext<DataLoggingService>();

            string executableLocation = Path.GetDirectoryName(
                System.Reflection.Assembly.GetExecutingAssembly().Location
            );
            _baseLogDirectory = Path.Combine(executableLocation, "LoggedData");

            try
            {
                if (!Directory.Exists(_baseLogDirectory))
                {
                    Directory.CreateDirectory(_baseLogDirectory);
                    _logger.Information(
                        "CSV Log data map aangemaakt: {LogDirectory}",
                        _baseLogDirectory
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het aanmaken van de CSV log data map: {LogDirectory}",
                    _baseLogDirectory
                );
            }
        }

        public void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues)
        {
            if (tagValues == null || !tagValues.Any())
            {
                return;
            }

            string sanitizedConnectionName = SanitizeFileName(connectionName);
            string fileName = $"{sanitizedConnectionName}_{DateTime.Now:yyyyMMdd}.csv";
            string filePath = Path.Combine(_baseLogDirectory, fileName);

            StringBuilder csvBuilder = new StringBuilder();
            bool fileExistsAndHasContent =
                File.Exists(filePath) && new FileInfo(filePath).Length > 0;

            if (!fileExistsAndHasContent)
            {
                csvBuilder.AppendLine("Timestamp,TagName,Value,IsGoodQuality,ErrorMessage");
            }

            foreach (var tagValue in tagValues)
            {
                string safeTagName = EscapeCsvField(tagValue.TagName);
                string safeValue = EscapeCsvField(tagValue.Value?.ToString() ?? string.Empty);
                string safeErrorMessage = EscapeCsvField(tagValue.ErrorMessage ?? string.Empty);

                csvBuilder.AppendFormat(
                    CultureInfo.InvariantCulture,
                    "{0},{1},{2},{3},{4}{5}",
                    tagValue.Timestamp.ToString(
                        "yyyy-MM-dd HH:mm:ss.fff",
                        CultureInfo.InvariantCulture
                    ),
                    safeTagName,
                    safeValue,
                    tagValue.IsGoodQuality,
                    safeErrorMessage,
                    Environment.NewLine
                );
            }

            string contentToWrite = csvBuilder.ToString();

            if (
                string.IsNullOrWhiteSpace(
                    contentToWrite
                        .Replace(
                            "Timestamp,TagName,Value,IsGoodQuality,ErrorMessage"
                                + Environment.NewLine,
                            ""
                        )
                        .Replace(Environment.NewLine, "")
                )
            )
            {
                if (!tagValues.Any() && !fileExistsAndHasContent)
                    return;
                if (
                    tagValues.Any()
                    && !fileExistsAndHasContent
                    && contentToWrite.StartsWith("Timestamp,TagName")
                )
                { /* Alleen header, wel schrijven als er data is */
                }
                else if (string.IsNullOrWhiteSpace(contentToWrite.Replace(Environment.NewLine, "")))
                {
                    return;
                }
            }

            try
            {
                lock (_fileLock)
                {
                    using (
                        FileStream stream = new FileStream(
                            filePath,
                            FileMode.Append,
                            FileAccess.Write,
                            FileShare.Read
                        )
                    )
                    using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8))
                    {
                        writer.Write(contentToWrite);
                    }
                }
                _logger.Debug(
                    "Data gelogd naar {FilePath} voor connectie {ConnectionName}. Aantal tags: {TagCount}",
                    filePath,
                    connectionName,
                    tagValues.Count()
                );
            }
            catch (IOException ioEx) when (IsFileLocked(ioEx))
            {
                _logger.Warning(
                    ioEx,
                    "CSV bestand {FilePath} is geblokkeerd (sharing violation/lock) tijdens poging tot schrijven. Data voor dit interval mogelijk niet gelogd.",
                    filePath
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout bij het wegschrijven van tag data naar CSV voor connectie {ConnectionName} naar bestand {FilePath}",
                    connectionName,
                    filePath
                );
            }
        }

        private bool IsFileLocked(IOException exception)
        {
            int errorCode = Marshal.GetHRForException(exception) & 0xFFFF;
            return errorCode == 32 || errorCode == 33;
        }

        private string SanitizeFileName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return "DefaultConnection";
            return Path.GetInvalidFileNameChars()
                .Aggregate(name, (current, c) => current.Replace(c.ToString(), string.Empty));
        }

        private string EscapeCsvField(string field)
        {
            if (string.IsNullOrEmpty(field))
                return string.Empty;
            if (
                field.Contains(",")
                || field.Contains("\"")
                || field.Contains("\r")
                || field.Contains("\n")
            )
            {
                return $"\"{field.Replace("\"", "\"\"")}\"";
            }
            return field;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\LoggingHostService.cs"
using System.Collections.ObjectModel;
using System.Threading;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;

namespace Data_Logger.Services.Implementations
{
    public class LoggingHostService : ILoggingHostService
    {
        public string InstanceId { get; }
        private static int _instanceCounter = 0;

        public ObservableCollection<UiLogEntry> LogEntries { get; }

        private const int MaxLogEntries = 1000;

        public LoggingHostService()
        {
            InstanceId = $"LHS_Instance_{Interlocked.Increment(ref _instanceCounter)}";

            LogEntries = new ObservableCollection<UiLogEntry>();
        }

        public void AddLogEntry(UiLogEntry entry)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (MaxLogEntries > 0 && LogEntries.Count >= MaxLogEntries)
                {
                    LogEntries.RemoveAt(LogEntries.Count - 1);
                }
                LogEntries.Insert(0, entry);
            });
        }

        public void ClearLogs()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                LogEntries.Clear();
            });
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\ModbusService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Modbus;
using Modbus.Device;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class ModbusService : IModbusService
    {
        private readonly ILogger _logger;
        private ModbusTcpConnectionConfig _config;
        private TcpClient _tcpClient;
        private ModbusIpMaster _master;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);

        private bool _isConnected;
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        public ModbusService(ILogger logger, ModbusTcpConnectionConfig config)
        {
            _logger = logger
                .ForContext<ModbusService>()
                .ForContext("ConnectionName", config.ConnectionName);
            _config = config;
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            _logger.Information(
                "Bezig met verbinden met Modbus server: {IpAddress}:{Port}",
                _config.IpAddress,
                _config.Port
            );
            try
            {
                _tcpClient = new TcpClient();
                Task connectTask = _tcpClient.ConnectAsync(_config.IpAddress, _config.Port);
                Task timeoutTask = Task.Delay(5000);

                Task completedTask = await Task.WhenAny(connectTask, timeoutTask);

                if (completedTask == connectTask)
                {
                    await connectTask;

                    if (_tcpClient.Connected)
                    {
                        _master = ModbusIpMaster.CreateIp(_tcpClient);
                        if (_master != null)
                        {
                            _master.Transport.ReadTimeout = 2000;
                            _master.Transport.WriteTimeout = 2000;
                            IsConnected = true;
                            _logger.Information("Succesvol verbonden met Modbus server.");
                            return true;
                        }
                        else
                        {
                            _logger.Error(
                                "Kon ModbusIpMaster niet aanmaken na succesvolle TCP verbinding."
                            );
                            _tcpClient?.Close();
                            _tcpClient = null;
                            IsConnected = false;
                            return false;
                        }
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon niet verbinden met Modbus server (ConnectAsync voltooid, maar niet verbonden). IP: {IpAddress}",
                            _config.IpAddress
                        );
                        _tcpClient?.Close();
                        _tcpClient = null;
                        IsConnected = false;
                        return false;
                    }
                }
                else
                {
                    _logger.Warning(
                        "Timeout ({Timeout}ms) tijdens verbinden met Modbus server: {IpAddress}:{Port}",
                        5000,
                        _config.IpAddress,
                        _config.Port
                    );

                    _tcpClient?.Close();
                    _tcpClient = null;
                    IsConnected = false;

                    return false;
                }
            }
            catch (SocketException sockEx)
            {
                _logger.Error(
                    sockEx,
                    "SocketException tijdens verbinden met Modbus server {IpAddress}:{Port}. Foutcode: {ErrorCode}",
                    _config.IpAddress,
                    _config.Port,
                    sockEx.SocketErrorCode
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout tijdens verbinden met Modbus server {IpAddress}:{Port}",
                    _config.IpAddress,
                    _config.Port
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;
            _logger.Information("Verbinding met Modbus server verbreken...");
            await _semaphore.WaitAsync().ConfigureAwait(false);
            try
            {
                _logger.Debug("DisconnectAsync: Semaphore verkregen. Resources sluiten.");

                _master?.Dispose();
                _tcpClient?.Close();
                _tcpClient?.Dispose();

                _master = null;
                _tcpClient = null;
                IsConnected = false;
                _logger.Information("Verbinding met Modbus server daadwerkelijk verbroken.");
            }
            catch (Exception ex)
            {
                _logger.Warning(
                    ex,
                    "Fout tijdens daadwerkelijk sluiten van Modbus resources in DisconnectAsync."
                );

                _master = null;
                _tcpClient = null;
                IsConnected = false;
            }
            finally
            {
                _semaphore.Release();
                _logger.Debug("DisconnectAsync: Semaphore vrijgegeven.");
            }
        }

        public void Reconfigure(ModbusTcpConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            _logger.Information(
                "Herconfigureren van ModbusService {ConnectionName} met nieuwe instellingen. Oude scan interval: {OldInterval}, Nieuw: {NewInterval}. Aantal oude tags: {OldTagCount}, Nieuw: {NewTagCount}",
                _config.ConnectionName,
                _config.ScanIntervalSeconds,
                newConfig.ScanIntervalSeconds,
                _config.TagsToMonitor.Count,
                newConfig.TagsToMonitor.Count
            );

            _config = newConfig;
        }

        public async Task PollConfiguredTagsAsync()
        {
            if (!IsConnected || _master == null)
            {
                _logger.Warning("Kan geconfigureerde tags niet pollen, niet verbonden.");
                return;
            }

            var results = new List<LoggedTagValue>();
            var now = DateTime.Now;

            foreach (var tag in _config.TagsToMonitor.Where(t => t.IsActive))
            {
                var loggedTag = new LoggedTagValue { TagName = tag.TagName, Timestamp = now };
                await _semaphore.WaitAsync();
                try
                {
                    object value = null;
                    ushort numRegistersToRead = 1;
                    if (
                        tag.DataType == ModbusDataType.Int32
                        || tag.DataType == ModbusDataType.UInt32
                        || tag.DataType == ModbusDataType.Float32
                    )
                    {
                        numRegistersToRead = 2;
                    }

                    switch (tag.RegisterType)
                    {
                        case ModbusRegisterType.Coil:
                            bool[] coilValues = await _master.ReadCoilsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (coilValues != null && coilValues.Length > 0)
                                value = coilValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Coil mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.DiscreteInput:
                            bool[] discreteValues = await _master.ReadInputsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (discreteValues != null && discreteValues.Length > 0)
                                value = discreteValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Discrete Input mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.HoldingRegister:
                            ushort[] holdingRegs = await _master.ReadHoldingRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (holdingRegs == null || holdingRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Holding Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(holdingRegs, tag.DataType);
                            break;

                        case ModbusRegisterType.InputRegister:
                            ushort[] inputRegs = await _master.ReadInputRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (inputRegs == null || inputRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Input Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(inputRegs, tag.DataType);
                            break;
                    }
                    loggedTag.Value = value;
                    loggedTag.IsGoodQuality = true;
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het lezen/interpreteren van Modbus tag: {TagName} (Adres: {Address}, Type: {RegisterType})",
                        tag.TagName,
                        tag.Address,
                        tag.RegisterType
                    );
                    loggedTag.IsGoodQuality = false;
                    loggedTag.ErrorMessage = ex.Message;
                }
                finally
                {
                    _semaphore.Release();
                }
                results.Add(loggedTag);
            }
            TagsDataReceived?.Invoke(this, results);
        }

        private object InterpretRegisterData(ushort[] registers, ModbusDataType dataType)
        {
            switch (dataType)
            {
                case ModbusDataType.Boolean:
                    return registers[0] != 0;
                case ModbusDataType.Int16:
                    return (short)registers[0];
                case ModbusDataType.UInt16:
                    return registers[0];

                case ModbusDataType.Int32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Int32.");

                    byte[] bytesInt32 = new byte[4];
                    bytesInt32[0] = (byte)(registers[0] >> 8);
                    bytesInt32[1] = (byte)(registers[0] & 0xFF);
                    bytesInt32[2] = (byte)(registers[1] >> 8);
                    bytesInt32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesInt32);
                    return BitConverter.ToInt32(bytesInt32, 0);

                case ModbusDataType.UInt32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor UInt32.");
                    byte[] bytesUInt32 = new byte[4];
                    bytesUInt32[0] = (byte)(registers[0] >> 8);
                    bytesUInt32[1] = (byte)registers[0];
                    bytesUInt32[2] = (byte)(registers[1] >> 8);
                    bytesUInt32[3] = (byte)registers[1];
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesUInt32);
                    return BitConverter.ToUInt32(bytesUInt32, 0);

                case ModbusDataType.Float32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Float32.");
                    byte[] bytesFloat32 = new byte[4];

                    bytesFloat32[0] = (byte)(registers[0] >> 8);
                    bytesFloat32[1] = (byte)(registers[0] & 0xFF);
                    bytesFloat32[2] = (byte)(registers[1] >> 8);
                    bytesFloat32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesFloat32);
                    return BitConverter.ToSingle(bytesFloat32, 0);

                default:
                    _logger.Warning(
                        "Niet-ondersteund ModbusDataType voor interpretatie: {DataType}. Geeft ruwe ushort[0] terug.",
                        dataType
                    );
                    return registers[0];
            }
        }

        private bool _disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (disposing)
            {
                _logger.Debug(
                    "ModbusService.Dispose({Disposing}) aangeroepen voor {ConnectionName}",
                    disposing,
                    _config.ConnectionName
                );

                bool acquired = false;
                try
                {
                    acquired = _semaphore.Wait(1000);
                    if (acquired)
                    {
                        _logger.Debug(
                            "ModbusService.Dispose: Semaphore verkregen. Resources sluiten."
                        );
                        _master?.Dispose();
                        _tcpClient?.Close();
                        _tcpClient?.Dispose();
                    }
                    else
                    {
                        _logger.Warning(
                            "ModbusService.Dispose: Timeout bij wachten op semaphore. Resources worden mogelijk niet correct vrijgegeven door deze Dispose aanroep."
                        );
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "ModbusService.Dispose: Fout bij vrijgeven resources.");
                }
                finally
                {
                    if (acquired)
                        _semaphore.Release();
                }

                _master = null;
                _tcpClient = null;
                IsConnected = false;

                _semaphore?.Dispose();
            }
            _disposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\OpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Opc.Ua;
using Opc.Ua.Client;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class OpcUaService : IOpcUaService
    {
        private readonly ILogger _logger;
        private OpcUaConnectionConfig _config;
        private Session _session;
        private Subscription _subscription;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);
        private ApplicationConfiguration _appConfig;

        public NamespaceTable NamespaceUris => _session?.NamespaceUris;

        private bool _isConnected;
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        public OpcUaService(
            ILogger logger,
            OpcUaConnectionConfig config,
            ApplicationConfiguration appConfig
        )
        {
            _logger = logger
                .ForContext<OpcUaService>()
                .ForContext("ConnectionName", config.ConnectionName);
            _config = config ?? throw new ArgumentNullException(nameof(config));
            _appConfig = appConfig ?? throw new ArgumentNullException(nameof(appConfig));
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            await _semaphore.WaitAsync();
            try
            {
                if (IsConnected)
                    return true;

                _logger.Information(
                    "Bezig met verbinden met OPC UA server: {EndpointUrl}",
                    _config.EndpointUrl
                );

                EndpointDescription endpointDescription = null;
                EndpointDescriptionCollection serverEndpoints = null;

                try
                {
                    var discoveryEndpointConfiguration = EndpointConfiguration.Create(_appConfig);
                    discoveryEndpointConfiguration.OperationTimeout = 5000;

                    using (
                        var discoveryClient = DiscoveryClient.Create(
                            _appConfig,
                            new Uri(_config.EndpointUrl),
                            discoveryEndpointConfiguration
                        )
                    )
                    {
                        _logger.Information(
                            "Probeert endpoints op te halen van {DiscoveryUrl}",
                            discoveryClient.Endpoint.EndpointUrl
                        );
                        serverEndpoints = discoveryClient.GetEndpoints(null);
                        _logger.Information(
                            "{Count} endpoints ontvangen van de server.",
                            serverEndpoints?.Count ?? 0
                        );
                    }

                    if (serverEndpoints == null || serverEndpoints.Count == 0)
                    {
                        _logger.Error(
                            "Geen endpoints ontvangen van de server via {EndpointUrl}",
                            _config.EndpointUrl
                        );
                        return false;
                    }

                    endpointDescription = CoreClientUtils.SelectEndpoint(
                        _appConfig,
                        new Uri(_config.EndpointUrl),
                        serverEndpoints,
                        _config.SecurityMode != MessageSecurityMode.None
                    );
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het selecteren van het OPC UA endpoint voor {EndpointUrl}. Controleer de URL en server beschikbaarheid.",
                        _config.EndpointUrl
                    );
                    return false;
                }

                if (endpointDescription == null)
                {
                    _logger.Error(
                        "Geen geschikt OPC UA endpoint gevonden voor {EndpointUrl} met de huidige security instellingen.",
                        _config.EndpointUrl
                    );
                    return false;
                }

                _logger.Information(
                    "Geselecteerd endpoint: {SelectedEndpointUrl}, SecurityMode: {SecurityMode}, SecurityPolicy: {SecurityPolicy}",
                    endpointDescription.EndpointUrl,
                    endpointDescription.SecurityMode,
                    endpointDescription.SecurityPolicyUri
                );

                bool userSpecifiedSecurity =
                    !string.IsNullOrEmpty(_config.SecurityPolicyUri)
                    && _config.SecurityPolicyUri != SecurityPolicies.None;

                if (
                    userSpecifiedSecurity
                    && (
                        endpointDescription.SecurityMode != _config.SecurityMode
                        || endpointDescription.SecurityPolicyUri != _config.SecurityPolicyUri
                    )
                )
                {
                    _logger.Information(
                        "Gebruiker heeft specifieke security policy ({UserPolicy}) en mode ({UserMode}) opgegeven.",
                        _config.SecurityPolicyUri,
                        _config.SecurityMode
                    );

                    var matchingEndpoint = serverEndpoints.FirstOrDefault(ep =>
                        IsEndpointUrlMatch(ep.EndpointUrl, endpointDescription.EndpointUrl)
                        && ep.SecurityMode == _config.SecurityMode
                        && ep.SecurityPolicyUri == _config.SecurityPolicyUri
                    );

                    if (matchingEndpoint != null)
                    {
                        endpointDescription = matchingEndpoint;
                        _logger.Information(
                            "Endpoint succesvol aangepast aan gebruikersspecificatie: Policy {SecurityPolicy}, Mode {SecurityMode}",
                            endpointDescription.SecurityPolicyUri,
                            endpointDescription.SecurityMode
                        );
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon geen endpoint vinden dat exact overeenkomt met de gespecificeerde SecurityMode '{UserMode}' en SecurityPolicy '{UserPolicy}'. "
                                + "Valt terug op het best automatisch geselecteerde endpoint: Policy '{AutoPolicy}', Mode '{AutoMode}'. Controleer server configuratie.",
                            _config.SecurityMode,
                            _config.SecurityPolicyUri,
                            endpointDescription.SecurityPolicyUri,
                            endpointDescription.SecurityMode
                        );
                    }
                }

                var endpointConfiguration = EndpointConfiguration.Create(_appConfig);
                var configuredEndpoint = new ConfiguredEndpoint(
                    null,
                    endpointDescription,
                    endpointConfiguration
                );

                _session = await Session.Create(
                    _appConfig,
                    configuredEndpoint,
                    updateBeforeConnect: false,
                    checkDomain: false,
                    sessionName: _config.ConnectionName,
                    sessionTimeout: 60000,
                    identity: GetUserIdentity(),
                    preferredLocales: null
                );

                if (_session == null)
                {
                    _logger.Error(
                        "Kon geen OPC UA sessie aanmaken met {EndpointUrl}",
                        _config.EndpointUrl
                    );
                    return false;
                }

                _session.KeepAlive += Session_KeepAlive;
                //_session.Notification += Session_Notification;

                IsConnected = true;
                _logger.Information(
                    "Succesvol verbonden met OPC UA server: {EndpointUrl}",
                    _config.EndpointUrl
                );
                return true;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij verbinden met OPC UA server {EndpointUrl}",
                    _config.EndpointUrl
                );
                IsConnected = false;
                _session?.Dispose();
                _session = null;
                return false;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        private IUserIdentity GetUserIdentity()
        {
            if (!string.IsNullOrEmpty(_config.UserName))
            {
                return new UserIdentity(_config.UserName, _config.Password ?? string.Empty);
            }
            return new UserIdentity();
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;

            await _semaphore.WaitAsync();
            try
            {
                _logger.Information(
                    "Verbinding met OPC UA server verbreken: {EndpointUrl}",
                    _config.EndpointUrl
                );
                await StopMonitoringTagsAsync();

                _session?.Close();
                _session?.Dispose();
                _session = null;
                IsConnected = false;
                _logger.Information("Verbinding met OPC UA server verbroken.");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Fout bij verbreken van OPC UA verbinding.");
                IsConnected = false;
                _session = null;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public void Reconfigure(OpcUaConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            _logger.Information(
                "Herconfigureren van OpcUaService {ConnectionName} met nieuwe instellingen. Oude endpoint: {OldEndpoint}, Nieuw: {NewEndpoint}",
                _config.ConnectionName,
                _config.EndpointUrl,
                newConfig.EndpointUrl
            );

            bool endpointChanged =
                _config.EndpointUrl != newConfig.EndpointUrl
                || _config.SecurityMode != newConfig.SecurityMode
                || _config.SecurityPolicyUri != newConfig.SecurityPolicyUri
                || _config.UserName != newConfig.UserName;

            _config = newConfig;

            if (IsConnected)
            {
                _logger.Information(
                    "Tags of subscription parameters gewijzigd voor {ConnectionName}, herstart monitoring.",
                    _config.ConnectionName
                );
                Task.Run(async () =>
                {
                    await StopMonitoringTagsAsync();
                    await StartMonitoringTagsAsync();
                });
            }

            _logger.ForContext("ConnectionName", _config.ConnectionName);

            if (IsConnected && endpointChanged)
            {
                _logger.Information("Endpoint parameters gewijzigd, verbinding wordt herstart.");
                Task.Run(async () =>
                {
                    await DisconnectAsync();
                    await ConnectAsync();
                    await StartMonitoringTagsAsync();
                });
            }
            else if (IsConnected && _subscription != null)
            {
                _logger.Information(
                    "Tags of subscription interval gewijzigd, subscription wordt bijgewerkt."
                );
                Task.Run(async () =>
                {
                    await StopMonitoringTagsAsync();
                    await StartMonitoringTagsAsync();
                });
            }
        }

        public async Task StartMonitoringTagsAsync()
        {
            if (!IsConnected || _session == null || !_config.TagsToMonitor.Any(t => t.IsActive))
            {
                _logger.Information(
                    "Kan monitoring niet starten: niet verbonden, geen sessie, of geen actieve tags geconfigureerd."
                );
                return;
            }

            await _semaphore.WaitAsync();
            try
            {
                if (_subscription != null)
                {
                    _logger.Information(
                        "Verwijdert bestaande subscription alvorens een nieuwe te starten."
                    );
                    try
                    {
                        _subscription.Delete(true);
                    }
                    catch (Exception ex)
                    {
                        _logger.Warning(ex, "Fout bij verwijderen oude subscription.");
                    }
                    _subscription.Dispose();
                    _subscription = null;
                }

                _subscription = new Subscription(_session.DefaultSubscription)
                {
                    DisplayName = $"{_config.ConnectionName} Subscription",
                    PublishingInterval = _config
                        .TagsToMonitor.Where(t => t.IsActive)
                        .Min(t => t.SamplingInterval > 0 ? t.SamplingInterval : 1000),
                    KeepAliveCount = 10,
                    LifetimeCount = 30,
                    MaxNotificationsPerPublish = 0,
                    PublishingEnabled = true,
                    TimestampsToReturn = TimestampsToReturn.Both,
                };

                var itemsToMonitor = new List<MonitoredItem>();
                foreach (var tagConfig in _config.TagsToMonitor.Where(t => t.IsActive))
                {
                    var item = new MonitoredItem(_subscription.DefaultItem)
                    {
                        DisplayName = tagConfig.TagName,
                        StartNodeId = NodeId.Parse(_session.MessageContext, tagConfig.NodeId),
                        AttributeId = Attributes.Value,
                        SamplingInterval =
                            tagConfig.SamplingInterval > 0 ? tagConfig.SamplingInterval : -1,
                        QueueSize = 1,
                        DiscardOldest = true,
                    };
                    item.Notification += OnMonitoredItemNotification;
                    itemsToMonitor.Add(item);
                }

                if (!itemsToMonitor.Any())
                {
                    _logger.Information(
                        "Geen actieve tags om te monitoren voor {ConnectionName}",
                        _config.ConnectionName
                    );
                    _subscription.Dispose();
                    _subscription = null;
                    return;
                }

                _subscription.AddItems(itemsToMonitor);

                _logger.Information(
                    "Probeert subscription aan te maken voor {ItemCount} items op {ConnectionName}",
                    itemsToMonitor.Count,
                    _config.ConnectionName
                );
                _session.AddSubscription(_subscription);
                await _subscription.CreateAsync();
                await _subscription.ApplyChangesAsync();
                _logger.Information(
                    "Subscription succesvol aangemaakt en items worden gemonitord voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij starten van OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
                if (_subscription != null)
                {
                    try
                    {
                        _subscription.Delete(true);
                    }
                    catch
                    { /* ignore */
                    }
                    _subscription.Dispose();
                    _subscription = null;
                }
            }
            finally
            {
                _semaphore.Release();
            }
        }

        private void OnMonitoredItemNotification(
            MonitoredItem monitoredItem,
            MonitoredItemNotificationEventArgs e
        )
        {
            var notification = e.NotificationValue as MonitoredItemNotification;
            if (notification == null || notification.Value == null)
                return;

            var loggedValue = new LoggedTagValue
            {
                TagName = monitoredItem.DisplayName,
                Value = notification.Value.Value,
                Timestamp =
                    notification.Value.SourceTimestamp != DateTime.MinValue
                        ? notification.Value.SourceTimestamp
                        : notification.Value.ServerTimestamp,
                IsGoodQuality = StatusCode.IsGood(notification.Value.StatusCode),
                ErrorMessage = StatusCode.IsBad(notification.Value.StatusCode)
                    ? notification.Value.StatusCode.ToString()
                    : null,
            };

            //_logger.Debug("OPC Data: {TagName}, Value: {Value}, Timestamp: {Timestamp}, Quality: {Quality}",

            TagsDataReceived?.Invoke(this, new List<LoggedTagValue> { loggedValue });
        }

        public async Task StopMonitoringTagsAsync()
        {
            if (_subscription == null)
                return;

            await _semaphore.WaitAsync();
            try
            {
                _logger.Information(
                    "Stopt OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
                _subscription.Delete(true);
                _session.RemoveSubscription(_subscription);
                _subscription.Dispose();
                _subscription = null;
                _logger.Information(
                    "OPC UA tag monitoring gestopt voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij stoppen van OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public async Task<IEnumerable<LoggedTagValue>> ReadCurrentTagValuesAsync()
        {
            if (!IsConnected || _session == null || !_config.TagsToMonitor.Any(t => t.IsActive))
            {
                _logger.Warning(
                    "Kan tags niet lezen: niet verbonden, geen sessie, of geen actieve tags."
                );
                return Enumerable.Empty<LoggedTagValue>();
            }

            var loggedValues = new List<LoggedTagValue>();
            var nodesToRead = new ReadValueIdCollection();
            var tagConfigs = _config.TagsToMonitor.Where(t => t.IsActive).ToList();

            foreach (var tagConfig in tagConfigs)
            {
                try
                {
                    nodesToRead.Add(
                        new ReadValueId
                        {
                            NodeId = NodeId.Parse(_session.MessageContext, tagConfig.NodeId),
                            AttributeId = Attributes.Value,
                        }
                    );
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Ongeldige NodeId {NodeId} voor tag {TagName}",
                        tagConfig.NodeId,
                        tagConfig.TagName
                    );
                    loggedValues.Add(
                        new LoggedTagValue
                        {
                            TagName = tagConfig.TagName,
                            IsGoodQuality = false,
                            ErrorMessage = "Ongeldige NodeId",
                            Timestamp = DateTime.UtcNow,
                        }
                    );
                }
            }

            if (!nodesToRead.Any())
                return loggedValues;

            try
            {
                _logger.Debug("Leest {Count} OPC UA tags.", nodesToRead.Count);
                DataValueCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                _session.Read(
                    null,
                    0,
                    TimestampsToReturn.Source,
                    nodesToRead,
                    out results,
                    out diagnosticInfos
                );

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                for (int i = 0; i < results.Count; i++)
                {
                    var tagConfig = tagConfigs.FirstOrDefault(tc =>
                    {
                        try
                        {
                            return NodeId
                                .Parse(_session.MessageContext, tc.NodeId)
                                .Equals(nodesToRead[i].NodeId);
                        }
                        catch
                        {
                            return false;
                        }
                    });
                    if (tagConfig == null)
                        continue;

                    loggedValues.Add(
                        new LoggedTagValue
                        {
                            TagName = tagConfig.TagName,
                            Value = results[i].Value,
                            Timestamp =
                                results[i].SourceTimestamp != DateTime.MinValue
                                    ? results[i].SourceTimestamp
                                    : results[i].ServerTimestamp,
                            IsGoodQuality = StatusCode.IsGood(results[i].StatusCode),
                            ErrorMessage = StatusCode.IsBad(results[i].StatusCode)
                                ? results[i].StatusCode.ToString()
                                : null,
                        }
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Fout tijdens het lezen van OPC UA tags.");

                foreach (var node in nodesToRead)
                {
                    var tagConfig = tagConfigs.FirstOrDefault(tc =>
                    {
                        try
                        {
                            return NodeId
                                .Parse(_session.MessageContext, tc.NodeId)
                                .Equals(node.NodeId);
                        }
                        catch
                        {
                            return false;
                        }
                    });
                    if (
                        tagConfig != null
                        && !loggedValues.Any(lv => lv.TagName == tagConfig.TagName)
                    )
                    {
                        loggedValues.Add(
                            new LoggedTagValue
                            {
                                TagName = tagConfig.TagName,
                                IsGoodQuality = false,
                                ErrorMessage = ex.Message,
                                Timestamp = DateTime.UtcNow,
                            }
                        );
                    }
                }
            }
            return loggedValues;
        }

        private void Session_KeepAlive(ISession session, KeepAliveEventArgs e)
        {
            if (ServiceResult.IsBad(e.Status))
            {
                _logger.Warning(
                    "OPC UA Sessie KeepAlive mislukt: {Status}. Huidige status: {CurrentState}",
                    e.Status,
                    e.CurrentState
                );
                IsConnected = false;

                return;
            }
            _logger.Debug(
                "OPC UA Sessie KeepAlive ontvangen. Server status: {CurrentState}",
                e.CurrentState
            );
        }

        private bool IsEndpointUrlMatch(string urlFromServerList, string selectedUrl)
        {
            if (string.Equals(urlFromServerList, selectedUrl, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            try
            {
                var uriFromServer = new Uri(urlFromServerList);
                var uriSelected = new Uri(selectedUrl);

                return uriFromServer.Scheme == uriSelected.Scheme
                    && string.Equals(
                        uriFromServer.DnsSafeHost,
                        uriSelected.DnsSafeHost,
                        StringComparison.OrdinalIgnoreCase
                    )
                    && uriFromServer.Port == uriSelected.Port;
            }
            catch (UriFormatException)
            {
                return false;
            }
        }

        public async Task<ReferenceDescriptionCollection> BrowseAsync(
            NodeId nodeIdToBrowse,
            NodeId referenceTypeId = null,
            bool includeSubtypes = true,
            BrowseDirection direction = BrowseDirection.Forward,
            NodeClass nodeClassMask = NodeClass.Unspecified,
            CancellationToken ct = default
        )
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning("Kan niet browsen: geen actieve sessie.");
                return new ReferenceDescriptionCollection();
            }

            try
            {
                _logger.Debug("Browsen vanaf NodeId: {NodeIdString}", nodeIdToBrowse);
                BrowseDescription nodeToBrowseDescription = new BrowseDescription
                {
                    NodeId = nodeIdToBrowse,
                    BrowseDirection = direction,
                    ReferenceTypeId = referenceTypeId ?? ReferenceTypeIds.HierarchicalReferences,
                    IncludeSubtypes = includeSubtypes,
                    NodeClassMask = (uint)nodeClassMask,
                    ResultMask = (uint)BrowseResultMask.All,
                };

                BrowseDescriptionCollection nodesToBrowseCollection =
                    new BrowseDescriptionCollection { nodeToBrowseDescription };

                RequestHeader requestHeader = null;
                ViewDescription viewDescription = null;
                uint maxResultsToReturnPerNode = 0;

                BrowseResponse response = await _session.BrowseAsync(
                    requestHeader,
                    viewDescription,
                    maxResultsToReturnPerNode,
                    nodesToBrowseCollection,
                    ct
                );

                var results = response.Results;
                var diagnosticInfos = response.DiagnosticInfos;

                ClientBase.ValidateResponse(results, nodesToBrowseCollection);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowseCollection);

                if (StatusCode.IsBad(results[0].StatusCode))
                {
                    _logger.Error(
                        "Browse fout voor NodeId {NodeIdString}: {StatusCode}",
                        nodeIdToBrowse,
                        results[0].StatusCode
                    );

                    return new ReferenceDescriptionCollection();
                }

                ReferenceDescriptionCollection references = results[0].References;

                ByteStringCollection continuationPoints = new ByteStringCollection();
                if (results[0].ContinuationPoint != null)
                {
                    continuationPoints.Add(results[0].ContinuationPoint);
                }

                while (continuationPoints.Any() && continuationPoints[0] != null)
                {
                    _logger.Debug(
                        "Browsen met continuation point voor NodeId: {NodeIdString}",
                        nodeIdToBrowse
                    );

                    var browseNextResponse = await _session.BrowseNextAsync(
                        requestHeader,
                        false,
                        continuationPoints,
                        ct
                    );

                    var nextResults = browseNextResponse.Results;
                    var nextDiagnosticInfos = browseNextResponse.DiagnosticInfos;

                    ClientBase.ValidateResponse(nextResults, continuationPoints);
                    ClientBase.ValidateDiagnosticInfos(nextDiagnosticInfos, continuationPoints);

                    if (StatusCode.IsBad(nextResults[0].StatusCode))
                    {
                        _logger.Error(
                            "BrowseNext fout voor NodeId {NodeIdString}: {StatusCode}",
                            nodeIdToBrowse,
                            nextResults[0].StatusCode
                        );
                        break;
                    }
                    references.AddRange(nextResults[0].References);

                    continuationPoints.Clear();
                    if (nextResults[0].ContinuationPoint != null)
                    {
                        continuationPoints.Add(nextResults[0].ContinuationPoint);
                    }
                }

                return references;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Exception tijdens browsen van NodeId: {NodeIdString}",
                    nodeIdToBrowse
                );
                return new ReferenceDescriptionCollection();
            }
        }

        public async Task<ReferenceDescriptionCollection> BrowseRootAsync()
        {
            return await BrowseAsync(ObjectIds.ObjectsFolder);
        }

        public async Task<DataValue> ReadValueAsync(NodeId nodeId)
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning(
                    "Kan waarde niet lezen voor {NodeId}: geen actieve sessie.",
                    nodeId
                );
                return new DataValue(StatusCodes.BadNotConnected);
            }

            ReadValueId nodeToRead = new ReadValueId
            {
                NodeId = nodeId,
                AttributeId = Attributes.Value,
            };
            ReadValueIdCollection nodesToRead = new ReadValueIdCollection { nodeToRead };

            DataValueCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            try
            {
                var response = await _session.ReadAsync(
                    null,
                    0,
                    TimestampsToReturn.Source,
                    nodesToRead,
                    CancellationToken.None
                );

                results = response.Results;
                diagnosticInfos = response.DiagnosticInfos;

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                if (results != null && results.Count > 0)
                {
                    return results[0];
                }
                else
                {
                    _logger.Warning("Geen resultaat ontvangen bij het lezen van {NodeId}", nodeId);
                    return new DataValue(StatusCodes.BadNoDataAvailable);
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens het lezen van waarde voor NodeId: {NodeId}",
                    nodeId
                );
                return null;
            }
        }

        public void Dispose()
        {
            _semaphore.Wait();
            try
            {
                if (IsConnected)
                {
                    Task.Run(async () => await DisconnectAsync()).Wait(5000);
                }
                _subscription?.Dispose();
                _session?.Dispose();
                _semaphore?.Dispose();
            }
            finally
            {
                //_semaphore.Release();
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\SettingsService.cs"
using System;
using System.IO;
using System.Reflection;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class SettingsService : ISettingsService
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private const string SettingsFileName = "DataLoggerSettings.json";
        private string _settingsFilePath;

        private AppSettings _currentSettings;
        public AppSettings CurrentSettings
        {
            get => _currentSettings;
            private set => _currentSettings = value;
        }

        public SettingsService(ILogger logger, IStatusService statusService)
        {
            _logger = logger;
            _statusService = statusService;

            string executableLocation = Path.GetDirectoryName(
                Assembly.GetExecutingAssembly().Location
            );
            _settingsFilePath = Path.Combine(executableLocation, SettingsFileName);
            _logger.Information(
                "Pad naar instellingenbestand: {SettingsFilePath}",
                _settingsFilePath
            );

            LoadSettings();
        }

        public void LoadSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Loading, "Instellingen laden...");
            try
            {
                if (File.Exists(_settingsFilePath))
                {
                    _logger.Information("Instellingenbestand gevonden. Bezig met laden...");
                    string json = File.ReadAllText(_settingsFilePath);

                    var serializerSettings = new JsonSerializerSettings
                    {
                        TypeNameHandling = TypeNameHandling.Objects,
                        Formatting = Formatting.Indented,
                    };

                    _currentSettings = JsonConvert.DeserializeObject<AppSettings>(
                        json,
                        serializerSettings
                    );
                    _logger.Information("Instellingen succesvol geladen.");
                }
                else
                {
                    _logger.Warning(
                        "Instellingenbestand niet gevonden op {SettingsFilePath}. Standaardinstellingen worden geladen.",
                        _settingsFilePath
                    );
                    LoadDefaultSettings();
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van instellingen. Standaardinstellingen worden geladen."
                );
                LoadDefaultSettings();
            }
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen verwerkt.");
        }

        public void SaveSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Saving, "Instellingen opslaan...");
            try
            {
                var serializerSettings = new JsonSerializerSettings
                {
                    TypeNameHandling = TypeNameHandling.Objects,
                    Formatting = Formatting.Indented,
                };

                string json = JsonConvert.SerializeObject(CurrentSettings, serializerSettings);
                File.WriteAllText(_settingsFilePath, json);
                _logger.Information(
                    "Instellingen succesvol opgeslagen in {SettingsFilePath}",
                    _settingsFilePath
                );
                _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het opslaan van instellingen naar {SettingsFilePath}",
                    _settingsFilePath
                );
                _statusService.SetStatus(
                    Enums.ApplicationStatus.Error,
                    "Fout bij opslaan instellingen."
                );
            }
        }

        public void LoadDefaultSettings()
        {
            _logger.Information("Standaardinstellingen worden geconfigureerd.");
            _currentSettings = new AppSettings();
            _currentSettings.Connections.Add(
                new ModbusTcpConnectionConfig
                {
                    ConnectionName = "Voorbeeld Modbus Device",
                    IpAddress = "192.168.1.100",
                    Port = 502,
                    IsEnabled = false,
                    ScanIntervalSeconds = 5,
                }
            );
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\StatusService.cs"
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class StatusService : ObservableObject, IStatusService
    {
        private readonly ILogger _logger;
        private ApplicationStatus _currentStatus;
        private string _statusMessage;

        public ApplicationStatus CurrentStatus
        {
            get => _currentStatus;
            private set => SetProperty(ref _currentStatus, value);
        }

        public string StatusMessage
        {
            get => _statusMessage;
            private set => SetProperty(ref _statusMessage, value);
        }

        public StatusService(ILogger logger)
        {
            _logger = logger;

            SetStatus(ApplicationStatus.Idle, "Applicatie gereed.");
        }

        public void SetStatus(ApplicationStatus status, string message)
        {
            CurrentStatus = status;
            StatusMessage = message;
            _logger.Information(
                "Applicatiestatus gewijzigd naar: {Status} - Bericht: {Message}",
                status,
                message
            );
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\LogViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;
using Serilog.Events;

namespace Data_Logger.ViewModels
{
    public class LogViewModel : ObservableObject
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly ILogger _logger;

        private string _filterText;
        private LogEventLevel? _selectedLogLevelFilter;

        public ObservableCollection<UiLogEntry> LogEntries => _loggingHostService.LogEntries;
        public ICollectionView FilteredLogEntries { get; }

        public string FilterText
        {
            get => _filterText;
            set
            {
                if (SetProperty(ref _filterText, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ObservableCollection<LogEventLevel?> LogLevels { get; } =
            new ObservableCollection<LogEventLevel?>(
                new LogEventLevel?[] { null }.Concat(
                    Enum.GetValues(typeof(LogEventLevel)).Cast<LogEventLevel?>()
                )
            );

        public LogEventLevel? SelectedLogLevelFilter
        {
            get => _selectedLogLevelFilter;
            set
            {
                if (SetProperty(ref _selectedLogLevelFilter, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ICommand ClearLogsCommand { get; }

        public LogViewModel(ILoggingHostService loggingHostService, ILogger logger)
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _logger =
                logger?.ForContext<LogViewModel>()
                ?? throw new ArgumentNullException(nameof(logger));

            FilteredLogEntries = CollectionViewSource.GetDefaultView(LogEntries);
            FilteredLogEntries.Filter = ApplyFilter;

            ClearLogsCommand = new RelayCommand(
                _ => _loggingHostService.ClearLogs(),
                _ => LogEntries.Any()
            );

            LogEntries.CollectionChanged += (sender, e) =>
            {
                ((RelayCommand)ClearLogsCommand).RaiseCanExecuteChanged();
            };
        }

        private bool ApplyFilter(object item)
        {
            if (item is UiLogEntry entry)
            {
                bool logLevelMatch =
                    !_selectedLogLevelFilter.HasValue
                    || entry.Level == _selectedLogLevelFilter.Value;
                bool textMatch =
                    string.IsNullOrWhiteSpace(_filterText)
                    || entry.RenderedMessage.IndexOf(
                        _filterText,
                        StringComparison.OrdinalIgnoreCase
                    ) >= 0
                    || (
                        entry.Exception != null
                        && entry.Exception.IndexOf(_filterText, StringComparison.OrdinalIgnoreCase)
                            >= 0
                    );
                return logLevelMatch && textMatch;
            }
            return false;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\MainViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.Views;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private readonly ISettingsService _settingsService;
        private readonly Func<Action, SettingsViewModel> _settingsViewModelFactory;

        private readonly Func<ModbusTcpConnectionConfig, IModbusService> _modbusServiceFactory;
        private readonly Func<OpcUaConnectionConfig, IOpcUaService> _opcUaServiceFactory;

        private readonly IDataLoggingService _dataLoggingService;

        private string _applicationTitle = "Data Logger Applicatie";
        public string ApplicationTitle
        {
            get => _applicationTitle;
            set => SetProperty(ref _applicationTitle, value);
        }

        public LogViewModel LogVm { get; }
        public ApplicationStatus CurrentApplicationStatus => _statusService.CurrentStatus;
        public string CurrentStatusMessage => _statusService.StatusMessage;

        public ObservableCollection<TabViewModelBase> ActiveTabs { get; } =
            new ObservableCollection<TabViewModelBase>();

        private TabViewModelBase _selectedTab;
        public TabViewModelBase SelectedTab
        {
            get => _selectedTab;
            set => SetProperty(ref _selectedTab, value);
        }

        public ICommand OpenSettingsCommand { get; }

        public MainViewModel(
            ILogger logger,
            LogViewModel logViewModel,
            IStatusService statusService,
            ISettingsService settingsService,
            Func<Action, SettingsViewModel> settingsViewModelFactory,
            Func<ModbusTcpConnectionConfig, IModbusService> modbusServiceFactory,
            Func<OpcUaConnectionConfig, IOpcUaService> opcUaServiceFactory,
            IDataLoggingService dataLoggingService
        )
        {
            _logger = logger;
            LogVm = logViewModel;
            _statusService = statusService;
            _settingsService = settingsService;
            _settingsViewModelFactory = settingsViewModelFactory;

            _modbusServiceFactory = modbusServiceFactory;
            _opcUaServiceFactory = opcUaServiceFactory;

            _dataLoggingService = dataLoggingService;

            if (_statusService is INotifyPropertyChanged notifier)
            {
                notifier.PropertyChanged += StatusService_PropertyChanged;
            }

            OpenSettingsCommand = new RelayCommand(_ => OpenSettingsWindow());

            _logger.Information("MainViewModel geïnitialiseerd.");
            _statusService.SetStatus(ApplicationStatus.Idle, "Applicatie succesvol geladen.");

            LoadTabsFromSettings();
        }

        private void OpenSettingsWindow()
        {
            _logger.Information("Instellingenvenster wordt geopend...");
            _statusService.SetStatus(ApplicationStatus.Idle, "Instellingen openen...");

            var settingsView = new Views.SettingsView();
            Action closeAction = () => settingsView.Close();
            var settingsVm = _settingsViewModelFactory(closeAction);
            settingsView.DataContext = settingsVm;

            if (
                Application.Current.MainWindow != null
                && Application.Current.MainWindow != settingsView
            )
            {
                settingsView.Owner = Application.Current.MainWindow;
            }

            settingsView.ShowDialog();

            _logger.Information("Instellingenvenster gesloten.");

            UpdateTabsAfterSettingsChange();

            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar.");
        }

        private void UpdateTabsAfterSettingsChange()
        {
            _logger.Information("Tabs bijwerken na mogelijke instellingwijzigingen...");
            var newEnabledConfigs = _settingsService
                .CurrentSettings.Connections.Where(c => c.IsEnabled)
                .ToDictionary(c => c.ConnectionName);

            var currentActiveTabVMs = ActiveTabs.ToList();

            foreach (var tabVm in currentActiveTabVMs)
            {
                if (
                    !newEnabledConfigs.TryGetValue(
                        tabVm.ConnectionConfiguration.ConnectionName,
                        out var newConfigData
                    ) || !newConfigData.IsEnabled
                )
                {
                    _logger.Information(
                        "Tab verwijderen voor: {ConnectionName}",
                        tabVm.ConnectionConfiguration.ConnectionName
                    );
                    if (tabVm is IDisposable disposable)
                        disposable.Dispose();
                    ActiveTabs.Remove(tabVm);
                }
            }

            foreach (var newConfigPair in newEnabledConfigs)
            {
                var newConfig = newConfigPair.Value;
                var existingTabVm = ActiveTabs.FirstOrDefault(t =>
                    t.ConnectionConfiguration.ConnectionName == newConfig.ConnectionName
                );

                if (existingTabVm != null)
                {
                    bool requiresRestart = false;
                    if (
                        newConfig is ModbusTcpConnectionConfig newModbusConf
                        && existingTabVm.ConnectionConfiguration
                            is ModbusTcpConnectionConfig oldModbusConf
                    )
                    {
                        if (
                            newModbusConf.IpAddress != oldModbusConf.IpAddress
                            || newModbusConf.Port != oldModbusConf.Port
                            || newModbusConf.UnitId != oldModbusConf.UnitId
                        )
                        {
                            requiresRestart = true;
                        }
                    }
                    else if (
                        newConfig is OpcUaConnectionConfig newOpcUaConf
                        && existingTabVm.ConnectionConfiguration
                            is OpcUaConnectionConfig oldOpcUaConf
                    )
                    {
                        if (
                            newOpcUaConf.EndpointUrl != oldOpcUaConf.EndpointUrl
                            || newOpcUaConf.SecurityMode != oldOpcUaConf.SecurityMode
                            || newOpcUaConf.SecurityPolicyUri != oldOpcUaConf.SecurityPolicyUri
                            || newOpcUaConf.UserName != oldOpcUaConf.UserName /* || Wachtwoord gewijzigd? */
                        )
                        {
                            requiresRestart = true;
                        }
                    }

                    if (requiresRestart)
                    {
                        _logger.Information(
                            "Kernparameters gewijzigd voor {ConnectionName}. Tab wordt herstart.",
                            newConfig.ConnectionName
                        );
                        if (existingTabVm is IDisposable disposable)
                            disposable.Dispose();
                        ActiveTabs.Remove(existingTabVm);
                        CreateAndAddTab(newConfig);
                    }
                    else
                    {
                        _logger.Information(
                            "Instellingen 'warm' toepassen op bestaande tab: {ConnectionName}",
                            newConfig.ConnectionName
                        );
                        if (
                            existingTabVm is ModbusTabViewModel modbusTabVm
                            && newConfig is ModbusTcpConnectionConfig mc
                        )
                        {
                            modbusTabVm.UpdateConfiguration(mc);
                        }
                        else if (
                            existingTabVm is OpcUaTabViewModel opcUaTabVm
                            && newConfig is OpcUaConnectionConfig oc
                        )
                        {
                            opcUaTabVm.UpdateConfiguration(oc);
                        }
                    }
                }
                else
                {
                    _logger.Information(
                        "Nieuwe actieve verbinding gevonden, tab aanmaken voor: {ConnectionName}",
                        newConfig.ConnectionName
                    );
                    CreateAndAddTab(newConfig);
                }
            }

            if (ActiveTabs.Any() && SelectedTab == null)
                SelectedTab = ActiveTabs.First();
            else if (!ActiveTabs.Any())
                SelectedTab = null;
            else if (SelectedTab != null && !ActiveTabs.Contains(SelectedTab))
                SelectedTab = ActiveTabs.FirstOrDefault();
        }

        private void CreateAndAddTab(ConnectionConfigBase config)
        {
            TabViewModelBase tabVm = null;
            if (config is ModbusTcpConnectionConfig modbusConfig)
            {
                if (_modbusServiceFactory != null && _dataLoggingService != null)
                {
                    var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                    tabVm = new ModbusTabViewModel(
                        modbusConfig,
                        _logger,
                        modbusServiceInstance,
                        _statusService,
                        _dataLoggingService
                    );
                }
                else
                {
                    _logger.Error(
                        "Modbus service factory of data logging service niet geïnjecteerd. Kan ModbusTabViewModel niet aanmaken."
                    );
                }
            }
            else if (config is OpcUaConnectionConfig opcUaConfig)
            {
                if (_opcUaServiceFactory != null && _dataLoggingService != null)
                {
                    var opcUaServiceInstance = _opcUaServiceFactory(opcUaConfig);
                    tabVm = new OpcUaTabViewModel(
                        opcUaConfig,
                        _logger,
                        opcUaServiceInstance,
                        _statusService,
                        _dataLoggingService
                    );
                }
                else
                {
                    _logger.Error(
                        "OPC UA service factory of data logging service niet geïnjecteerd. Kan OpcUaTabViewModel niet aanmaken."
                    );
                }
            }

            if (tabVm != null)
            {
                ActiveTabs.Add(tabVm);
                _logger.Information(
                    "Tab aangemaakt en toegevoegd voor {ConnectionName} ({ConnectionType})",
                    config.ConnectionName,
                    config.Type
                );
            }
        }

        private void LoadTabsFromSettings()
        {
            _logger.Information("Tabs laden op basis van huidige instellingen...");
            var currentSelectedTabName = SelectedTab?.ConnectionConfiguration?.ConnectionName;
            var currentTabs = ActiveTabs.ToList();

            foreach (var tab in currentTabs)
            {
                if (tab is IDisposable disposable)
                {
                    disposable.Dispose();
                }
                ActiveTabs.Remove(tab);
            }

            if (_settingsService.CurrentSettings?.Connections == null)
            {
                _logger.Warning(
                    "Geen verbindingen gevonden in de instellingen om tabs voor te laden."
                );
                SelectedTab = null;
                return;
            }

            foreach (var config in _settingsService.CurrentSettings.Connections)
            {
                if (config.IsEnabled)
                {
                    TabViewModelBase tabVm = null;
                    switch (config.Type)
                    {
                        case ConnectionType.ModbusTcp:
                            if (
                                config is ModbusTcpConnectionConfig modbusConfig
                                && _modbusServiceFactory != null
                            )
                            {
                                var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                                tabVm = new ModbusTabViewModel(
                                    modbusConfig,
                                    _logger,
                                    modbusServiceInstance,
                                    _statusService,
                                    _dataLoggingService
                                );
                                _logger.Debug(
                                    "Modbus TCP Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    modbusConfig.ConnectionName
                                );
                            }
                            else if (_modbusServiceFactory == null)
                            {
                                _logger.Error(
                                    "_modbusServiceFactory is niet geïnjecteerd in MainViewModel."
                                );
                            }
                            break;
                        case ConnectionType.OpcUa:
                            if (
                                config is OpcUaConnectionConfig opcUaConfig
                                && _opcUaServiceFactory != null
                            )
                            {
                                var opcUaServiceInstance = _opcUaServiceFactory(opcUaConfig);
                                tabVm = new OpcUaTabViewModel(
                                    opcUaConfig,
                                    _logger,
                                    opcUaServiceInstance,
                                    _statusService,
                                    _dataLoggingService
                                );
                                _logger.Debug(
                                    "OPC UA Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    opcUaConfig.ConnectionName
                                );
                            }
                            else if (_opcUaServiceFactory == null)
                            {
                                _logger.Error(
                                    "_opcUaServiceFactory is niet geïnjecteerd in MainViewModel."
                                );
                            }
                            break;
                        default:
                            _logger.Warning(
                                "Onbekend verbindingstype '{Type}' overgeslagen voor tab: {ConnectionName}",
                                config.Type,
                                config.ConnectionName
                            );
                            break;
                    }

                    if (tabVm != null)
                    {
                        ActiveTabs.Add(tabVm);
                    }
                }
                else
                {
                    _logger.Debug(
                        "Verbinding '{ConnectionName}' is uitgeschakeld en wordt niet als tab geladen.",
                        config.ConnectionName
                    );
                }
            }

            if (!string.IsNullOrEmpty(currentSelectedTabName))
            {
                SelectedTab = ActiveTabs.FirstOrDefault(t =>
                    t.ConnectionConfiguration.ConnectionName == currentSelectedTabName
                );
            }

            if (SelectedTab == null && ActiveTabs.Any())
            {
                SelectedTab = ActiveTabs.First();
            }
            else if (!ActiveTabs.Any())
            {
                SelectedTab = null;
            }
            _logger.Information("{Count} actieve tabs geladen.", ActiveTabs.Count);
        }

        private void StatusService_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(IStatusService.CurrentStatus))
            {
                OnPropertyChanged(nameof(CurrentApplicationStatus));
            }
            else if (e.PropertyName == nameof(IStatusService.StatusMessage))
            {
                OnPropertyChanged(nameof(CurrentStatusMessage));
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ModbusTabViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using LiveChartsCore;
using LiveChartsCore.Defaults;
using LiveChartsCore.SkiaSharpView;
using LiveChartsCore.SkiaSharpView.Painting;
using Serilog;
using SkiaSharp;

namespace Data_Logger.ViewModels
{
    public class ModbusTabViewModel : TabViewModelBase, IDisposable
    {
        private readonly ILogger _logger;
        private readonly IModbusService _modbusService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;
        private DispatcherTimer _scanTimer;

        public ModbusTcpConnectionConfig ModbusConfig =>
            ConnectionConfiguration as ModbusTcpConnectionConfig;

        public bool IsConnected => _modbusService?.IsConnected ?? false;

        public ObservableCollection<LoggedTagValue> DataValues { get; } =
            new ObservableCollection<LoggedTagValue>();

        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }

        private readonly ObservableCollection<ObservablePoint> _plotDataPoints;
        public ObservableCollection<ISeries> Series { get; set; }
        public Axis[] XAxes { get; set; }
        public Axis[] YAxes { get; set; }

        public ObservableCollection<string> AvailableTagNamesForPlotting { get; } =
            new ObservableCollection<string>();
        private string _selectedTagNameForPlotting;
        public string SelectedTagNameForPlotting
        {
            get => _selectedTagNameForPlotting;
            set
            {
                _logger.Debug("Probeer SelectedTagNameForPlotting te zetten. Oud: '{OldValue}', Nieuw: '{NewValue}'", _selectedTagNameForPlotting, value);
                if (SetProperty(ref _selectedTagNameForPlotting, value))
                {
                    _logger.Information("SelectedTagNameForPlotting GEWIJZIGD naar: {SelectedTag}. Aanroepen UpdatePlotSeriesNameAndYAxis en LoadHistoricalDataForPlot.", _selectedTagNameForPlotting);
                    UpdatePlotSeriesNameAndYAxis();
                    LoadHistoricalDataForPlot();
                }
                else
                {
                    _logger.Debug("SelectedTagNameForPlotting NIET gewijzigd (zelfde waarde).");
                }
            }
        }

        private const int MaxPlotBufferSize = 500;

        public ModbusTabViewModel(
            ModbusTcpConnectionConfig config,
            ILogger logger,
            IModbusService modbusService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService
        )
            : base(config)
        {
            _logger = logger
                .ForContext<ModbusTabViewModel>()
                .ForContext("ConnectionName", config.ConnectionName);
            _modbusService =
                modbusService ?? throw new ArgumentNullException(nameof(modbusService));
            _statusService =
                statusService ?? throw new ArgumentNullException(nameof(statusService));
            _dataLoggingService =
                dataLoggingService ?? throw new ArgumentNullException(nameof(dataLoggingService));

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(
                async _ => await DisconnectAsync(),
                _ => IsConnected
            );

            _modbusService.ConnectionStatusChanged += OnModbusConnectionStatusChanged;
            _modbusService.TagsDataReceived += OnModbusTagsDataReceived;

            _plotDataPoints = new ObservableCollection<ObservablePoint>();
            Series = new ObservableCollection<ISeries>
            {
                new LineSeries<ObservablePoint>
                {
                    Values = _plotDataPoints,
                    Name = "Waarde",
                    Fill = null,
                    GeometrySize = 5,
                    LineSmoothness = 0,
                    Stroke = new SolidColorPaint(SKColors.DodgerBlue) { StrokeThickness = 2 },
                    GeometryStroke = new SolidColorPaint(SKColors.DodgerBlue)
                    {
                        StrokeThickness = 2,
                    },
                },
            };

            XAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Tijdstempel",
                    Labeler = value => new DateTime((long)value).ToString("HH:mm:ss"),
                    UnitWidth = TimeSpan.TicksPerSecond,
                    MinStep = TimeSpan.TicksPerSecond * 1,
                    TextSize = 10,
                    NameTextSize = 12,
                },
            };

            YAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Waarde",
                    TextSize = 10,
                    NameTextSize = 12,
                },
            };

            PopulateAvailableTagNames();
            InitializeScanTimer();
        }

        private void PopulateAvailableTagNames()
        {
            AvailableTagNamesForPlotting.Clear();
            if (ModbusConfig?.TagsToMonitor != null)
            {
                foreach (
                    var tag in ModbusConfig.TagsToMonitor.Where(t =>
                        t.IsActive && IsDataTypePlottable(t.DataType)
                    )
                )
                {
                    AvailableTagNamesForPlotting.Add(tag.TagName);
                }
            }

            SelectedTagNameForPlotting = AvailableTagNamesForPlotting.FirstOrDefault();
        }

        private void UpdatePlotSeriesNameAndYAxis()
        {
            string seriesName = string.IsNullOrEmpty(_selectedTagNameForPlotting)
                ? "Waarde"
                : _selectedTagNameForPlotting;
            string yAxisName = string.IsNullOrEmpty(_selectedTagNameForPlotting)
                ? "Waarde"
                : $"Waarde ({_selectedTagNameForPlotting})";

            if (Series.Any() && Series[0] is LineSeries<ObservablePoint> lineSeries)
            {
                lineSeries.Name = seriesName;
            }
            if (YAxes.Any())
            {
                YAxes[0].Name = yAxisName;
            }

            OnPropertyChanged(nameof(Series));
            OnPropertyChanged(nameof(YAxes));
        }

        private bool IsDataTypePlottable(ModbusDataType dataType)
        {
            switch (dataType)
            {
                case ModbusDataType.Int16:
                case ModbusDataType.UInt16:
                case ModbusDataType.Int32:
                case ModbusDataType.UInt32:
                case ModbusDataType.Float32:
                    return true;
                case ModbusDataType.Boolean:
                default:
                    return false;
            }
        }

        private void LoadHistoricalDataForPlot()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        _plotDataPoints.Clear();
                        if (string.IsNullOrEmpty(SelectedTagNameForPlotting))
                            return;

                        var relevantValues = DataValues
                            .Where(dv =>
                                dv.TagName == SelectedTagNameForPlotting && dv.IsGoodQuality
                            )
                            .OrderBy(dv => dv.Timestamp)
                            .ToList();

                        int count = relevantValues.Count;
                        int itemsToSkip = Math.Max(0, count - MaxPlotBufferSize);

                        var historicalValues = relevantValues.Skip(itemsToSkip);

                        foreach (var loggedValue in historicalValues)
                        {
                            if (TryConvertToDouble(loggedValue.Value, out double numericValue))
                            {
                                _plotDataPoints.Add(
                                    new ObservablePoint(loggedValue.Timestamp.Ticks, numericValue)
                                );
                            }
                        }
                    }
                )
            );
        }

        private void OnModbusTagsDataReceived(
            object sender,
            IEnumerable<LoggedTagValue> receivedTagValues
        )
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            if (!tagValuesList.Any())
                return;

            _logger.Debug(
                "OnModbusTagsDataReceived: {Count} tag(s) ontvangen voor {ConnectionName}",
                tagValuesList.Count,
                DisplayName
            );

            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                bool plotNeedsUpdate = false;
                foreach (var newTagValue in tagValuesList)
                {
                    var existingTag = DataValues.FirstOrDefault(t =>
                        t.TagName == newTagValue.TagName
                    );
                    if (existingTag != null)
                    {
                        existingTag.Value = newTagValue.Value;
                        existingTag.Timestamp = newTagValue.Timestamp;
                        existingTag.IsGoodQuality = newTagValue.IsGoodQuality;
                        existingTag.ErrorMessage = newTagValue.ErrorMessage;
                    }
                    else
                    {
                        DataValues.Add(newTagValue);
                    }

                    if (
                        newTagValue.TagName == SelectedTagNameForPlotting
                        && newTagValue.IsGoodQuality
                    )
                    {
                        if (TryConvertToDouble(newTagValue.Value, out double numericValue))
                        {
                            _plotDataPoints.Add(
                                new ObservablePoint(newTagValue.Timestamp.Ticks, numericValue)
                            );
                            plotNeedsUpdate = true;
                        }
                    }
                }

                if (plotNeedsUpdate)
                {
                    while (_plotDataPoints.Count > MaxPlotBufferSize)
                    {
                        _plotDataPoints.RemoveAt(0);
                    }
                }
            });
            _dataLoggingService.LogTagValues(ModbusConfig.ConnectionName, tagValuesList);
        }

        private bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null)
                return false;
            try
            {
                result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
                return true;
            }
            catch (FormatException)
            {
                return false;
            }
            catch (InvalidCastException)
            {
                return false;
            }
            catch (OverflowException)
            {
                return false;
            }
        }

        public void UpdateConfiguration(ModbusTcpConnectionConfig newConfig)
        {
            var currentSpecificConfig = this.ModbusConfig;
            if (currentSpecificConfig == null)
            {
                _logger.Error(
                    "UpdateConfig: Huidige ModbusConfig is null voor {DisplayName}",
                    DisplayName
                );
                return;
            }
            if (newConfig == null)
            {
                _logger.Error(
                    "UpdateConfig: Nieuwe config is null voor {DisplayName}",
                    DisplayName
                );
                return;
            }

            _logger.Information(
                "Warme configuratie update voor Modbus {ConnectionName}",
                newConfig.ConnectionName
            );

            bool tagsOrIntervalChanged =
                currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds
                || !TagsSequentiallyEqual(
                    currentSpecificConfig.TagsToMonitor,
                    newConfig.TagsToMonitor
                );

            if (
                _scanTimer != null
                && currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds
            )
            {
                _logger.Information(
                    "Scan interval voor {DisplayName} gewijzigd van {OldInterval}s naar {NewInterval}s.",
                    DisplayName,
                    currentSpecificConfig.ScanIntervalSeconds,
                    newConfig.ScanIntervalSeconds
                );
                bool restartTimer = _scanTimer.IsEnabled;
                _scanTimer.Stop();
                _scanTimer.Interval = TimeSpan.FromSeconds(
                    newConfig.ScanIntervalSeconds > 0 ? newConfig.ScanIntervalSeconds : 5
                );
                if (restartTimer && IsConnected)
                {
                    _scanTimer.Start();
                }
            }

            ConnectionConfiguration = newConfig;
            OnPropertyChanged(nameof(ModbusConfig));
            _modbusService.Reconfigure(newConfig);
            if (DisplayName != newConfig.ConnectionName)
                DisplayName = newConfig.ConnectionName;

            if (tagsOrIntervalChanged || DisplayName != newConfig.ConnectionName)
            {
                _logger.Debug(
                    "Configuratie gewijzigd voor {DisplayName}, herpopuleren plot tags.",
                    DisplayName
                );
                PopulateAvailableTagNames();
                UpdatePlotSeriesNameAndYAxis();
            }
        }

        private bool TagsSequentiallyEqual(
            ObservableCollection<ModbusTagConfig> list1,
            ObservableCollection<ModbusTagConfig> list2
        )
        {
            if (ReferenceEquals(list1, list2))
                return true;
            if (list1 == null || list2 == null)
                return false;
            if (list1.Count != list2.Count)
                return false;

            for (int i = 0; i < list1.Count; i++)
            {
                if (
                    list1[i].TagName != list2[i].TagName
                    || list1[i].Address != list2[i].Address
                    || list1[i].DataType != list2[i].DataType
                    || list1[i].RegisterType != list2[i].RegisterType
                    || list1[i].IsActive != list2[i].IsActive
                )
                    return false;
            }
            return true;
        }

        private void InitializeScanTimer()
        {
            _scanTimer = new DispatcherTimer();
            _scanTimer.Interval = TimeSpan.FromSeconds(
                ModbusConfig?.ScanIntervalSeconds > 0 ? ModbusConfig.ScanIntervalSeconds : 5
            );
            _scanTimer.Tick += async (s, e) => await ScanTimer_TickAsync();
        }

        private async Task ScanTimer_TickAsync()
        {
            if (IsConnected)
            {
                await ReadConfiguredTagsAsync();
            }
        }

        private async Task ConnectAsync()
        {
            _statusService.SetStatus(
                ApplicationStatus.Connecting,
                $"Verbinden met Modbus: {ModbusConfig?.ConnectionName}..."
            );
            _logger.Information("Verbindingspoging gestart voor {ConnectionName}...", DisplayName);
            bool success = await _modbusService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(
                    ApplicationStatus.Logging,
                    $"Verbonden met Modbus: {ModbusConfig?.ConnectionName}."
                );
                _logger.Information("Verbinding succesvol voor {ConnectionName}.", DisplayName);
                System.Windows.Application.Current.Dispatcher.Invoke(() => _plotDataPoints.Clear());
                UpdatePlotSeriesNameAndYAxis();
                _scanTimer.Start();
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Kon niet verbinden met Modbus: {ModbusConfig?.ConnectionName}."
                );
                _logger.Warning("Verbinding mislukt voor {ConnectionName}.", DisplayName);
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _scanTimer.Stop();
            _logger.Information("Verbinding verbreken voor {ConnectionName}...", DisplayName);
            await _modbusService.DisconnectAsync();
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"Modbus verbinding verbroken: {ModbusConfig?.ConnectionName}."
            );
            _logger.Information("Verbinding verbroken voor {ConnectionName}.", DisplayName);
            UpdateCommandStates();
            ClearDataAndPlot();
        }

        private async Task ReadConfiguredTagsAsync()
        {
            if (!IsConnected)
                return;
            _logger.Debug(
                "Bezig met pollen van geconfigureerde Modbus tags voor {ConnectionName}",
                ModbusConfig?.ConnectionName
            );
            await _modbusService.PollConfiguredTagsAsync();
        }

        private void OnModbusConnectionStatusChanged(object sender, EventArgs e)
        {
            _logger.Debug(
                "ModbusConnectionStatusChanged event ontvangen. IsConnected: {IsConnected} voor {ConnectionName}",
                _modbusService.IsConnected,
                DisplayName
            );
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();
            if (!_modbusService.IsConnected)
            {
                _scanTimer.Stop();
                ClearDataAndPlot();
            }
            else
            {
                if (!_scanTimer.IsEnabled)
                {
                    System.Windows.Application.Current.Dispatcher.Invoke(() =>
                        _plotDataPoints.Clear()
                    );
                    _scanTimer.Start();
                }
            }
        }

        private void ClearDataAndPlot()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                DataValues.Clear();
                _plotDataPoints.Clear();
            });
        }

        private void UpdateCommandStates()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
                ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
            });
        }

        public void Dispose()
        {
            _logger.Debug(
                "Dispose aangeroepen voor ModbusTabViewModel: {ConnectionName}",
                DisplayName
            );
            _scanTimer?.Stop();
            if (_modbusService != null)
            {
                _modbusService.ConnectionStatusChanged -= OnModbusConnectionStatusChanged;
                _modbusService.TagsDataReceived -= OnModbusTagsDataReceived;
                _modbusService.Dispose();
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaNodeViewModel.cs"
// Data_Logger/ViewModels/OpcUaNodeViewModel.cs

using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using Data_Logger.Core;
using Data_Logger.Services.Abstractions; // Voor IOpcUaService
using Opc.Ua; // Voor NodeId, NodeClass, etc.

namespace Data_Logger.ViewModels
{
    public class OpcUaNodeViewModel : ObservableObject
    {
        private readonly NodeId _nodeId;
        private readonly IOpcUaService _opcUaService; // Om children te kunnen laden
        private readonly Serilog.ILogger _logger;

        private string _displayName;
        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        private NodeClass _nodeClass;
        public NodeClass NodeClass
        {
            get => _nodeClass;
            set => SetProperty(ref _nodeClass, value);
        }

        public NodeId NodeId => _nodeId;

        private bool _isExpanded;
        public bool IsExpanded
        {
            get => _isExpanded;
            set
            {
                if (SetProperty(ref _isExpanded, value))
                {
                    if (_isExpanded && !_childrenLoaded && Children.Any(c => c == null)) // Alleen laden als het een dummy child is
                    {
                        LoadChildren();
                    }
                }
            }
        }

        public ObservableCollection<OpcUaNodeViewModel> Children { get; }

        private bool _childrenLoaded = false;

        // Constructor voor een root node of een node waarvan de details al bekend zijn
        public OpcUaNodeViewModel(
            NodeId nodeId,
            string displayName,
            NodeClass nodeClass,
            IOpcUaService opcUaService,
            Serilog.ILogger logger,
            bool hasChildren
        )
        {
            _nodeId = nodeId;
            DisplayName = displayName;
            NodeClass = nodeClass;
            _opcUaService = opcUaService;
            _logger = logger;
            Children = new ObservableCollection<OpcUaNodeViewModel>();
            if (hasChildren)
            {
                Children.Add(null); // Dummy child om de expander te tonen
            }
        }

        private async void LoadChildren()
        {
            _childrenLoaded = true;
            Children.Clear(); // Verwijder dummy child

            _logger.Debug(
                "Laden van children voor OPC UA Node: {NodeIdString} - {DisplayName}",
                _nodeId.ToString(),
                DisplayName
            );

            if (_opcUaService == null || !_opcUaService.IsConnected)
            {
                _logger.Warning("Kan children niet laden: OpcUaService is null of niet verbonden.");
                // Optioneel: voeg een indicatie toe in de UI dat laden mislukt is
                return;
            }

            try
            {
                // De BrowseAsync methode in IOpcUaService retourneert ReferenceDescriptionCollection
                ReferenceDescriptionCollection childReferences = await _opcUaService.BrowseAsync(
                    _nodeId,
                    ct: CancellationToken.None
                );

                if (childReferences != null)
                {
                    foreach (var childData in childReferences) // childData is hier een ReferenceDescription
                    {
                        bool hasGrandChildren =
                            childData.NodeClass == Opc.Ua.NodeClass.Object
                            || childData.NodeClass == Opc.Ua.NodeClass.View;

                        // Converteer ExpandedNodeId naar NodeId met NamespaceUris van de service
                        NodeId actualNodeId = null;
                        if (_opcUaService.NamespaceUris != null) // Controleer of NamespaceUris beschikbaar is
                        {
                            try
                            {
                                actualNodeId = ExpandedNodeId.ToNodeId(
                                    childData.NodeId,
                                    _opcUaService.NamespaceUris
                                );
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(
                                    ex,
                                    "Fout bij het converteren van ExpandedNodeId {ExpandedNodeId} naar NodeId voor DisplayName {DisplayName}",
                                    childData.NodeId,
                                    childData.DisplayName?.Text
                                );
                                continue; // Sla deze child over als conversie mislukt
                            }
                        }
                        else
                        {
                            _logger.Warning(
                                "NamespaceUris is null in OpcUaService, kan ExpandedNodeId niet correct converteren voor {DisplayName}",
                                childData.DisplayName?.Text
                            );
                            // Probeer een 'blinde' conversie als fallback, of sla over
                            try
                            {
                                actualNodeId = ExpandedNodeId.ToNodeId(childData.NodeId, null);
                            }
                            catch
                            {
                                continue;
                            }
                        }

                        if (actualNodeId == null)
                            continue; // Sla over als NodeId niet bepaald kon worden

                        // Cast de lambda expliciet naar Action
                        System.Windows.Application.Current.Dispatcher.Invoke(
                            (Action)(
                                () =>
                                {
                                    Children.Add(
                                        new OpcUaNodeViewModel(
                                            actualNodeId, // << GEBRUIK GECONVERTEERDE NodeId
                                            childData.DisplayName?.Text ?? "Unknown", // Voeg null check toe voor DisplayName
                                            childData.NodeClass,
                                            _opcUaService,
                                            _logger,
                                            hasGrandChildren
                                        )
                                    );
                                }
                            )
                        );
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van children voor node {NodeIdString}",
                    _nodeId.ToString()
                );
                // Optioneel: voeg een indicatie toe in de UI
            }
            OnPropertyChanged(nameof(Children)); // Forceer update als de collectie niet direct de UI update
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaTabViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using LiveChartsCore;
using LiveChartsCore.Defaults;
using LiveChartsCore.SkiaSharpView;
using LiveChartsCore.SkiaSharpView.Painting;
using Opc.Ua;
using Serilog;
using SkiaSharp;

namespace Data_Logger.ViewModels
{
    public class OpcUaTabViewModel : TabViewModelBase, IDisposable
    {
        private readonly ILogger _logger;
        private readonly IOpcUaService _opcUaService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;

        public ObservableCollection<LoggedTagValue> DataValues { get; } =
            new ObservableCollection<LoggedTagValue>();
        public OpcUaConnectionConfig OpcUaConfig =>
            ConnectionConfiguration as OpcUaConnectionConfig;
        public bool IsConnected => _opcUaService?.IsConnected ?? false;

        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }
        public ICommand ReadAllConfiguredTagsCommand { get; }
        public ICommand LoadAddressSpaceCommand { get; }
        public ICommand AddSelectedNodeToMonitoringCommand { get; }
        public ICommand RemoveSelectedNodeFromMonitoringCommand { get; }
        public ICommand ReadSelectedNodeValueCommand { get; }

        private readonly ObservableCollection<ObservablePoint> _plotDataPoints;
        public ObservableCollection<ISeries> Series { get; set; }
        public Axis[] XAxes { get; set; }
        public Axis[] YAxes { get; set; }

        public ObservableCollection<string> AvailableTagNamesForPlotting { get; } =
            new ObservableCollection<string>();
        private string _selectedTagNameForPlotting;
        public string SelectedTagNameForPlotting
        {
            get => _selectedTagNameForPlotting;
            set
            {
                _logger.Debug("Probeer SelectedTagNameForPlotting te zetten. Oud: '{OldValue}', Nieuw: '{NewValue}'", _selectedTagNameForPlotting, value);
                if (SetProperty(ref _selectedTagNameForPlotting, value))
                {
                    _logger.Information("SelectedTagNameForPlotting GEWIJZIGD naar: {SelectedTag}. Aanroepen UpdatePlotSeriesNameAndYAxis en LoadHistoricalDataForPlot.", _selectedTagNameForPlotting);
                    UpdatePlotSeriesNameAndYAxis();
                    LoadHistoricalDataForPlot();
                }
                else
                {
                    _logger.Debug("SelectedTagNameForPlotting NIET gewijzigd (zelfde waarde).");
                }
            }
        }
        private const int MaxPlotBufferSize = 500;

        public ObservableCollection<OpcUaNodeViewModel> RootNodes { get; } =
            new ObservableCollection<OpcUaNodeViewModel>();
        private bool _isBrowse = false;
        public bool IsBrowse
        {
            get => _isBrowse;
            set => SetProperty(ref _isBrowse, value);
        }

        private OpcUaNodeViewModel _selectedOpcUaNode;
        public OpcUaNodeViewModel SelectedOpcUaNode
        {
            get => _selectedOpcUaNode;
            set
            {
                if (SetProperty(ref _selectedOpcUaNode, value))
                {
                    _logger.Debug(
                        "Geselecteerde OPC UA Node in TreeView: {DisplayName}",
                        _selectedOpcUaNode?.DisplayName ?? "null"
                    );
                    System.Windows.Application.Current.Dispatcher.Invoke(
                        (Action)(
                            () =>
                            {
                                (
                                    (RelayCommand)AddSelectedNodeToMonitoringCommand
                                ).RaiseCanExecuteChanged();
                                (
                                    (RelayCommand)RemoveSelectedNodeFromMonitoringCommand
                                ).RaiseCanExecuteChanged();
                                (
                                    (RelayCommand)ReadSelectedNodeValueCommand
                                ).RaiseCanExecuteChanged();
                            }
                        )
                    );
                }
            }
        }

        private string _lastReadNodeValue = "Nog geen waarde gelezen.";
        public string LastReadNodeValue
        {
            get => _lastReadNodeValue;
            set => SetProperty(ref _lastReadNodeValue, value);
        }

        public OpcUaTabViewModel(
            OpcUaConnectionConfig config,
            ILogger logger,
            IOpcUaService opcUaService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService
        )
            : base(config)
        {
            _logger = logger
                .ForContext<OpcUaTabViewModel>()
                .ForContext("ConnectionName", config.ConnectionName);
            _opcUaService = opcUaService ?? throw new ArgumentNullException(nameof(opcUaService));
            _statusService =
                statusService ?? throw new ArgumentNullException(nameof(statusService));
            _dataLoggingService =
                dataLoggingService ?? throw new ArgumentNullException(nameof(dataLoggingService));

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(
                async _ => await DisconnectAsync(),
                _ => IsConnected
            );
            ReadAllConfiguredTagsCommand = new RelayCommand(
                async _ => await ReadAllConfiguredTagsAsync(),
                _ => IsConnected
            );
            LoadAddressSpaceCommand = new RelayCommand(
                async _ => await LoadInitialAddressSpaceAsync(),
                _ => IsConnected && !IsBrowse
            );
            AddSelectedNodeToMonitoringCommand = new RelayCommand(
                _ => AddSelectedNodeToMonitoring(),
                _ => CanAddSelectedNodeToMonitoring()
            );
            RemoveSelectedNodeFromMonitoringCommand = new RelayCommand(
                _ => RemoveSelectedNodeFromMonitoring(),
                _ => CanRemoveSelectedNodeFromMonitoring()
            );
            ReadSelectedNodeValueCommand = new RelayCommand(
                async _ => await ReadSelectedNodeValueAsync(),
                _ => CanReadSelectedNodeValue()
            );

            _opcUaService.ConnectionStatusChanged += OnOpcUaConnectionStatusChanged;
            _opcUaService.TagsDataReceived += OnOpcUaTagsDataReceived;

            _plotDataPoints = new ObservableCollection<ObservablePoint>();
            Series = new ObservableCollection<ISeries>
            {
                new LineSeries<ObservablePoint>
                {
                    Values = _plotDataPoints,
                    Name = "Waarde",
                    Fill = null,
                    GeometrySize = 5,
                    LineSmoothness = 0,
                    Stroke = new SolidColorPaint(SKColors.MediumPurple) { StrokeThickness = 2 },
                    GeometryStroke = new SolidColorPaint(SKColors.MediumPurple)
                    {
                        StrokeThickness = 2,
                    },
                },
            };
            XAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Tijdstempel",
                    Labeler = value =>
                    {
                        long ticks = (long)value;
                        // Controleer of de ticks binnen het geldige bereik vallen
                        if (ticks >= DateTime.MinValue.Ticks && ticks <= DateTime.MaxValue.Ticks)
                        {
                            return new DateTime(ticks).ToString("HH:mm:ss");
                        }
                        // Retourneer een lege string of een placeholder als de waarde ongeldig is
                        return ""; 
                    },
                    UnitWidth = TimeSpan.TicksPerSecond,
                    MinStep = TimeSpan.TicksPerSecond * 1,
                    TextSize = 10,
                    NameTextSize = 12,
                    // Optioneel: expliciete limieten instellen als er geen data is (zie hieronder)
                }
            };
            YAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Waarde",
                    TextSize = 10,
                    NameTextSize = 12,
                },
            };

            PopulateAvailableTagNames();
        }

        private void PopulateAvailableTagNames()
        {
            AvailableTagNamesForPlotting.Clear();
            if (OpcUaConfig?.TagsToMonitor != null)
            {
                foreach (
                    var tag in OpcUaConfig.TagsToMonitor.Where(t =>
                        t.IsActive && IsDataTypePlottable(t.DataType)
                    )
                )
                {
                    AvailableTagNamesForPlotting.Add(tag.TagName);
                }
            }
            SelectedTagNameForPlotting = AvailableTagNamesForPlotting.FirstOrDefault();
        }

        private void UpdatePlotSeriesNameAndYAxis() // Of een aparte methode voor as-updates
        {
            string seriesName = string.IsNullOrEmpty(_selectedTagNameForPlotting) ? "Selecteer Tag" : _selectedTagNameForPlotting;
            string yAxisName = string.IsNullOrEmpty(_selectedTagNameForPlotting) ? "Waarde" : $"Waarde ({_selectedTagNameForPlotting})";
        
            if (Series.Any() && Series[0] is LineSeries<ObservablePoint> lineSeries)
            {
                lineSeries.Name = seriesName;
            }
            if (YAxes.Any())
            {
                YAxes[0].Name = yAxisName;
            }
        
            // Stel initiële/default limieten in als er geen data is, of laat LiveCharts AutoScale doen
            if (!_plotDataPoints.Any())
            {
                if (XAxes.Any())
                {
                    // Geef een default tijdsspanne weer, bijv. het laatste uur
                    var nowTicks = DateTime.Now.Ticks;
                    var oneHourAgoTicks = DateTime.Now.AddHours(-1).Ticks;
                    XAxes[0].MinLimit = oneHourAgoTicks;
                    XAxes[0].MaxLimit = nowTicks;
                }
                if (YAxes.Any())
                {
                    YAxes[0].MinLimit = 0;
                    YAxes[0].MaxLimit = 10; // Een willekeurige kleine default range
                }
            }
            else
            {
                // Laat LiveCharts de limieten automatisch bepalen op basis van data
                if (XAxes.Any())
                {
                    XAxes[0].MinLimit = null; 
                    XAxes[0].MaxLimit = null;
                }
                if (YAxes.Any())
                {
                    YAxes[0].MinLimit = null;
                    YAxes[0].MaxLimit = null;
                }
            }
        
            OnPropertyChanged(nameof(Series)); 
            OnPropertyChanged(nameof(XAxes)); // Zorg dat de UI de as-updates meekrijgt
            OnPropertyChanged(nameof(YAxes));
        }

        private bool IsDataTypePlottable(OpcUaDataType dataType)
        {
            _logger.Verbose("Check IsDataTypePlottable voor OpcUaDataType: {DataType}", dataType);
            switch (dataType)
            {
                case OpcUaDataType.SByte:
                case OpcUaDataType.Byte:
                case OpcUaDataType.Int16:
                case OpcUaDataType.UInt16:
                case OpcUaDataType.Int32:
                case OpcUaDataType.UInt32:
                case OpcUaDataType.Int64:
                case OpcUaDataType.UInt64:
                case OpcUaDataType.Float:
                case OpcUaDataType.Double:
                    return true;

                case OpcUaDataType.Variant: // << TOEGEVOEGD ALS POTENTIEEL PLOTBAAR
                    // Als de geconfigureerde type Variant is, nemen we aan dat het plotbaar KAN zijn.
                    // De TryConvertToDouble in OnOpcUaTagsDataReceived zal de uiteindelijke check doen.
                    // Als het een Variant is die altijd een String bevat, zal het nooit plotten,
                    // maar het staat dan wel in de lijst.
                    _logger.Debug("DataType is Variant, beschouwd als mogelijk plotbaar. Werkelijke check gebeurt bij data ontvangst.");
                    return true; 

                // Deze blijven false, want ze zijn inherent niet numeriek plotbaar
                case OpcUaDataType.Boolean:
                case OpcUaDataType.String:
                case OpcUaDataType.DateTime: 
                // case OpcUaDataType.Guid: // Als je Guid had
                // case OpcUaDataType.ByteString: // Als je ByteString had
                // case OpcUaDataType.XmlElement: // Als je XmlElement had
                // case OpcUaDataType.NodeId: // etc.
                default:
                    return false;
            }
        }

        private void LoadHistoricalDataForPlot()
        {
            _logger.Debug("LoadHistoricalDataForPlot gestart voor tag: {SelectedTag}", SelectedTagNameForPlotting);
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                _plotDataPoints.Clear(); // Eerst clearen
                if (string.IsNullOrEmpty(SelectedTagNameForPlotting))
                {
                    _logger.Debug("LoadHistoricalDataForPlot: SelectedTagNameForPlotting is null/leeg, geen data geladen.");
                    UpdatePlotSeriesNameAndYAxis(); // Update namen, stelt default assen in
                    return;
                }
                if (!string.IsNullOrEmpty(SelectedTagNameForPlotting))
                {
                    var relevantValues = DataValues
                        .Where(dv => dv.TagName == SelectedTagNameForPlotting && dv.IsGoodQuality)
                        .OrderBy(dv => dv.Timestamp)
                        .ToList();

                    int count = relevantValues.Count;
                    int itemsToSkip = Math.Max(0, count - MaxPlotBufferSize);
                    var historicalValuesToDisplay = relevantValues.Skip(itemsToSkip);

                    foreach (var loggedValue in historicalValuesToDisplay)
                    {
                        if (TryConvertToDouble(loggedValue.Value, out double numericValue))
                        {
                            _plotDataPoints.Add(new ObservablePoint(loggedValue.Timestamp.Ticks, numericValue));
                        }
                    }
                }
                        _logger.Debug("LoadHistoricalDataForPlot: {Count} punten geladen in _plotDataPoints voor tag {SelectedTag}.", _plotDataPoints.Count, SelectedTagNameForPlotting);
                UpdatePlotSeriesNameAndYAxis(); // << ROEP DEZE HIER AAN (of de methode die as-limieten beheert)
            }));
        }

        private async Task ConnectAsync()
        {
            _statusService.SetStatus(
                ApplicationStatus.Connecting,
                $"Verbinden met OPC UA: {OpcUaConfig.ConnectionName}..."
            );
            _logger.Information("Verbindingspoging gestart voor {ConnectionName}...", DisplayName);
            bool success = await _opcUaService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(
                    ApplicationStatus.Logging,
                    $"Verbonden met OPC UA: {OpcUaConfig.ConnectionName}."
                );
                _logger.Information("Verbinding succesvol voor {ConnectionName}.", DisplayName);
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(() => _plotDataPoints.Clear())
                );
                UpdatePlotSeriesNameAndYAxis();
                await LoadInitialAddressSpaceAsync();
                await _opcUaService.StartMonitoringTagsAsync();
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Kon niet verbinden met OPC UA: {OpcUaConfig.ConnectionName}."
                );
                _logger.Warning("Verbinding mislukt voor {ConnectionName}.", DisplayName);
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _logger.Information("Verbinding verbreken voor {ConnectionName}...", DisplayName);
            await _opcUaService.DisconnectAsync();
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"OPC UA verbinding verbroken: {OpcUaConfig.ConnectionName}."
            );
            _logger.Information("Verbinding verbroken voor {ConnectionName}.", DisplayName);
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() => RootNodes.Clear()));
            UpdateCommandStates();
            ClearDataAndPlot();
        }

        private async Task ReadAllConfiguredTagsAsync()
        {
            if (!IsConnected)
            {
                _logger.Warning(
                    "Kan geconfigureerde tags niet lezen, niet verbonden: {ConnectionName}",
                    DisplayName
                );
                return;
            }
            _logger.Information(
                "Eenmalige leesactie voor geconfigureerde tags gestart voor {ConnectionName}",
                DisplayName
            );
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Leest geconfigureerde tags van {OpcUaConfig.ConnectionName}..."
            );
            var values = await _opcUaService.ReadCurrentTagValuesAsync();
            OnOpcUaTagsDataReceived(this, values);
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Klaar met lezen van geconfigureerde tags van {OpcUaConfig.ConnectionName}."
            );
        }

        private async Task LoadInitialAddressSpaceAsync()
        {
            if (!IsConnected || _opcUaService == null)
                return;

            IsBrowse = true;
            ((RelayCommand)LoadAddressSpaceCommand).RaiseCanExecuteChanged();
            _logger.Information(
                "Laden van initiële OPC UA address space voor {ConnectionName}",
                DisplayName
            );

            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() => RootNodes.Clear()));

            try
            {
                ReferenceDescriptionCollection rootItems = await _opcUaService.BrowseRootAsync();
                if (rootItems != null)
                {
                    foreach (var item in rootItems)
                    {
                        bool hasChildren =
                            item.NodeClass == Opc.Ua.NodeClass.Object
                            || item.NodeClass == Opc.Ua.NodeClass.View;
                        NodeId nodeId = null;
                        if (_opcUaService.NamespaceUris != null)
                        {
                            try
                            {
                                nodeId = ExpandedNodeId.ToNodeId(
                                    item.NodeId,
                                    _opcUaService.NamespaceUris
                                );
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(
                                    ex,
                                    "Fout bij converteren root ExpandedNodeId {ExpNodeId}",
                                    item.NodeId
                                );
                            }
                        }
                        if (nodeId != null)
                        {
                            System.Windows.Application.Current.Dispatcher.Invoke(
                                (Action)(
                                    () =>
                                    {
                                        RootNodes.Add(
                                            new OpcUaNodeViewModel(
                                                nodeId,
                                                item.DisplayName?.Text ?? "Unknown",
                                                item.NodeClass,
                                                _opcUaService,
                                                _logger.ForContext<OpcUaNodeViewModel>(),
                                                hasChildren
                                            )
                                        );
                                    }
                                )
                            );
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van de initiële address space voor {ConnectionName}",
                    DisplayName
                );
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Fout bij laden address space: {ex.Message}"
                );
            }
            finally
            {
                IsBrowse = false;
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(() => ((RelayCommand)LoadAddressSpaceCommand).RaiseCanExecuteChanged())
                );
            }
        }

        private void OnOpcUaConnectionStatusChanged(object sender, EventArgs e)
        {
            _logger.Debug(
                "OpcUaConnectionStatusChanged event ontvangen. IsConnected: {IsConnected} voor {ConnectionName}",
                _opcUaService.IsConnected,
                DisplayName
            );
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();
            if (!_opcUaService.IsConnected)
            {
                ClearDataAndPlot();
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(() => RootNodes.Clear())
                );
            }
        }

        private void ClearDataAndPlot()
        {
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                DataValues.Clear();
                _plotDataPoints.Clear();
                UpdatePlotSeriesNameAndYAxis(); // << ROEP DEZE HIER AAN
            }));
        }

        private void OnOpcUaTagsDataReceived(
            object sender,
            IEnumerable<LoggedTagValue> receivedTagValues
        )
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            if (!tagValuesList.Any())
                return;

            _logger.Debug(
                "OnOpcUaTagsDataReceived: {Count} tag(s) ontvangen voor {ConnectionName}",
                tagValuesList.Count,
                DisplayName
            );

            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        bool plotNeedsUpdate = false;
                        foreach (var newTagValue in tagValuesList)
                        {
                            var existingTag = DataValues.FirstOrDefault(t =>
                                t.TagName == newTagValue.TagName
                            );
                            if (existingTag != null)
                            {
                                existingTag.Value = newTagValue.Value;
                                existingTag.Timestamp = newTagValue.Timestamp;
                                existingTag.IsGoodQuality = newTagValue.IsGoodQuality;
                                existingTag.ErrorMessage = newTagValue.ErrorMessage;
                            }
                            else
                            {
                                DataValues.Add(newTagValue);
                            }

                            if (
                                newTagValue.TagName == SelectedTagNameForPlotting
                                && newTagValue.IsGoodQuality
                            )
                            {
                                if (TryConvertToDouble(newTagValue.Value, out double numericValue))
                                {
                                    _plotDataPoints.Add(
                                        new ObservablePoint(
                                            newTagValue.Timestamp.Ticks,
                                            numericValue
                                        )
                                    );
                                    plotNeedsUpdate = true;
                                }
                            }
                        }
                        if (plotNeedsUpdate)
                        {
                            while (_plotDataPoints.Count > MaxPlotBufferSize)
                            {
                                _plotDataPoints.RemoveAt(0);
                            }
                        }
                    }
                )
            );
            _dataLoggingService.LogTagValues(OpcUaConfig.ConnectionName, tagValuesList);
        }

        private bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null)
                return false;
            try
            {
                result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
                return true;
            }
            catch (FormatException)
            {
                return false;
            }
            catch (InvalidCastException)
            {
                return false;
            }
            catch (OverflowException)
            {
                return false;
            }
        }

        private void UpdateCommandStates()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)ReadAllConfiguredTagsCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)LoadAddressSpaceCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)AddSelectedNodeToMonitoringCommand).RaiseCanExecuteChanged();
                        (
                            (RelayCommand)RemoveSelectedNodeFromMonitoringCommand
                        ).RaiseCanExecuteChanged();
                        ((RelayCommand)ReadSelectedNodeValueCommand).RaiseCanExecuteChanged();
                    }
                )
            );
        }

        public void UpdateConfiguration(OpcUaConnectionConfig newConfig)
        {
            _logger.Information(
                "Warme configuratie update voor OPC UA verbinding {ConnectionName}",
                newConfig.ConnectionName
            );

            ConnectionConfiguration = newConfig;
            OnPropertyChanged(nameof(OpcUaConfig));
            if (DisplayName != newConfig.ConnectionName)
                DisplayName = newConfig.ConnectionName;

            _opcUaService.Reconfigure(newConfig);

            PopulateAvailableTagNames();
            UpdatePlotSeriesNameAndYAxis();
            LoadHistoricalDataForPlot();

            if (IsConnected)
            {
                _logger.Information(
                    "Configuratie gewijzigd, herstart monitoring voor {ConnectionName}",
                    DisplayName
                );
                Task.Run(async () =>
                {
                    await _opcUaService.StopMonitoringTagsAsync();
                    await _opcUaService.StartMonitoringTagsAsync();
                });
            }
        }

        private bool IsNodeCurrentlyMonitored(OpcUaNodeViewModel node)
        {
            if (node == null || OpcUaConfig?.TagsToMonitor == null)
                return false;
            return OpcUaConfig.TagsToMonitor.Any(t => t.NodeId == node.NodeId.ToString());
        }

        private bool CanAddSelectedNodeToMonitoring()
        {
            return SelectedOpcUaNode != null
                && (
                    SelectedOpcUaNode.NodeClass == NodeClass.Variable
                    || SelectedOpcUaNode.NodeClass == NodeClass.VariableType
                )
                && !IsNodeCurrentlyMonitored(SelectedOpcUaNode);
        }

        private bool CanRemoveSelectedNodeFromMonitoring()
        {
            return SelectedOpcUaNode != null && IsNodeCurrentlyMonitored(SelectedOpcUaNode);
        }

        private bool CanReadSelectedNodeValue()
        {
            return SelectedOpcUaNode != null
                && IsConnected
                && (
                    SelectedOpcUaNode.NodeClass == NodeClass.Variable
                    || SelectedOpcUaNode.NodeClass == NodeClass.VariableType
                );
        }

        private void AddSelectedNodeToMonitoring()
        {
            if (!CanAddSelectedNodeToMonitoring())
                return;
            var nodeToAdd = SelectedOpcUaNode;

            var newTagConfig = new OpcUaTagConfig
            {
                TagName = nodeToAdd.DisplayName,
                NodeId = nodeToAdd.NodeId.ToString(),
                IsActive = true,
                SamplingInterval = 1000,
                DataType = OpcUaDataType.Variant,
            };

            OpcUaConfig.TagsToMonitor.Add(newTagConfig);
            _logger.Information(
                "Tag {NodeId} ({DisplayName}) toegevoegd aan monitoring configuratie (nog niet opgeslagen).",
                newTagConfig.NodeId,
                newTagConfig.TagName
            );
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"Tag '{newTagConfig.TagName}' toegevoegd. Open Instellingen en sla op."
            );

            UpdateCommandStatesAfterModifyMonitoring();
            PopulateAvailableTagNames();
        }

        private void RemoveSelectedNodeFromMonitoring()
        {
            if (!CanRemoveSelectedNodeFromMonitoring())
                return;
            var nodeToRemove = SelectedOpcUaNode;

            var tagToRemove = OpcUaConfig.TagsToMonitor.FirstOrDefault(t =>
                t.NodeId == nodeToRemove.NodeId.ToString()
            );
            if (tagToRemove != null)
            {
                OpcUaConfig.TagsToMonitor.Remove(tagToRemove);
                _logger.Information(
                    "Tag {NodeId} ({DisplayName}) verwijderd uit monitoring configuratie (nog niet opgeslagen).",
                    nodeToRemove.NodeId,
                    nodeToRemove.DisplayName
                );
                _statusService.SetStatus(
                    ApplicationStatus.Idle,
                    $"Tag '{nodeToRemove.DisplayName}' verwijderd. Open Instellingen en sla op."
                );

                UpdateCommandStatesAfterModifyMonitoring();
                PopulateAvailableTagNames();
            }
        }

        private void UpdateCommandStatesAfterModifyMonitoring()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        ((RelayCommand)AddSelectedNodeToMonitoringCommand).RaiseCanExecuteChanged();
                        (
                            (RelayCommand)RemoveSelectedNodeFromMonitoringCommand
                        ).RaiseCanExecuteChanged();
                    }
                )
            );
        }

        private async Task ReadSelectedNodeValueAsync()
        {
            if (!CanReadSelectedNodeValue())
            {
                LastReadNodeValue =
                    "Kan waarde niet lezen (geen selectie/verbinding/verkeerd type).";
                return;
            }

            var nodeToRead = SelectedOpcUaNode;
            _logger.Information(
                "Lezen van waarde voor geselecteerde node: {NodeId}",
                nodeToRead.NodeId
            );
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Leest waarde van {nodeToRead.DisplayName}..."
            );

            try
            {
                DataValue dataValue = await _opcUaService.ReadValueAsync(nodeToRead.NodeId);

                if (dataValue != null)
                {
                    if (StatusCode.IsGood(dataValue.StatusCode))
                    {
                        LastReadNodeValue =
                            $"Waarde: {dataValue.Value?.ToString() ?? "null"} @ {dataValue.SourceTimestamp.ToLocalTime()} (Kwaliteit: Goed)";
                        _logger.Information(
                            "Waarde gelezen voor {NodeId}: {Value}",
                            nodeToRead.NodeId,
                            dataValue.Value
                        );
                    }
                    else
                    {
                        LastReadNodeValue = $"Fout bij lezen: {dataValue.StatusCode}";
                        _logger.Warning(
                            "Fout bij lezen waarde voor {NodeId}: {StatusCode}",
                            nodeToRead.NodeId,
                            dataValue.StatusCode
                        );
                    }
                }
                else
                {
                    LastReadNodeValue = "Geen waarde object ontvangen.";
                    _logger.Warning(
                        "Geen DataValue object ontvangen bij lezen van {NodeId}",
                        nodeToRead.NodeId
                    );
                }
            }
            catch (Exception ex)
            {
                LastReadNodeValue = $"Fout: {ex.Message}";
                _logger.Error(
                    ex,
                    "Exception bij lezen van geselecteerde node {NodeId}",
                    nodeToRead.NodeId
                );
            }
            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar met lezen.");
        }

        public void Dispose()
        {
            _logger.Debug(
                "Dispose aangeroepen voor OpcUaTabViewModel: {ConnectionName}",
                DisplayName
            );
            if (_opcUaService != null)
            {
                _opcUaService.ConnectionStatusChanged -= OnOpcUaConnectionStatusChanged;
                _opcUaService.TagsDataReceived -= OnOpcUaTagsDataReceived;
                _opcUaService.Dispose();
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\SettingsViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class SettingsViewModel : ObservableObject
    {
        private readonly ISettingsService _settingsService;
        private readonly IStatusService _statusService;
        private readonly ILogger _logger;

        private ObservableCollection<ConnectionConfigBase> _workingConnections;
        public ObservableCollection<ConnectionConfigBase> WorkingConnections
        {
            get => _workingConnections;
            set => SetProperty(ref _workingConnections, value);
        }

        private ConnectionConfigBase _selectedConnection;
        public ConnectionConfigBase SelectedConnection
        {
            get => _selectedConnection;
            set
            {
                if (SetProperty(ref _selectedConnection, value))
                {
                    ((RelayCommand)RemoveConnectionCommand).RaiseCanExecuteChanged();
                }
            }
        }

        public ICommand AddOpcUaConnectionCommand { get; }
        public ICommand AddModbusTcpConnectionCommand { get; }
        public ICommand RemoveConnectionCommand { get; }
        public ICommand SaveCommand { get; }
        public ICommand CancelCommand { get; }

        private Action _closeWindowAction;

        public SettingsViewModel(
            ISettingsService settingsService,
            IStatusService statusService,
            ILogger logger,
            Action closeWindowAction
        )
        {
            _settingsService = settingsService;
            _statusService = statusService;
            _logger = logger;
            _closeWindowAction =
                closeWindowAction ?? throw new ArgumentNullException(nameof(closeWindowAction));

            LoadWorkingCopyOfSettings();

            AddOpcUaConnectionCommand = new RelayCommand(_ => AddConnection(ConnectionType.OpcUa));
            AddModbusTcpConnectionCommand = new RelayCommand(_ =>
                AddConnection(ConnectionType.ModbusTcp)
            );
            RemoveConnectionCommand = new RelayCommand(
                _ => RemoveSelectedConnection(),
                _ => SelectedConnection != null
            );
            SaveCommand = new RelayCommand(_ => SaveSettingsAndClose());
            CancelCommand = new RelayCommand(_ => CancelAndClose());

            _logger.Information("SettingsViewModel geïnitialiseerd.");
        }

        private void LoadWorkingCopyOfSettings()
        {
            _logger.Debug("Werkkopie van instellingen laden...");

            var originalConnections = _settingsService.CurrentSettings.Connections;
            var tempWorkingConnections = new ObservableCollection<ConnectionConfigBase>();

            var serializerSettings = new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Objects,
            };

            foreach (var conn in originalConnections)
            {
                try
                {
                    string jsonConn = JsonConvert.SerializeObject(conn, serializerSettings);
                    var clonedConn = JsonConvert.DeserializeObject<ConnectionConfigBase>(
                        jsonConn,
                        serializerSettings
                    );
                    if (clonedConn != null)
                    {
                        tempWorkingConnections.Add(clonedConn);
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het klonen van een ConnectionConfig object: {ConnectionName}",
                        conn.ConnectionName
                    );
                }
            }
            WorkingConnections = tempWorkingConnections;
            _logger.Information(
                "Werkkopie van {Count} verbindingen geladen.",
                WorkingConnections.Count
            );
        }

        private void AddConnection(ConnectionType type)
        {
            ConnectionConfigBase newConnection = null;
            switch (type)
            {
                case ConnectionType.ModbusTcp:
                    newConnection = new ModbusTcpConnectionConfig();
                    _logger.Information("Nieuwe Modbus TCP verbinding toegevoegd aan werkkopie.");
                    break;
                case ConnectionType.OpcUa:
                    newConnection = new OpcUaConnectionConfig();
                    _logger.Information("Nieuwe OPC UA verbinding toegevoegd aan werkkopie.");
                    break;
                default:
                    _logger.Warning("Onbekend verbindingstype gevraagd: {Type}", type);
                    return;
            }

            if (newConnection != null)
            {
                WorkingConnections.Add(newConnection);
                SelectedConnection = newConnection;
            }
        }

        private void RemoveSelectedConnection()
        {
            if (SelectedConnection != null)
            {
                _logger.Information(
                    "Verbinding '{ConnectionName}' verwijderd uit werkkopie.",
                    SelectedConnection.ConnectionName
                );
                WorkingConnections.Remove(SelectedConnection);
                SelectedConnection = null;
            }
        }

        private void SaveSettingsAndClose()
        {
            _logger.Information("Instellingen opslaan vanuit SettingsViewModel...");
            _statusService.SetStatus(
                Enums.ApplicationStatus.Saving,
                "Bezig met opslaan van gewijzigde instellingen..."
            );

            _settingsService.CurrentSettings.Connections.Clear();
            foreach (var conn in WorkingConnections)
            {
                _settingsService.CurrentSettings.Connections.Add(conn);
            }

            _settingsService.SaveSettings();
            _logger.Information("Instellingen succesvol opgeslagen.");
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            _closeWindowAction();
        }

        private void CancelAndClose()
        {
            _logger.Information("Wijzigingen in instellingen geannuleerd.");
            _statusService.SetStatus(
                Enums.ApplicationStatus.Idle,
                "Wijzigingen in instellingen geannuleerd."
            );
            _closeWindowAction();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\TabViewModelBase.cs"
using Data_Logger.Core;
using Data_Logger.Models;

namespace Data_Logger.ViewModels
{
    public abstract class TabViewModelBase : ObservableObject
    {
        private string _displayName;

        private ConnectionConfigBase _connectionConfiguration;

        public ConnectionConfigBase ConnectionConfiguration
        {
            get => _connectionConfiguration;
            protected set => SetProperty(ref _connectionConfiguration, value);
        }

        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        protected TabViewModelBase(ConnectionConfigBase connectionConfig)
        {
            ConnectionConfiguration = connectionConfig;
            DisplayName = connectionConfig.ConnectionName;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml"
<Window x:Class="Data_Logger.Views.BrowseOpcUaNodesView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        mc:Ignorable="d"
        Title="BrowseOpcUaNodesView" Height="450" Width="800">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>   <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,5">
            <Button Content="Omhoog" Command="{Binding GoUpCommand}" MinWidth="70" Margin="0,0,10,0"/>
            <TextBlock Text="{Binding CurrentBrowsePathDisplay}" VerticalAlignment="Center" FontWeight="SemiBold" TextTrimming="CharacterEllipsis"/>
        </StackPanel>
        
        <ListView Grid.Row="1" x:Name="NodesListView"
                  ItemsSource="{Binding CurrentNodes}" 
                  SelectedItem="{Binding SelectedNodeInView}" 
                  SelectionMode="Single" Margin="0,0,0,5"
                  HorizontalContentAlignment="Stretch">
            <ListView.InputBindings>
                <MouseBinding MouseAction="LeftDoubleClick" Command="{Binding BrowseDeeperCommand}" CommandParameter="{Binding SelectedItem, ElementName=NodesListView}"/>
            </ListView.InputBindings>
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding NodeClass}" Value="Variable">
                            <Setter Property="FontWeight" Value="Bold"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="Naam" Width="*">
                        <GridViewColumn.CellTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="{Binding DisplayName}" />
                                </StackPanel>
                            </DataTemplate>
                        </GridViewColumn.CellTemplate>
                    </GridViewColumn>
                    <GridViewColumn Header="NodeClass" DisplayMemberBinding="{Binding NodeClass}" Width="100"/>
                    <GridViewColumn Header="NodeId" DisplayMemberBinding="{Binding NodeId}" Width="200"/>
                </GridView>
            </ListView.View>
        </ListView>
        
        <TextBlock Grid.Row="1" Text="Laden..." FontSize="16" HorizontalAlignment="Center" VerticalAlignment="Center"
                   Visibility="{Binding IsLoading, Converter={StaticResource BooleanToVisibilityConverter}}"/>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
            <Button Content="Selecteer" Command="{Binding SelectNodeCommand}" IsDefault="True" MinWidth="80" Margin="0,0,10,0"/>
            <Button Content="Annuleren" Command="{Binding CancelCommand}" IsCancel="True" MinWidth="80"/>
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class BrowseOpcUaNodesView : Window
    {
        public BrowseOpcUaNodesView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance vm:LogViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="600"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.LogView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <StackPanel
            Grid.Row="0"
            Margin="5"
            Orientation="Horizontal">
            <TextBlock
                Margin="0,0,5,0"
                Text="Filter Tekst:"
                VerticalAlignment="Center" />
            <TextBox
                Margin="0,0,10,0"
                Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}"
                VerticalAlignment="Center"
                Width="150" />
            <TextBlock
                Margin="0,0,5,0"
                Text="Niveau:"
                VerticalAlignment="Center" />
            <ComboBox
                ItemsSource="{Binding LogLevels}"
                Margin="0,0,10,0"
                SelectedValue="{Binding SelectedLogLevelFilter}"
                VerticalAlignment="Center"
                Width="100" />
            <Button
                Command="{Binding ClearLogsCommand}"
                Content="Wis Logs"
                VerticalAlignment="Center" />
        </StackPanel>

        <ListView
            AlternationCount="2"
            Grid.Row="1"
            ItemsSource="{Binding LogEntries}"
            Margin="5,0,5,5">
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding Level}" Value="Error">
                            <Setter Property="Background" Value="LightPink" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Fatal">
                            <Setter Property="Background" Value="Red" />
                            <Setter Property="Foreground" Value="White" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Warning">
                            <Setter Property="Background" Value="LightYellow" />
                        </DataTrigger>
                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                            <Setter Property="Background" Value="#EFEFEF" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn
                        DisplayMemberBinding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}"
                        Header="Tijd"
                        Width="150" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding LevelDisplay}"
                        Header="Niveau"
                        Width="80" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding RenderedMessage}"
                        Header="Bericht"
                        Width="Auto" />
                </GridView>
            </ListView.View>
        </ListView>
    </Grid>
</UserControl>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml.cs"
using System.Windows.Controls;

namespace Data_Logger.Views
{
    public partial class LogView : UserControl
    {
        public LogView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml"
<Window
    Height="600"
    Title="{Binding ApplicationTitle}"
    Width="800"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:views="clr-namespace:Data_Logger.Views"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Window.Resources>
        <DataTemplate DataType="{x:Type vm:ModbusTabViewModel}">
            <views:ModbusTabView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:OpcUaTabViewModel}"> <views:OpcUaTabView />
        </DataTemplate>
    </Window.Resources>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="200" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <Menu Grid.Row="0">
            <MenuItem Header="_Bestand">
                <MenuItem Command="{Binding OpenSettingsCommand}" Header="_Instellingen..." />
                <Separator />
                <MenuItem Click="Afsluiten_Click" Header="_Afsluiten" />
            </MenuItem>
        </Menu>

        <TabControl
            Grid.Row="1"
            ItemsSource="{Binding ActiveTabs}"
            Margin="5"
            SelectedItem="{Binding SelectedTab}">
            <TabControl.ItemTemplate>
                <DataTemplate DataType="{x:Type vm:TabViewModelBase}">
                    <TextBlock Text="{Binding DisplayName}" />
                </DataTemplate>
            </TabControl.ItemTemplate>
        </TabControl>

        <GridSplitter
            Background="LightGray"
            Grid.Row="2"
            Height="5"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Center" />

        <GroupBox
            Grid.Row="3"
            Header="Applicatie Logs"
            Margin="5">
            <views:LogView DataContext="{Binding LogVm}" />
        </GroupBox>

        <StatusBar Grid.Row="4" Padding="5,2">
            <StatusBar.ItemsPanel>
                <ItemsPanelTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                    </Grid>
                </ItemsPanelTemplate>
            </StatusBar.ItemsPanel>
            <StatusBarItem Grid.Column="0">
                <Ellipse
                    Height="15"
                    Margin="0,0,5,0"
                    Width="15">
                    <Ellipse.Style>
                        <Style TargetType="Ellipse">
                            <Setter Property="Fill" Value="Gray" />
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Idle}">
                                    <Setter Property="Fill" Value="LightGray" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Connecting}">
                                    <Setter Property="Fill" Value="Orange" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Logging}">
                                    <Setter Property="Fill" Value="Green" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Warning}">
                                    <Setter Property="Fill" Value="Yellow" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Error}">
                                    <Setter Property="Fill" Value="Red" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Loading}">
                                    <Setter Property="Fill" Value="SkyBlue" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Saving}">
                                    <Setter Property="Fill" Value="Plum" />
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </Ellipse.Style>
                </Ellipse>
            </StatusBarItem>
            <StatusBarItem Grid.Column="1">
                <TextBlock Text="{Binding CurrentStatusMessage}" VerticalAlignment="Center" />
            </StatusBarItem>
        </StatusBar>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class MainWindow
    {
        public MainWindow()
        {
            InitializeComponent();
        }
        
        private void Afsluiten_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance Type=vm:ModbusTabViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="300"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.ModbusTabView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:converters="clr-namespace:Data_Logger.Converters"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:wpf="clr-namespace:LiveChartsCore.SkiaSharpView.WPF;assembly=LiveChartsCore.SkiaSharpView.WPF">
    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
        
        </UserControl.Resources>

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> <RowDefinition Height="200"/>  </Grid.RowDefinitions>
        
        <StackPanel Grid.Row="0" HorizontalAlignment="Left" Margin="0,0,0,10">
            <TextBlock Text="{Binding ModbusConfig.ConnectionName}" FontSize="18" FontWeight="Bold" ToolTip="Naam van de Modbus verbinding"/>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="IP: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.IpAddress}" ToolTip="IP Adres"/>
                <TextBlock Text=":" Margin="2,0,2,0"/>
                <TextBlock Text="{Binding ModbusConfig.Port}" Margin="0,0,10,0" ToolTip="Poortnummer"/>
                <TextBlock Text="Unit ID: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.UnitId}" ToolTip="Modbus Unit ID"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                <TextBlock Text="Status: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" />
                <TextBlock Text=" (Scan Interval: " Margin="5,0,0,0" FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.ScanIntervalSeconds}" />
                <TextBlock Text="s)" />
            </StackPanel>
        </StackPanel>

        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="100" Margin="0,0,5,0"/>
            <Button Content="Verbinding Verbreken" Command="{Binding DisconnectCommand}" MinWidth="100"/>
        </StackPanel>
        
        <DataGrid Grid.Row="2" 
                  ItemsSource="{Binding DataValues}"
                  AutoGenerateColumns="False" 
                  CanUserAddRows="False" 
                  IsReadOnly="True"
                  AlternationCount="2"
                  VerticalScrollBarVisibility="Auto"
                  HorizontalScrollBarVisibility="Auto">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Tijdstempel" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" Width="Auto" SortDirection="Descending"/>
                <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*"/>
                <DataGridTextColumn Header="Waarde" Binding="{Binding FormattedValue}" Width="Auto"/>
                <DataGridTextColumn Header="Kwaliteit" Width="Auto">
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True">
                                    <Setter Property="Foreground" Value="Green"/>
                                </DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                                    <Setter Property="Foreground" Value="Red"/>
                                    <Setter Property="FontWeight" Value="Bold"/>
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.CellStyle>
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Center"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True">
                                    <Setter Property="Text" Value="Goed"/>
                                </DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                                    <Setter Property="Text" Value="Slecht"/>
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                </DataGrid.Columns>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/> <Style.Triggers>
                        <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                            <Setter Property="Background" Value="#FFF0F0"/> </DataTrigger>
                        <Trigger Property="AlternationIndex" Value="1">
                            <Setter Property="Background" Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}"/>
                             </Trigger>
                         <Trigger Property="AlternationIndex" Value="0">
                            <Setter Property="Background" Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"/>
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>
        </DataGrid>
        
        <GridSplitter Grid.Row="3" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray" ShowsPreview="True"/>
        
        <Grid Grid.Row="4">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    </Grid.RowDefinitions>
            
            <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,5,0,5">
                <TextBlock Text="Plot Tag:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                <ComboBox ItemsSource="{Binding AvailableTagNamesForPlotting}" 
                          SelectedItem="{Binding SelectedTagNameForPlotting}"
                          MinWidth="200" VerticalAlignment="Center"/>
            </StackPanel>

            <wpf:CartesianChart
                Grid.Row="1"
                Series="{Binding Series}"
                XAxes="{Binding XAxes}"
                YAxes="{Binding YAxes}"
                LegendPosition="Bottom" 
                Margin="0,5,0,0"/>
        </Grid>
    </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml.cs"
using System.Windows.Controls;
using Data_Logger.ViewModels;

namespace Data_Logger.Views
{
    public partial class ModbusTabView : UserControl
    {
        private ModbusTabViewModel _viewModel;
        

        public ModbusTabView()
        {
            InitializeComponent();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml"
<UserControl x:Class="Data_Logger.Views.OpcUaTabView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:Data_Logger.ViewModels"
             xmlns:converters="clr-namespace:Data_Logger.Converters"
             xmlns:lvc="clr-namespace:LiveChartsCore.SkiaSharpView.WPF;assembly=LiveChartsCore.SkiaSharpView.WPF"
             mc:Ignorable="d"
             d:DataContext="{d:DesignInstance Type=vm:OpcUaTabViewModel, IsDesignTimeCreatable=False}"
             d:DesignHeight="600" d:DesignWidth="800">
    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>

        <Style TargetType="{x:Type TreeViewItem}">
            <Setter Property="Header" Value="{Binding DisplayName}" />
            <Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" />
            <Setter Property="ItemsSource" Value="{Binding Children}" />
            <Setter Property="ToolTip">
                <Setter.Value>
                    <StackPanel MaxWidth="300">
                        <TextBlock Text="{Binding NodeId, StringFormat='NodeId: {0}'}" TextWrapping="Wrap"/>
                        <TextBlock Text="{Binding NodeClass, StringFormat='Class: {0}'}" />
                    </StackPanel>
                </Setter.Value>
            </Setter>
            </Style>

        <HierarchicalDataTemplate DataType="{x:Type vm:OpcUaNodeViewModel}" ItemsSource="{Binding Children}">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding DisplayName}" />
                <TextBlock Text="{Binding NodeClass, StringFormat=' ({0})'}" Foreground="Gray" FontStyle="Italic" Margin="5,0,0,0" FontSize="10"/>
            </StackPanel>
        </HierarchicalDataTemplate>

    </UserControl.Resources>

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>  
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="200"/>  </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" HorizontalAlignment="Left" Margin="0,0,0,10">
            <TextBlock Text="{Binding OpcUaConfig.ConnectionName}" FontSize="18" FontWeight="Bold" ToolTip="Naam van de OPC UA verbinding"/>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Endpoint URL: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding OpcUaConfig.EndpointUrl}" ToolTip="Endpoint URL"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Security Mode: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding OpcUaConfig.SecurityMode}" ToolTip="Security Mode"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="Security Policy: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding OpcUaConfig.SecurityPolicyUri}" ToolTip="Security Policy URI"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                <TextBlock Text="Status: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" />
            </StackPanel>
        </StackPanel>

        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="80" Margin="0,0,5,0"/>
            <Button Content="Verbinding Verbreken" Command="{Binding DisconnectCommand}" MinWidth="80" Margin="0,0,5,0"/>
            <Button Content="Lees Alle Tags (Config)" Command="{Binding ReadAllTagsCommand}" MinWidth="100" Margin="0,0,5,0"
                    ToolTip="Leest de huidige waarde van alle tags die in de Settings zijn geconfigureerd voor monitoring."/>
            <Button Content="Refresh Address Space" Command="{Binding LoadAddressSpaceCommand}" MinWidth="100" Margin="0,0,5,0"/>
            <TextBlock Text="Laden..." VerticalAlignment="Center" Margin="5,0,0,0"
                       Visibility="{Binding IsBrowse, Converter={StaticResource BooleanToVisibilityConverter}}"/>
        </StackPanel>

        <Border Grid.Row="2" BorderBrush="LightGray" BorderThickness="1" Margin="0,0,0,5">
            <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto">
                <TreeView Grid.Row="2" ItemsSource="{Binding RootNodes}" Padding="5"
                          SelectedItemChanged="TreeView_SelectedItemChanged"> 
                </TreeView>
            </ScrollViewer>
        </Border>
        
        <StackPanel Grid.Row="3" Orientation="Horizontal" Margin="0,5,0,5" HorizontalAlignment="Left">
            <Button Content="Voeg toe aan Monitoring" 
                    Command="{Binding AddSelectedNodeToMonitoringCommand}" 
                    MinWidth="150" Margin="0,0,5,0"
                    ToolTip="Voegt de geselecteerde node uit de tree toe aan de lijst van te monitoren tags (vereist Opslaan in Settings)."/>

            <Button Content="Verwijder van Monitoring" Command="{Binding RemoveSelectedNodeFromMonitoringCommand}" 
                    MinWidth="150" Margin="0,0,5,0"
                    ToolTip="Verwijdert de geselecteerde node uit de lijst van te monitoren tags (vereist Opslaan in Settings)."/>

            <Button Content="Lees Huidige Waarde" 
                    Command="{Binding ReadSelectedNodeValueCommand}" 
                    MinWidth="120" Margin="0,0,5,0"/>
            <TextBlock Text="{Binding LastReadNodeValue}" VerticalAlignment="Center" Margin="10,0,0,0" TextWrapping="Wrap"/>
        </StackPanel>
        
        <GridSplitter Grid.Row="4" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray" ShowsPreview="True"/>

        <Grid Grid.Row="5">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,5,0,5">
                <TextBlock Text="Plot Tag:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                <ComboBox ItemsSource="{Binding AvailableTagNamesForPlotting}"
                          SelectedItem="{Binding SelectedTagNameForPlotting}"
                          MinWidth="200" VerticalAlignment="Center"/>
            </StackPanel>
            <lvc:CartesianChart Grid.Row="1" x:Name="DataPlotOpcUa" Margin="0,5,0,0"
                                Series="{Binding Series}"
                                XAxes="{Binding XAxes}"
                                YAxes="{Binding YAxes}"
                                LegendPosition="Bottom" />
        </Grid>
    </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml.cs"

using System.Windows;
using Data_Logger.ViewModels;
using System.Windows.Controls;

namespace Data_Logger.Views
{
    public partial class OpcUaTabView : UserControl
    {
        private OpcUaTabViewModel _viewModel;

        public OpcUaTabView()
        {
            InitializeComponent();
        }
        
        private void TreeView_SelectedItemChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            if (this.DataContext is OpcUaTabViewModel viewModel && e.NewValue is OpcUaNodeViewModel selectedNode)
            {
                viewModel.SelectedOpcUaNode = selectedNode;
            }
            // Als e.NewValue null is (bijv. deselectie), wordt SelectedOpcUaNode in VM ook null gezet.
            else if (this.DataContext is OpcUaTabViewModel viewModelWithNull && e.NewValue == null) {
                viewModelWithNull.SelectedOpcUaNode = null;
            }
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml"
<Window
    Height="500"
    MinHeight="400"
    MinWidth="600"
    Title="Instellingen"
    Width="800"
    WindowStartupLocation="CenterOwner"
    d:DataContext="{d:DesignInstance Type=vm:SettingsViewModel,
                                     IsDesignTimeCreatable=False}"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.SettingsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:System="clr-namespace:System;assembly=mscorlib"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:models="clr-namespace:Data_Logger.Models"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:Data_Logger.Views"
    xmlns:opcua="clr-namespace:Opc.Ua;assembly=Opc.Ua.Core">
    <Window.Resources>
        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusRegisterTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusRegisterType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusDataTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusDataType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>
        
        <ObjectDataProvider x:Key="OpcUaDataTypeEnumValues" MethodName="GetValues" ObjectType="{x:Type System:Enum}">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:OpcUaDataType"/>
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>
        
        <ObjectDataProvider MethodName="GetValues"
                            ObjectType="{x:Type System:Enum}"
                            x:Key="MessageSecurityModeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="opcua:MessageSecurityMode" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider ObjectType="{x:Type local:OpcUaSecurityPolicyValues}"
                            MethodName="GetInstance"
                            x:Key="SecurityPolicyUriValues"/>

        <DataTemplate DataType="{x:Type models:OpcUaConnectionConfig}">
        <ScrollViewer VerticalScrollBarVisibility="Auto">
            <StackPanel Margin="10">
                <TextBlock Text="OPC UA Verbinding Details" FontWeight="Bold" Margin="0,0,0,10"/>
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" MinWidth="150"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

                    <Label Grid.Row="0" Grid.Column="0" Content="Naam:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="0" Grid.Column="1" Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                    <Label Grid.Row="1" Grid.Column="0" Content="Endpoint URL:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding EndpointUrl, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                    <Label Grid.Row="2" Grid.Column="0" Content="Security Mode:" VerticalAlignment="Center"/>
                    <ComboBox Grid.Row="2" Grid.Column="1" Margin="5"
                              ItemsSource="{Binding Source={StaticResource MessageSecurityModeEnumValues}}"
                              SelectedValue="{Binding SecurityMode, UpdateSourceTrigger=PropertyChanged}"/>


                    <Label Grid.Row="3" Grid.Column="0" Content="Security Policy:" VerticalAlignment="Center"/>
                    <ComboBox Grid.Row="3" Grid.Column="1" Margin="5"
                              ItemsSource="{Binding Source={StaticResource SecurityPolicyUriValues}}"
                              SelectedValue="{Binding SecurityPolicyUri, UpdateSourceTrigger=PropertyChanged}"/>

                    <Label Grid.Row="4" Grid.Column="0" Content="Gebruikersnaam:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="4" Grid.Column="1" Text="{Binding UserName, UpdateSourceTrigger=PropertyChanged, ValidatesOnExceptions=True, NotifyOnValidationError=True}" Margin="5"/>

                    <Label Grid.Row="5" Grid.Column="0" Content="Wachtwoord:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="5" Grid.Column="1" Text="{Binding Password, UpdateSourceTrigger=PropertyChanged, ValidatesOnExceptions=True, NotifyOnValidationError=True}" Margin="5"/>


                    <Label Grid.Row="6" Grid.Column="0" Content="Scan Interval (sec):" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="6" Grid.Column="1" Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                    <CheckBox Grid.Row="7" Grid.Column="1" IsChecked="{Binding IsEnabled}" Content="Actief" Margin="5" VerticalAlignment="Center"/>
                </Grid>

                <GroupBox Header="Te Monitoren OPC UA Tags" Margin="0,15,0,0">
                    <DataGrid ItemsSource="{Binding TagsToMonitor}" CanUserAddRows="True" CanUserDeleteRows="True"
                              AutoGenerateColumns="False" MinHeight="150" MaxHeight="300" Margin="5">
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName, UpdateSourceTrigger=PropertyChanged}" Width="*"/>
                            <DataGridTextColumn Header="NodeID (bijv. ns=2;s=MyVar)" Binding="{Binding NodeId, UpdateSourceTrigger=PropertyChanged}" Width="2*"/>
                            <DataGridComboBoxColumn Header="Data Type" Width="*"
                                                    ItemsSource="{Binding Source={StaticResource OpcUaDataTypeEnumValues}}"
                                                    SelectedItemBinding="{Binding DataType, UpdateSourceTrigger=PropertyChanged}"/>
                            <DataGridTextColumn Header="Sampling Interval (ms)" Binding="{Binding SamplingInterval, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                            <DataGridCheckBoxColumn Header="Actief" Binding="{Binding IsActive, UpdateSourceTrigger=PropertyChanged}" Width="Auto"/>
                        </DataGrid.Columns>
                    </DataGrid>
                </GroupBox>
            </StackPanel>
        </ScrollViewer>
    </DataTemplate>

        <DataTemplate DataType="{x:Type models:ModbusTcpConnectionConfig}">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel Margin="10">
                    <TextBlock
                        FontWeight="Bold"
                        Margin="0,0,0,10"
                        Text="Modbus TCP Verbinding Details" />
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition MinWidth="150" Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>

                        <Label
                            Content="Naam:"
                            Grid.Column="0"
                            Grid.Row="0"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="0"
                            Margin="5"
                            Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="IP Adres:"
                            Grid.Column="0"
                            Grid.Row="1"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="1"
                            Margin="5"
                            Text="{Binding IpAddress, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Poort:"
                            Grid.Column="0"
                            Grid.Row="2"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="2"
                            Margin="5"
                            Text="{Binding Port, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Unit ID:"
                            Grid.Column="0"
                            Grid.Row="3"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="3"
                            Margin="5"
                            Text="{Binding UnitId, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Scan Interval (sec):"
                            Grid.Column="0"
                            Grid.Row="4"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="4"
                            Margin="5"
                            Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" />

                        <CheckBox
                            Content="Actief"
                            Grid.Column="1"
                            Grid.Row="5"
                            IsChecked="{Binding IsEnabled}"
                            Margin="5"
                            VerticalAlignment="Center" />
                    </Grid>
                    <GroupBox Header="Te Monitoren Tags" Margin="0,15,0,0">
                        <StackPanel>
                            <DataGrid
                                AutoGenerateColumns="False"
                                CanUserAddRows="True"
                                CanUserDeleteRows="True"
                                ItemsSource="{Binding TagsToMonitor}"
                                Margin="5"
                                MaxHeight="300"
                                MinHeight="150">
                                <DataGrid.Columns>
                                    <DataGridTextColumn
                                        Binding="{Binding TagName, UpdateSourceTrigger=PropertyChanged}"
                                        Header="Tag Naam"
                                        Width="*" />
                                    <DataGridTextColumn
                                        Binding="{Binding Address, UpdateSourceTrigger=PropertyChanged}"
                                        Header="Adres"
                                        Width="Auto" />

                                    <DataGridComboBoxColumn
                                        Header="Register Type"
                                        SelectedItemBinding="{Binding RegisterType, UpdateSourceTrigger=PropertyChanged}"
                                        Width="*">
                                        <DataGridComboBoxColumn.ElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusRegisterTypeEnumValues}}" />
                                            </Style>
                                        </DataGridComboBoxColumn.ElementStyle>
                                        <DataGridComboBoxColumn.EditingElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusRegisterTypeEnumValues}}" />
                                            </Style>
                                        </DataGridComboBoxColumn.EditingElementStyle>
                                    </DataGridComboBoxColumn>

                                    <DataGridComboBoxColumn
                                        Header="Data Type"
                                        SelectedItemBinding="{Binding DataType, UpdateSourceTrigger=PropertyChanged}"
                                        Width="*">
                                        <DataGridComboBoxColumn.ElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusDataTypeEnumValues}}" />
                                                <Setter Property="IsEnabled" Value="{Binding IsDataTypeSelectionEnabled}" />
                                            </Style>
                                        </DataGridComboBoxColumn.ElementStyle>
                                        <DataGridComboBoxColumn.EditingElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusDataTypeEnumValues}}" />
                                                <Setter Property="IsEnabled" Value="{Binding IsDataTypeSelectionEnabled}" />
                                            </Style>
                                        </DataGridComboBoxColumn.EditingElementStyle>
                                    </DataGridComboBoxColumn>

                                    <DataGridCheckBoxColumn
                                        Binding="{Binding IsActive, UpdateSourceTrigger=PropertyChanged}"
                                        Header="Actief"
                                        Width="Auto" />
                                </DataGrid.Columns>
                            </DataGrid>
                        </StackPanel>
                    </GroupBox>
                </StackPanel>
            </ScrollViewer>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition MinWidth="200" Width="250" />
            <ColumnDefinition Width="5" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <ToolBar
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="0"
            Padding="5">
            <Button
                Command="{Binding AddOpcUaConnectionCommand}"
                Content="Nieuwe OPC UA"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding AddModbusTcpConnectionCommand}"
                Content="Nieuwe Modbus TCP"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding RemoveConnectionCommand}"
                Content="Verwijder Geselecteerde"
                Foreground="Red" />
        </ToolBar>

        <GroupBox
            Grid.Column="0"
            Grid.Row="1"
            Header="Verbindingen"
            Margin="5">
            <ListView
                DisplayMemberPath="ConnectionName"
                ItemsSource="{Binding WorkingConnections}"
                SelectedItem="{Binding SelectedConnection}" />
        </GroupBox>

        <GridSplitter
            Background="LightGray"
            Grid.Column="1"
            Grid.Row="1"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Stretch"
            Width="5" />

        <GroupBox
            Grid.Column="2"
            Grid.Row="1"
            Header="Details"
            Margin="5">
            <ContentControl Content="{Binding SelectedConnection}" />
        </GroupBox>

        <StackPanel
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="2"
            HorizontalAlignment="Right"
            Margin="10"
            Orientation="Horizontal">
            <Button
                Command="{Binding SaveCommand}"
                Content="Opslaan"
                IsDefault="True"
                Margin="0,0,10,0"
                MinWidth="80" />
            <Button
                Command="{Binding CancelCommand}"
                Content="Annuleren"
                IsCancel="True"
                MinWidth="80" />
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using Opc.Ua;

namespace Data_Logger.Views
{
    public partial class SettingsView : Window
    {
        public SettingsView()
        {
            InitializeComponent();
        }
    }
    
    public static class OpcUaSecurityModeValues
    {
        
        public static IEnumerable<MessageSecurityMode> Instance => 
            Enum.GetValues(typeof(MessageSecurityMode)).Cast<MessageSecurityMode>();
    }

    public static class OpcUaSecurityPolicyValues
    {
        public static IEnumerable<string> GetInstance()
        {
            return new List<string>
            {
                SecurityPolicies.None,
                SecurityPolicies.Basic256Sha256,
            };
        }
    }
}



