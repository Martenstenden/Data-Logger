// Basis map repository: "C:\Development\Projects\Afstudeeropdracht\Data Logger"
// Script uitgevoerd op: "05/10/2025 08:58:58"
// Inclusie relatieve mappen: Converters, Models, Services, ViewModels, Windows, Assets, Config, Core, Enums, Views, .
// Exclusie subpad patronen (-like): \bin\, \obj\, \packages\, \.idea\, \.vs\, \.git\, \output\
// Bestanden verder gefilterd op toegestane extensies en bestandsnamen.

// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml"
<Application
    x:Class="Data_Logger.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:converters1="clr-namespace:Data_Logger.Converters"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Application.Resources>
        <converters1:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" xmlns:converters="clr-namespace:Data_Logger.Converters" />
    </Application.Resources>
</Application>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml.cs"
using System;
using System.IO;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services;
using Data_Logger.Services.Abstractions;
using Data_Logger.Services.Implementations;
using Data_Logger.ViewModels;
using Data_Logger.Views;
using Microsoft.Extensions.DependencyInjection;
using Serilog;

namespace Data_Logger
{
    public partial class App
    {
        public IServiceProvider ServiceProvider { get; private set; }
        
        private ILoggingHostService _theActualLoggingHostService;

        public App()
        {
            _theActualLoggingHostService = new LoggingHostService();
            
            string logsDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
            if (!Directory.Exists(logsDirectory)) Directory.CreateDirectory(logsDirectory);
            string logFilePath = Path.Combine(logsDirectory, "DataLoggerApp_.log");
            
            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.Console()
                .WriteTo.File(logFilePath,
                    rollingInterval: RollingInterval.Day,
                    retainedFileCountLimit: 7,
                    outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}")
                .WriteTo.Sink(new UiLogSink(_theActualLoggingHostService))
                .CreateLogger();
            
            var serviceCollection = new ServiceCollection();
            ConfigureServices(serviceCollection);
            ServiceProvider = serviceCollection.BuildServiceProvider();
            
            var loggerFromDI = ServiceProvider.GetService<ILogger>();
            loggerFromDI?.Information("Applicatie initialisatie voltooid in App constructor (ServiceProvider is gebouwd).");
        }

        private void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<ILogger>(Log.Logger);
            
            services.AddSingleton<ILoggingHostService>(_theActualLoggingHostService);
            
            services.AddSingleton<IStatusService, StatusService>();
            services.AddSingleton<ISettingsService, SettingsService>(); 
            
            services.AddSingleton<IDataLoggingService, DataLoggingService>();
            
            services.AddSingleton<LogViewModel>(serviceProvider =>
                new LogViewModel(
                    serviceProvider.GetRequiredService<ILoggingHostService>(),
                    serviceProvider.GetRequiredService<ILogger>()
                ));
            
            services.AddSingleton<MainViewModel>(serviceProvider =>
                new MainViewModel(
                    serviceProvider.GetRequiredService<ILogger>(),
                    serviceProvider.GetRequiredService<LogViewModel>(),
                    serviceProvider.GetRequiredService<IStatusService>(),
                    serviceProvider.GetRequiredService<ISettingsService>(),
                    serviceProvider.GetRequiredService<Func<Action, SettingsViewModel>>(),
                    serviceProvider.GetRequiredService<Func<ModbusTcpConnectionConfig, IModbusService>>(),
                    serviceProvider.GetRequiredService<IDataLoggingService>() 
                ));
            
            services.AddTransient<Func<Action, SettingsViewModel>>(serviceProvider =>
                closeAction => new SettingsViewModel(
                    serviceProvider.GetRequiredService<ISettingsService>(),
                    serviceProvider.GetRequiredService<IStatusService>(),
                    serviceProvider.GetRequiredService<ILogger>(),
                    closeAction
                ));
            
            services.AddTransient<Func<ModbusTcpConnectionConfig, IModbusService>>(serviceProvider =>
                config => new ModbusService(
                    serviceProvider.GetRequiredService<ILogger>(),
                    config
                ));
        }

        protected override void OnStartup(StartupEventArgs e)
        {
            Log.Information("App.OnStartup: Begin van OnStartup.");

            var mainWindow = new MainWindow
            {
                DataContext = ServiceProvider.GetRequiredService<MainViewModel>()
            };
            mainWindow.Show();
            
            Log.Debug("App.OnStartup: MainWindow getoond.");

            base.OnStartup(e);
        }
        
        protected override void OnExit(ExitEventArgs e)
        {
            Log.CloseAndFlush();
            base.OnExit(e);
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\BooleanToConnectionStatusConverter.cs"
using System;
using System.Globalization;
using System.Windows.Data;

namespace Data_Logger.Converters
{
    public class BooleanToConnectionStatusConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isConnected)
            {
                return isConnected ? "Verbonden" : "Niet Verbonden";
            }
            return "Onbekend";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\ObservableObject.cs"
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Data_Logger.Core
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\RelayCommand.cs"
using System;
using System.Windows.Input;

namespace Data_Logger.Core
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;
        
        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }
        
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
        
        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ApplicationStatus.cs"
namespace Data_Logger.Enums
{
    public enum ApplicationStatus
    {
        Idle,        
        Connecting,  
        Logging,     
        Warning,     
        Error,       
        Loading,     
        Saving       
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ConnectionType.cs"
namespace Data_Logger.Enums
{
    public enum ConnectionType
    {
        OpcUa,
        ModbusTcp
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusDataType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusDataType
    {
        Boolean,

        Int16,
        UInt16,

        Int32,
        UInt32,
        Float32,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusRegisterType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusRegisterType
    {
        HoldingRegister,  
        InputRegister,    
        Coil,             
        DiscreteInput     
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\OpcUaDataType.cs"
namespace Data_Logger.Enums
{
    public enum OpcUaDataType
    {
        
        
        Variant,    
        Boolean,
        SByte,      
        Byte,       
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,      
        Double,     
        String,
        DateTime
        
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\AppSettings.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;

namespace Data_Logger.Models
{
    public class AppSettings : ObservableObject
    {
        private ObservableCollection<ConnectionConfigBase> _connections;
        

        public ObservableCollection<ConnectionConfigBase> Connections
        {
            get => _connections;
            set => SetProperty(ref _connections, value);
        }

        public AppSettings()
        {
            Connections = new ObservableCollection<ConnectionConfigBase>();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ConnectionConfigBase.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public abstract class ConnectionConfigBase : ObservableObject
    {
        private string _connectionName;
        private ConnectionType _type;
        private bool _isEnabled = true;
        private int _scanIntervalSeconds = 5; 

        public string ConnectionName
        {
            get => _connectionName;
            set => SetProperty(ref _connectionName, value);
        }

        public ConnectionType Type 
        {
            get => _type;
            protected set => SetProperty(ref _type, value); 
        }

        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        public int ScanIntervalSeconds
        {
            get => _scanIntervalSeconds;
            set => SetProperty(ref _scanIntervalSeconds, value);
        }


        protected ConnectionConfigBase(ConnectionType type)
        {
            Type = type; 
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\LoggedTagValue.cs"
using System;

namespace Data_Logger.Models
{
    public class LoggedTagValue
    {
        public string TagName { get; set; }
        public object Value { get; set; } 
        public DateTime Timestamp { get; set; }
        public bool IsGoodQuality { get; set; } = true; 
        public string ErrorMessage { get; set; } 

        
        public string FormattedValue 
        {
            get
            {
                if (!IsGoodQuality) return ErrorMessage ?? "Error";
                return Value?.ToString() ?? "N/A";
            }
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTagConfig.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private ushort _address; 
        public ushort Address
        {
            get => _address;
            set => SetProperty(ref _address, value);
        }

        private ModbusRegisterType _registerType = ModbusRegisterType.HoldingRegister;
        public ModbusRegisterType RegisterType
        {
            get => _registerType;
            set
            {
                if (SetProperty(ref _registerType, value))
                {
                    
                    if (_registerType == ModbusRegisterType.Coil || _registerType == ModbusRegisterType.DiscreteInput)
                    {
                        DataType = ModbusDataType.Boolean;
                    }
                    OnPropertyChanged(nameof(IsDataTypeSelectionEnabled)); 
                }
            }
        }

        private ModbusDataType _dataType = ModbusDataType.UInt16;
        public ModbusDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        
        public bool IsDataTypeSelectionEnabled => RegisterType != ModbusRegisterType.Coil && RegisterType != ModbusRegisterType.DiscreteInput;


        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }

        
        
        
        
        
        
        
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTcpConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTcpConnectionConfig : ConnectionConfigBase
    {
        private string _ipAddress = "127.0.0.1";
        private int _port = 502;
        private byte _unitId = 1;
        
        private ObservableCollection<ModbusTagConfig> _tagsToMonitor;
        public ObservableCollection<ModbusTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public string IpAddress
        {
            get => _ipAddress;
            set => SetProperty(ref _ipAddress, value);
        }

        public int Port
        {
            get => _port;
            set => SetProperty(ref _port, value);
        }

        public byte UnitId
        {
            get => _unitId;
            set => SetProperty(ref _unitId, value);
        }

        public ModbusTcpConnectionConfig() : base(ConnectionType.ModbusTcp)
        {
            ConnectionName = "Nieuwe Modbus TCP Verbinding";
            TagsToMonitor = new ObservableCollection<ModbusTagConfig>();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaConnectionConfig.cs"
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class OpcUaConnectionConfig : ConnectionConfigBase
    {
        private string _endpointUrl = "opc.tcp://localhost:4840";

        public string EndpointUrl
        {
            get => _endpointUrl;
            set => SetProperty(ref _endpointUrl, value);
        }

        public OpcUaConnectionConfig() : base(ConnectionType.OpcUa)
        {
            ConnectionName = "Nieuwe OPC UA Verbinding";
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaNodeInfo.cs"
namespace Data_Logger.Models
{
    public enum OpcUaNodeClass
    {
        Unspecified,
        Object,
        Variable,
        Method,
        View,
        ObjectType,
        VariableType,
        DataType,
        ReferenceType
        
    }

    public class OpcUaNodeInfo
    {
        public string NodeId { get; set; }
        public string DisplayName { get; set; }
        public string BrowseName { get; set; }
        public OpcUaNodeClass NodeClass { get; set; }
        public bool HasChildren { get; set; }
        
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaTagConfig.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class OpcUaTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe OPC UA Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private string _nodeId = "ns=2;s=VulHierNodeIdIn";
        public string NodeId
        {
            get => _nodeId;
            set => SetProperty(ref _nodeId, value);
        }

        private OpcUaDataType _dataType = OpcUaDataType.Variant;
        public OpcUaDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }
        
        private int _samplingInterval = 1000; 
        public int SamplingInterval { get => _samplingInterval; set => SetProperty(ref _samplingInterval, value); }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\UiLogEntry.cs"
using System;
using Serilog.Events;

namespace Data_Logger.Models
{
    public class UiLogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogEventLevel Level { get; set; }
        public string LevelDisplay => Level.ToString(); 
        public string Message { get; set; }
        public string RenderedMessage { get; set; } 
        public string Exception { get; set; } 

        
        
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\UiLogSink.cs"
using System;
using System.IO;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog.Core;
using Serilog.Events;

namespace Data_Logger.Services
{
    public class UiLogSink : ILogEventSink
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly IFormatProvider _formatProvider; 
        private bool _instanceIdLoggedFromEmit = false;

        public UiLogSink(ILoggingHostService loggingHostService, IFormatProvider formatProvider = null)
        {
            _loggingHostService = loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _formatProvider = formatProvider;
            
            Console.WriteLine($"[DIAGNOSTIC] UiLogSink Constructor: Gebruikt LoggingHostService met InstanceId: {_loggingHostService.InstanceId}");
        }

        public void Emit(LogEvent logEvent)
        {
            if (!_instanceIdLoggedFromEmit)
            {
                Console.WriteLine($"[DIAGNOSTIC] UiLogSink.Emit: Eerste aanroep met LoggingHostService InstanceId: {_loggingHostService.InstanceId}");
                _instanceIdLoggedFromEmit = true;
            }
            
            if (logEvent == null) return;

            var renderedMessage = RenderLogEvent(logEvent);

            var uiEntry = new UiLogEntry
            {
                Timestamp = logEvent.Timestamp.DateTime.ToLocalTime(), 
                Level = logEvent.Level,
                Message = logEvent.MessageTemplate.Text, 
                RenderedMessage = renderedMessage,
                Exception = logEvent.Exception?.ToString()
            };

            _loggingHostService.AddLogEntry(uiEntry);
        }

        private string RenderLogEvent(LogEvent logEvent)
        {
            var writer = new StringWriter();
            logEvent.RenderMessage(writer, _formatProvider);
            if (logEvent.Exception != null)
            {
                writer.WriteLine(); 
                writer.Write(logEvent.Exception.ToString());
            }
            return writer.ToString();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IDataLoggingService.cs"
using System.Collections.Generic;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface IDataLoggingService
    {
        void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues);
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ILoggingHostService.cs"
using System.Collections.ObjectModel;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ILoggingHostService
    {
        string InstanceId { get; } 
        ObservableCollection<UiLogEntry> LogEntries { get; }
        void AddLogEntry(UiLogEntry entry);
        void ClearLogs(); 
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IModbusService.cs"
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public class ModbusDataPoint
    {
        public ushort Address { get; set; }
        public ushort Value { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public interface IModbusService : IDisposable
    {
        bool IsConnected { get; }
        event EventHandler ConnectionStatusChanged;
        event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        Task<bool> ConnectAsync();
        Task DisconnectAsync();
        Task PollConfiguredTagsAsync(); 
        void Reconfigure(ModbusTcpConnectionConfig newConfig);
        
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IOpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface IOpcUaService : IDisposable
    {
        bool IsConnected { get; }
        event EventHandler ConnectionStatusChanged;

        Task<bool> ConnectAsync(OpcUaConnectionConfig connectionConfig);
        Task DisconnectAsync();

        Task<List<OpcUaNodeInfo>> BrowseNodeAsync(string nodeIdToBrowse = null);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ISettingsService.cs"
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ISettingsService
    {
        AppSettings CurrentSettings { get; }
        void LoadSettings();
        void SaveSettings();
        void LoadDefaultSettings(); 
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IStatusService.cs"
using Data_Logger.Enums;

namespace Data_Logger.Services.Abstractions
{
    public interface IStatusService
    {
        ApplicationStatus CurrentStatus { get; }
        string StatusMessage { get; }
        void SetStatus(ApplicationStatus status, string message);
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\DataLoggingService.cs"
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class DataLoggingService : IDataLoggingService
    {
        private readonly ILogger _logger;
        private readonly string _baseLogDirectory;
        private readonly object _fileLock = new object();

        public DataLoggingService(ILogger logger)
        {
            _logger = logger.ForContext<DataLoggingService>();

            string executableLocation = Path.GetDirectoryName(
                System.Reflection.Assembly.GetExecutingAssembly().Location
            );
            _baseLogDirectory = Path.Combine(executableLocation, "LoggedData");

            try
            {
                if (!Directory.Exists(_baseLogDirectory))
                {
                    Directory.CreateDirectory(_baseLogDirectory);
                    _logger.Information(
                        "CSV Log data map aangemaakt: {LogDirectory}",
                        _baseLogDirectory
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het aanmaken van de CSV log data map: {LogDirectory}",
                    _baseLogDirectory
                );
            }
        }

        public void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues)
        {
            if (tagValues == null || !tagValues.Any())
            {
                return;
            }

            string sanitizedConnectionName = SanitizeFileName(connectionName);
            string fileName = $"{sanitizedConnectionName}_{DateTime.Now:yyyyMMdd}.csv";
            string filePath = Path.Combine(_baseLogDirectory, fileName);

            StringBuilder csvBuilder = new StringBuilder();
            bool fileExistsAndHasContent =
                File.Exists(filePath) && new FileInfo(filePath).Length > 0;

            if (!fileExistsAndHasContent)
            {
                csvBuilder.AppendLine("Timestamp,TagName,Value,IsGoodQuality,ErrorMessage");
            }

            foreach (var tagValue in tagValues)
            {
                string safeTagName = EscapeCsvField(tagValue.TagName);
                string safeValue = EscapeCsvField(tagValue.Value?.ToString() ?? string.Empty);
                string safeErrorMessage = EscapeCsvField(tagValue.ErrorMessage ?? string.Empty);

                csvBuilder.AppendFormat(
                    CultureInfo.InvariantCulture,
                    "{0},{1},{2},{3},{4}{5}",
                    tagValue.Timestamp.ToString(
                        "yyyy-MM-dd HH:mm:ss.fff",
                        CultureInfo.InvariantCulture
                    ),
                    safeTagName,
                    safeValue,
                    tagValue.IsGoodQuality,
                    safeErrorMessage,
                    Environment.NewLine
                );
            }

            string contentToWrite = csvBuilder.ToString();

            if (
                string.IsNullOrWhiteSpace(
                    contentToWrite
                        .Replace(
                            "Timestamp,TagName,Value,IsGoodQuality,ErrorMessage"
                                + Environment.NewLine,
                            ""
                        )
                        .Replace(Environment.NewLine, "")
                )
            )
            {
                if (!tagValues.Any() && !fileExistsAndHasContent)
                    return;
                if (
                    tagValues.Any()
                    && !fileExistsAndHasContent
                    && contentToWrite.StartsWith("Timestamp,TagName")
                )
                { /* Alleen header, wel schrijven als er data is */
                }
                else if (string.IsNullOrWhiteSpace(contentToWrite.Replace(Environment.NewLine, "")))
                {
                    return;
                }
            }

            try
            {
                lock (_fileLock)
                {
                    using (
                        FileStream stream = new FileStream(
                            filePath,
                            FileMode.Append,
                            FileAccess.Write,
                            FileShare.Read
                        )
                    )
                    using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8))
                    {
                        writer.Write(contentToWrite);
                    }
                }
                _logger.Debug(
                    "Data gelogd naar {FilePath} voor connectie {ConnectionName}. Aantal tags: {TagCount}",
                    filePath,
                    connectionName,
                    tagValues.Count()
                );
            }
            catch (IOException ioEx) when (IsFileLocked(ioEx))
            {
                _logger.Warning(
                    ioEx,
                    "CSV bestand {FilePath} is geblokkeerd (sharing violation/lock) tijdens poging tot schrijven. Data voor dit interval mogelijk niet gelogd.",
                    filePath
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout bij het wegschrijven van tag data naar CSV voor connectie {ConnectionName} naar bestand {FilePath}",
                    connectionName,
                    filePath
                );
            }
        }

        private bool IsFileLocked(IOException exception)
        {
            int errorCode = Marshal.GetHRForException(exception) & 0xFFFF;
            return errorCode == 32 || errorCode == 33;
        }

        private string SanitizeFileName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return "DefaultConnection";
            return Path.GetInvalidFileNameChars()
                .Aggregate(name, (current, c) => current.Replace(c.ToString(), string.Empty));
        }

        private string EscapeCsvField(string field)
        {
            if (string.IsNullOrEmpty(field))
                return string.Empty;
            if (
                field.Contains(",")
                || field.Contains("\"")
                || field.Contains("\r")
                || field.Contains("\n")
            )
            {
                return $"\"{field.Replace("\"", "\"\"")}\"";
            }
            return field;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\LoggingHostService.cs"
using System.Collections.ObjectModel;
using System.Threading;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;

namespace Data_Logger.Services.Implementations
{
    public class LoggingHostService : ILoggingHostService
    {
        public string InstanceId { get; } 
        private static int _instanceCounter = 0;
        
        public ObservableCollection<UiLogEntry> LogEntries { get; }

        private const int MaxLogEntries = 1000;

        public LoggingHostService()
        {
            InstanceId = $"LHS_Instance_{Interlocked.Increment(ref _instanceCounter)}";
            
            LogEntries = new ObservableCollection<UiLogEntry>();
        }

        public void AddLogEntry(UiLogEntry entry)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (MaxLogEntries > 0 && LogEntries.Count >= MaxLogEntries)
                {
                    LogEntries.RemoveAt(LogEntries.Count - 1);
                }
                LogEntries.Insert(0, entry);
            });
        }

        public void ClearLogs()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                LogEntries.Clear();
            });
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\ModbusService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Modbus;
using Modbus.Device;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class ModbusService : IModbusService
    {
        private readonly ILogger _logger;
        private ModbusTcpConnectionConfig _config;
        private TcpClient _tcpClient;
        private ModbusIpMaster _master;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);

        private bool _isConnected;
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        public ModbusService(ILogger logger, ModbusTcpConnectionConfig config)
        {
            _logger = logger
                .ForContext<ModbusService>()
                .ForContext("ConnectionName", config.ConnectionName);
            _config = config;
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            _logger.Information(
                "Bezig met verbinden met Modbus server: {IpAddress}:{Port}",
                _config.IpAddress,
                _config.Port
            );
            try
            {
                _tcpClient = new TcpClient();
                Task connectTask = _tcpClient.ConnectAsync(_config.IpAddress, _config.Port);
                Task timeoutTask = Task.Delay(5000);

                Task completedTask = await Task.WhenAny(connectTask, timeoutTask);

                if (completedTask == connectTask)
                {
                    await connectTask;

                    if (_tcpClient.Connected)
                    {
                        _master = ModbusIpMaster.CreateIp(_tcpClient);
                        if (_master != null)
                        {
                            _master.Transport.ReadTimeout = 2000;
                            _master.Transport.WriteTimeout = 2000;
                            IsConnected = true;
                            _logger.Information("Succesvol verbonden met Modbus server.");
                            return true;
                        }
                        else
                        {
                            _logger.Error(
                                "Kon ModbusIpMaster niet aanmaken na succesvolle TCP verbinding."
                            );
                            _tcpClient?.Close();
                            _tcpClient = null;
                            IsConnected = false;
                            return false;
                        }
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon niet verbinden met Modbus server (ConnectAsync voltooid, maar niet verbonden). IP: {IpAddress}",
                            _config.IpAddress
                        );
                        _tcpClient?.Close();
                        _tcpClient = null;
                        IsConnected = false;
                        return false;
                    }
                }
                else
                {
                    _logger.Warning(
                        "Timeout ({Timeout}ms) tijdens verbinden met Modbus server: {IpAddress}:{Port}",
                        5000,
                        _config.IpAddress,
                        _config.Port
                    );

                    _tcpClient?.Close();
                    _tcpClient = null;
                    IsConnected = false;

                    return false;
                }
            }
            catch (SocketException sockEx)
            {
                _logger.Error(
                    sockEx,
                    "SocketException tijdens verbinden met Modbus server {IpAddress}:{Port}. Foutcode: {ErrorCode}",
                    _config.IpAddress,
                    _config.Port,
                    sockEx.SocketErrorCode
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout tijdens verbinden met Modbus server {IpAddress}:{Port}",
                    _config.IpAddress,
                    _config.Port
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;
            _logger.Information("Verbinding met Modbus server verbreken...");
            await _semaphore.WaitAsync().ConfigureAwait(false);
            try
            {
                _logger.Debug("DisconnectAsync: Semaphore verkregen. Resources sluiten.");

                _master?.Dispose();
                _tcpClient?.Close();
                _tcpClient?.Dispose();

                _master = null;
                _tcpClient = null;
                IsConnected = false;
                _logger.Information("Verbinding met Modbus server daadwerkelijk verbroken.");
            }
            catch (Exception ex)
            {
                _logger.Warning(
                    ex,
                    "Fout tijdens daadwerkelijk sluiten van Modbus resources in DisconnectAsync."
                );

                _master = null;
                _tcpClient = null;
                IsConnected = false;
            }
            finally
            {
                _semaphore.Release();
                _logger.Debug("DisconnectAsync: Semaphore vrijgegeven.");
            }
        }

        public void Reconfigure(ModbusTcpConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            _logger.Information(
                "Herconfigureren van ModbusService {ConnectionName} met nieuwe instellingen. Oude scan interval: {OldInterval}, Nieuw: {NewInterval}. Aantal oude tags: {OldTagCount}, Nieuw: {NewTagCount}",
                _config.ConnectionName,
                _config.ScanIntervalSeconds,
                newConfig.ScanIntervalSeconds,
                _config.TagsToMonitor.Count,
                newConfig.TagsToMonitor.Count
            );

            _config = newConfig;
        }

        public async Task PollConfiguredTagsAsync()
        {
            if (!IsConnected || _master == null)
            {
                _logger.Warning("Kan geconfigureerde tags niet pollen, niet verbonden.");
                return;
            }

            var results = new List<LoggedTagValue>();
            var now = DateTime.Now;

            foreach (var tag in _config.TagsToMonitor.Where(t => t.IsActive))
            {
                var loggedTag = new LoggedTagValue { TagName = tag.TagName, Timestamp = now };
                await _semaphore.WaitAsync();
                try
                {
                    object value = null;
                    ushort numRegistersToRead = 1;
                    if (
                        tag.DataType == ModbusDataType.Int32
                        || tag.DataType == ModbusDataType.UInt32
                        || tag.DataType == ModbusDataType.Float32
                    )
                    {
                        numRegistersToRead = 2;
                    }

                    switch (tag.RegisterType)
                    {
                        case ModbusRegisterType.Coil:
                            bool[] coilValues = await _master.ReadCoilsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (coilValues != null && coilValues.Length > 0)
                                value = coilValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Coil mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.DiscreteInput:
                            bool[] discreteValues = await _master.ReadInputsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (discreteValues != null && discreteValues.Length > 0)
                                value = discreteValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Discrete Input mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.HoldingRegister:
                            ushort[] holdingRegs = await _master.ReadHoldingRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (holdingRegs == null || holdingRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Holding Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(holdingRegs, tag.DataType);
                            break;

                        case ModbusRegisterType.InputRegister:
                            ushort[] inputRegs = await _master.ReadInputRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (inputRegs == null || inputRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Input Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(inputRegs, tag.DataType);
                            break;
                    }
                    loggedTag.Value = value;
                    loggedTag.IsGoodQuality = true;
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het lezen/interpreteren van Modbus tag: {TagName} (Adres: {Address}, Type: {RegisterType})",
                        tag.TagName,
                        tag.Address,
                        tag.RegisterType
                    );
                    loggedTag.IsGoodQuality = false;
                    loggedTag.ErrorMessage = ex.Message;
                }
                finally
                {
                    _semaphore.Release();
                }
                results.Add(loggedTag);
            }
            TagsDataReceived?.Invoke(this, results);
        }

        private object InterpretRegisterData(ushort[] registers, ModbusDataType dataType)
        {
            switch (dataType)
            {
                case ModbusDataType.Boolean:
                    return registers[0] != 0;
                case ModbusDataType.Int16:
                    return (short)registers[0];
                case ModbusDataType.UInt16:
                    return registers[0];

                case ModbusDataType.Int32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Int32.");

                    byte[] bytesInt32 = new byte[4];
                    bytesInt32[0] = (byte)(registers[0] >> 8);
                    bytesInt32[1] = (byte)(registers[0] & 0xFF);
                    bytesInt32[2] = (byte)(registers[1] >> 8);
                    bytesInt32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesInt32);
                    return BitConverter.ToInt32(bytesInt32, 0);

                case ModbusDataType.UInt32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor UInt32.");
                    byte[] bytesUInt32 = new byte[4];
                    bytesUInt32[0] = (byte)(registers[0] >> 8);
                    bytesUInt32[1] = (byte)registers[0];
                    bytesUInt32[2] = (byte)(registers[1] >> 8);
                    bytesUInt32[3] = (byte)registers[1];
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesUInt32);
                    return BitConverter.ToUInt32(bytesUInt32, 0);

                case ModbusDataType.Float32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Float32.");
                    byte[] bytesFloat32 = new byte[4];

                    bytesFloat32[0] = (byte)(registers[0] >> 8);
                    bytesFloat32[1] = (byte)(registers[0] & 0xFF);
                    bytesFloat32[2] = (byte)(registers[1] >> 8);
                    bytesFloat32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesFloat32);
                    return BitConverter.ToSingle(bytesFloat32, 0);

                default:
                    _logger.Warning(
                        "Niet-ondersteund ModbusDataType voor interpretatie: {DataType}. Geeft ruwe ushort[0] terug.",
                        dataType
                    );
                    return registers[0];
            }
        }

        private bool _disposed = false; 

        protected virtual void Dispose(bool disposing) 
        {
            if (_disposed) return;

            if (disposing)
            {
                _logger.Debug("ModbusService.Dispose({Disposing}) aangeroepen voor {ConnectionName}", disposing, _config.ConnectionName);

                bool acquired = false;
                try
                {
                    
                    
                    acquired = _semaphore.Wait(1000); 
                    if (acquired)
                    {
                        _logger.Debug("ModbusService.Dispose: Semaphore verkregen. Resources sluiten.");
                        _master?.Dispose();
                        _tcpClient?.Close(); 
                        _tcpClient?.Dispose();
                    }
                    else
                    {
                        _logger.Warning("ModbusService.Dispose: Timeout bij wachten op semaphore. Resources worden mogelijk niet correct vrijgegeven door deze Dispose aanroep.");
                        
                        
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "ModbusService.Dispose: Fout bij vrijgeven resources.");
                }
                finally
                {
                    if (acquired) _semaphore.Release();
                }

                _master = null;
                _tcpClient = null;
                IsConnected = false; 

                _semaphore?.Dispose(); 
            }
            _disposed = true;
        }

        public void Dispose() 
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\OpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography.X509Certificates;
using System.Threading.Tasks;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Opc.Ua;
using Opc.Ua.Client;
using Opc.Ua.Configuration;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class OpcUaService : IOpcUaService
    {
        private readonly ILogger _logger;
        private readonly OpcUaConnectionConfig _connectionConfig;
        private ApplicationConfiguration _appConfig;
        private Session _session;
        private bool _disposed = false;

        public bool IsConnected => _session != null && _session.Connected;
        public event EventHandler ConnectionStatusChanged;

        public OpcUaService(ILogger logger, OpcUaConnectionConfig config)
        {
            _logger = logger.ForContext<OpcUaService>().ForContext("Endpoint", config?.EndpointUrl);
            _connectionConfig = config ?? throw new ArgumentNullException(nameof(config));
            InitializeOpcUaApplicationConfiguration();
            _logger.Information(
                "OpcUaService instance aangemaakt voor endpoint {EndpointUrl}",
                _connectionConfig.EndpointUrl
            );
        }

        private void InitializeOpcUaApplicationConfiguration()
        {
            _appConfig = new ApplicationConfiguration
            {
                ApplicationName = "Data Logger OPC UA Client",
                ApplicationType = ApplicationType.Client,
                ApplicationUri = Utils.Format(
                    @"urn:{0}:DataLoggerOpcUaClient",
                    System.Net.Dns.GetHostName()
                ),
                ProductUri = "urn:DataLogger:OpcUaClient",
                SecurityConfiguration = new SecurityConfiguration
                {
                    ApplicationCertificate = new CertificateIdentifier
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath =
                            @"%CommonApplicationData%\OPC Foundation\CertificateStores\MachineDefault",
                        SubjectName = Utils.Format(
                            @"CN=Data Logger OPC UA Client, DC={0}",
                            System.Net.Dns.GetHostName()
                        ),
                    },
                    TrustedIssuerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath =
                            @"%CommonApplicationData%\OPC Foundation\CertificateStores\UA Certificate Authorities",
                    },
                    TrustedPeerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath =
                            @"%CommonApplicationData%\OPC Foundation\CertificateStores\UA Applications",
                    },
                    RejectedCertificateStore = new CertificateStoreIdentifier
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath =
                            @"%CommonApplicationData%\OPC Foundation\CertificateStores\RejectedCertificates",
                    },
                    AutoAcceptUntrustedCertificates = true,
                    AddAppCertToTrustedStore = true,
                },
                TransportConfigurations = new TransportConfigurationCollection(),
                TransportQuotas = new TransportQuotas { OperationTimeout = 15000 },
                ClientConfiguration = new ClientConfiguration { DefaultSessionTimeout = 60000 },
                TraceConfiguration = null,
            };
            _appConfig.Validate(ApplicationType.Client).GetAwaiter().GetResult();

            Task<X509Certificate2> cv =
                _appConfig.SecurityConfiguration.ApplicationCertificate.Find(true);
            cv.Wait();
            if (cv.Result == null)
            {
                _logger.Warning(
                    "Client instance certificaat validatieprobleem of niet gevonden. AutoAccept kan nodig zijn."
                );
            }
        }

        public async Task<bool> ConnectAsync(OpcUaConnectionConfig config = null)
        {
            var configToUse = config ?? _connectionConfig;

            if (IsConnected && _session?.Endpoint?.EndpointUrl == configToUse.EndpointUrl)
            {
                _logger.Information("Al verbonden met {EndpointUrl}", configToUse.EndpointUrl);
                return true;
            }
            if (IsConnected)
                await DisconnectAsync();

            _logger.Information(
                "Bezig met verbinden met OPC UA server: {EndpointUrl}",
                configToUse.EndpointUrl
            );
            try
            {
                bool useSecurity = false;

                var endpointDescription = CoreClientUtils.SelectEndpoint(
                    configToUse.EndpointUrl,
                    useSecurity,
                    15000
                );
                _logger.Debug(
                    "Geselecteerd OPC UA Endpoint: {Endpoint}, SecurityMode: {SecurityMode}, SecurityPolicy: {SecurityPolicy}",
                    endpointDescription.EndpointUrl,
                    endpointDescription.SecurityMode,
                    endpointDescription.SecurityPolicyUri
                );

                var endpointConfiguration = EndpointConfiguration.Create(_appConfig);
                var configuredEndpoint = new ConfiguredEndpoint(
                    null,
                    endpointDescription,
                    endpointConfiguration
                );

                var userIdentity = new UserIdentity();

                _session = await Session
                    .Create(
                        _appConfig,
                        configuredEndpoint,
                        false,
                        _appConfig.ApplicationName,
                        (uint)_appConfig.ClientConfiguration.DefaultSessionTimeout,
                        userIdentity,
                        null
                    )
                    .ConfigureAwait(false);

                if (IsConnected)
                {
                    _logger.Information(
                        "Succesvol verbonden met OPC UA server: {EndpointUrl}",
                        configToUse.EndpointUrl
                    );
                    _session.KeepAlive += Session_KeepAlive;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                    return true;
                }
                _logger.Warning(
                    "Sessie niet verbonden na Create voor OPC UA server: {EndpointUrl}",
                    configToUse.EndpointUrl
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens verbinden met OPC UA server: {EndpointUrl}",
                    configToUse.EndpointUrl
                );
            }

            _session?.Dispose();
            _session = null;
            ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
            return false;
        }

        private void Session_KeepAlive(ISession session, KeepAliveEventArgs e)
        { /* ... (vorige implementatie) ... */
            _logger.Debug("OPC UA Session KeepAlive: Status={Status}", e.CurrentState);
            if (ServiceResult.IsBad(e.Status))
                _logger.Warning("OPC UA KeepAlive Fout: {Status}.", e.Status);
        }

        public async Task DisconnectAsync()
        {
            if (_session == null)
                return;
            var sessionToClose = _session;
            _session = null;

            _logger.Information(
                "Verbinding met OPC UA server verbreken: {EndpointUrl}",
                sessionToClose.Endpoint?.EndpointUrl ?? _connectionConfig.EndpointUrl
            );
            try
            {
                if (sessionToClose.Connected)
                {
                    await Task.Run(() =>
                            sessionToClose.Close((int)_appConfig.TransportQuotas.OperationTimeout)
                        )
                        .ConfigureAwait(false);
                }
            }
            catch (Exception ex)
            {
                _logger.Warning(ex, "Fout tijdens sluiten OPC UA sessie.");
            }
            finally
            {
                sessionToClose.Dispose();
                _logger.Information("OPC UA Sessie gesloten en opgeruimd.");
                ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
            }
        }

        public async Task<List<OpcUaNodeInfo>> BrowseNodeAsync(string nodeIdToBrowse = null)
        {
            if (!IsConnected)
            {
                _logger.Warning("Kan OPC UA adresruimte niet browsen, niet verbonden.");
                if (_connectionConfig == null)
                {
                    _logger.Error(
                        "Geen OPC UA configuratie beschikbaar om te verbinden voor browsen."
                    );
                    return new List<OpcUaNodeInfo>();
                }
                if (!await ConnectAsync(_connectionConfig))
                {
                    _logger.Error(
                        "Verbinding voor browsen mislukt met endpoint: {EndpointUrl}",
                        _connectionConfig.EndpointUrl
                    );
                    return new List<OpcUaNodeInfo>();
                }
                if (!IsConnected)
                {
                    _logger.Error(
                        "Nog steeds niet verbonden na verbindingspoging, kan niet browsen."
                    );
                    return new List<OpcUaNodeInfo>();
                }
            }

            var nodesFoundInfo = new List<OpcUaNodeInfo>();
            try
            {
                NodeId currentNodeIdToBrowse = string.IsNullOrEmpty(nodeIdToBrowse)
                    ? ObjectIds.ObjectsFolder
                    : NodeId.Parse(nodeIdToBrowse);

                _logger.Debug(
                    "Starten met browsen in OPC UA adresruimte vanaf NodeId: {StartNode}",
                    currentNodeIdToBrowse
                );

                ReferenceDescriptionCollection allReferences = new ReferenceDescriptionCollection();
                byte[] rawContinuationPoint = null;

                await Task.Run(() =>
                    {
                        try
                        {
                            _session.Browse(
                                null,
                                null,
                                currentNodeIdToBrowse,
                                0,
                                BrowseDirection.Forward,
                                ReferenceTypeIds.HierarchicalReferences,
                                true,
                                (uint)(
                                    NodeClass.Object
                                    | NodeClass.Variable
                                    | NodeClass.Method
                                    | NodeClass.View
                                    | NodeClass.ObjectType
                                    | NodeClass.VariableType
                                    | NodeClass.DataType
                                ),
                                out rawContinuationPoint,
                                out ReferenceDescriptionCollection firstBatchReferences
                            );

                            if (firstBatchReferences != null)
                            {
                                allReferences.AddRange(firstBatchReferences);
                            }
                            _logger.Debug(
                                "Eerste browse call voor {NodeId} gaf {Count} referenties. ContinuationPoint leeg?: {IsCpNullOrEmpty}",
                                currentNodeIdToBrowse,
                                firstBatchReferences?.Count ?? 0,
                                rawContinuationPoint == null || rawContinuationPoint.Length == 0
                            );

                            while (rawContinuationPoint != null && rawContinuationPoint.Length > 0)
                            {
                                _logger.Debug(
                                    "Continuation point (lengte {Length}) ontvangen, BrowseNext aanroepen...",
                                    rawContinuationPoint.Length
                                );

                                ByteStringCollection continuationPointsToPass =
                                    new ByteStringCollection { rawContinuationPoint };

                                _session.BrowseNext(
                                    null,
                                    false,
                                    continuationPointsToPass,
                                    out BrowseResultCollection browseNextResultsCollection,
                                    out DiagnosticInfoCollection diagnosticInfosNext
                                );

                                rawContinuationPoint = null;

                                if (browseNextResultsCollection != null)
                                {
                                    ClientBase.ValidateResponse(
                                        browseNextResultsCollection,
                                        continuationPointsToPass
                                    );
                                    ClientBase.ValidateDiagnosticInfos(
                                        diagnosticInfosNext,
                                        continuationPointsToPass
                                    );

                                    foreach (BrowseResult result in browseNextResultsCollection)
                                    {
                                        if (
                                            StatusCode.IsGood(result.StatusCode)
                                            && result.References != null
                                        )
                                        {
                                            allReferences.AddRange(result.References);
                                        }
                                        else if (StatusCode.IsBad(result.StatusCode))
                                        {
                                            _logger.Warning(
                                                "BrowseNext Result voor een continuation point gaf StatusCode: {StatusCode}",
                                                result.StatusCode
                                            );
                                        }

                                        if (
                                            result.ContinuationPoint != null
                                            && result.ContinuationPoint.Length > 0
                                        )
                                        {
                                            rawContinuationPoint = result.ContinuationPoint;
                                            _logger.Debug(
                                                "Nieuw continuation point ({Length} bytes) ontvangen van een BrowseNext resultaat.",
                                                rawContinuationPoint.Length
                                            );
                                            break;
                                        }
                                    }
                                }

                                if (rawContinuationPoint == null)
                                {
                                    _logger.Debug(
                                        "Geen nieuw continuation point van BrowseNext resultaten, paging voltooid."
                                    );
                                    break;
                                }
                            }
                            _logger.Information(
                                "Browsen (incl. BrowseNext) voltooid voor {StartNode}. Totaal {RefCount} referenties gevonden.",
                                currentNodeIdToBrowse,
                                allReferences.Count
                            );
                        }
                        catch (ServiceResultException sre)
                        {
                            _logger.Error(
                                sre,
                                "ServiceResultException tijdens _session.Browse/BrowseNext voor NodeId: {NodeId}. Status: {StatusCode}",
                                currentNodeIdToBrowse,
                                sre.StatusCode
                            );
                        }
                        catch (Exception ex)
                        {
                            _logger.Error(
                                ex,
                                "Exception binnen Task.Run voor _session.Browse/BrowseNext voor NodeId: {NodeId}",
                                currentNodeIdToBrowse
                            );
                        }
                    })
                    .ConfigureAwait(false);

                if (allReferences != null)
                {
                    foreach (var rd in allReferences)
                    {
                        OpcUaNodeClass nodeClassEnum = OpcUaNodeClass.Unspecified;
                        if (rd.NodeClass != default(NodeClass))
                        {
                            Enum.TryParse(rd.NodeClass.ToString(), out nodeClassEnum);
                        }

                        nodesFoundInfo.Add(
                            new OpcUaNodeInfo
                            {
                                NodeId = rd.NodeId.ToString(),
                                DisplayName = rd.DisplayName.Text,
                                BrowseName = rd.BrowseName.ToString(),
                                NodeClass = nodeClassEnum,
                                HasChildren = (
                                    rd.NodeClass == Opc.Ua.NodeClass.Object
                                    || rd.NodeClass == Opc.Ua.NodeClass.View
                                    || rd.NodeClass == Opc.Ua.NodeClass.ObjectType
                                    || rd.NodeClass == Opc.Ua.NodeClass.VariableType
                                    || rd.NodeClass == Opc.Ua.NodeClass.ReferenceType
                                    || rd.NodeClass == Opc.Ua.NodeClass.DataType
                                ),
                            }
                        );
                    }
                    _logger.Information(
                        "Verwerkt {Count} nodes en geconverteerd naar OpcUaNodeInfo onder {StartNode}",
                        nodesFoundInfo.Count,
                        currentNodeIdToBrowse
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout tijdens browsen van OPC UA NodeId: {NodeIdToBrowse}",
                    nodeIdToBrowse ?? "Root"
                );
            }
            return nodesFoundInfo;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            if (disposing)
            {
                _logger.Debug(
                    "OpcUaService.Dispose({Disposing}) voor {Endpoint}",
                    disposing,
                    _connectionConfig?.EndpointUrl
                );

                if (_session != null)
                {
                    try
                    {
                        _session.Close(10000);
                    }
                    catch
                    { /* ignore */
                    }
                    _session.Dispose();
                    _session = null;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
            _disposed = true;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\SettingsService.cs"
using System;
using System.IO;
using System.Reflection;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class SettingsService : ISettingsService
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService; 
        private const string SettingsFileName = "DataLoggerSettings.json";
        private string _settingsFilePath;

        private AppSettings _currentSettings;
        public AppSettings CurrentSettings
        {
            get => _currentSettings;
            private set => _currentSettings = value; 
        }

        public SettingsService(ILogger logger, IStatusService statusService)
        {
            _logger = logger;
            _statusService = statusService;

            
            
            
            string executableLocation = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            _settingsFilePath = Path.Combine(executableLocation, SettingsFileName);
            _logger.Information("Pad naar instellingenbestand: {SettingsFilePath}", _settingsFilePath);

            LoadSettings();
        }

        public void LoadSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Loading, "Instellingen laden...");
            try
            {
                if (File.Exists(_settingsFilePath))
                {
                    _logger.Information("Instellingenbestand gevonden. Bezig met laden...");
                    string json = File.ReadAllText(_settingsFilePath);

                    
                    var serializerSettings = new JsonSerializerSettings
                    {
                        TypeNameHandling = TypeNameHandling.Objects, 
                        Formatting = Formatting.Indented 
                    };

                    _currentSettings = JsonConvert.DeserializeObject<AppSettings>(json, serializerSettings);
                    _logger.Information("Instellingen succesvol geladen.");
                }
                else
                {
                    _logger.Warning("Instellingenbestand niet gevonden op {SettingsFilePath}. Standaardinstellingen worden geladen.", _settingsFilePath);
                    LoadDefaultSettings();
                }
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Fout bij het laden van instellingen. Standaardinstellingen worden geladen.");
                LoadDefaultSettings();
            }
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen verwerkt.");
        }

        public void SaveSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Saving, "Instellingen opslaan...");
            try
            {
                
                var serializerSettings = new JsonSerializerSettings
                {
                    TypeNameHandling = TypeNameHandling.Objects, 
                    Formatting = Formatting.Indented 
                };

                string json = JsonConvert.SerializeObject(CurrentSettings, serializerSettings);
                File.WriteAllText(_settingsFilePath, json);
                _logger.Information("Instellingen succesvol opgeslagen in {SettingsFilePath}", _settingsFilePath);
                _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Fout bij het opslaan van instellingen naar {SettingsFilePath}", _settingsFilePath);
                _statusService.SetStatus(Enums.ApplicationStatus.Error, "Fout bij opslaan instellingen.");
            }
        }

        public void LoadDefaultSettings()
        {
            _logger.Information("Standaardinstellingen worden geconfigureerd.");
            _currentSettings = new AppSettings(); 

            
            _currentSettings.Connections.Add(new OpcUaConnectionConfig
            {
                ConnectionName = "Voorbeeld OPC UA Server",
                EndpointUrl = "opc.tcp://localhost:4840",
                IsEnabled = true,
                ScanIntervalSeconds = 10
            });
            _currentSettings.Connections.Add(new ModbusTcpConnectionConfig
            {
                ConnectionName = "Voorbeeld Modbus Device",
                IpAddress = "192.168.1.100",
                Port = 502,
                IsEnabled = false,
                ScanIntervalSeconds = 5
            });
            
            
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\StatusService.cs"
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class StatusService : ObservableObject, IStatusService
    {
        private readonly ILogger _logger;
        private ApplicationStatus _currentStatus;
        private string _statusMessage;

        public ApplicationStatus CurrentStatus
        {
            get => _currentStatus;
            private set => SetProperty(ref _currentStatus, value);
        }

        public string StatusMessage
        {
            get => _statusMessage;
            private set => SetProperty(ref _statusMessage, value);
        }

        public StatusService(ILogger logger)
        {
            _logger = logger;
            
            SetStatus(ApplicationStatus.Idle, "Applicatie gereed.");
        }

        public void SetStatus(ApplicationStatus status, string message)
        {
            CurrentStatus = status;
            StatusMessage = message;
            _logger.Information("Applicatiestatus gewijzigd naar: {Status} - Bericht: {Message}", status, message);
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\BrowseOpcUaNodesViewModel.cs"

using Data_Logger.Core;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions; 
using Serilog;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace Data_Logger.ViewModels
{
    public class BrowseOpcUaNodesViewModel : ObservableObject
    {
        private readonly IOpcUaService _opcUaService;
        private readonly ILogger _logger;
        
        
        public bool? DialogResult { get; private set; } 
        public OpcUaNodeInfo SelectedNodeToReturn { get; private set; } 

        public ObservableCollection<OpcUaNodeInfo> CurrentNodes { get; } = new ObservableCollection<OpcUaNodeInfo>();
        
        private string _currentBrowsePathDisplay = "Root"; 
        public string CurrentBrowsePathDisplay
        {
            get => _currentBrowsePathDisplay;
            private set => SetProperty(ref _currentBrowsePathDisplay, value);
        }

        
        private readonly Stack<string> _browseHistoryNodeIds = new Stack<string>();
        private string _currentNodeIdBeingBrowsed; 

        private OpcUaNodeInfo _selectedNodeInView; 
        public OpcUaNodeInfo SelectedNodeInView
        {
            get => _selectedNodeInView;
            set
            {
                if (SetProperty(ref _selectedNodeInView, value))
                {
                    ((RelayCommand)SelectNodeCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)BrowseDeeperCommand).RaiseCanExecuteChanged();
                }
            }
        }

        private bool _isLoading;
        public bool IsLoading
        {
            get => _isLoading;
            private set => SetProperty(ref _isLoading, value);
        }

        public ICommand SelectNodeCommand { get; }
        public ICommand CancelCommand { get; }
        public ICommand BrowseDeeperCommand { get; } 
        public ICommand GoUpCommand { get; }       

        
        
        private readonly Action<bool?> _closeWindowAction;


        public BrowseOpcUaNodesViewModel(IOpcUaService opcUaService, ILogger logger, 
                                         string initialNodeIdToStartBrowse, 
                                         Action<bool?> closeWindowAction) 
        {
            _opcUaService = opcUaService ?? throw new ArgumentNullException(nameof(opcUaService));
            _logger = logger?.ForContext<BrowseOpcUaNodesViewModel>() ?? throw new ArgumentNullException(nameof(logger));
            _closeWindowAction = closeWindowAction ?? throw new ArgumentNullException(nameof(closeWindowAction));

            SelectNodeCommand = new RelayCommand(ExecuteSelectNode, CanExecuteSelectNode);
            CancelCommand = new RelayCommand(ExecuteCancel);
            BrowseDeeperCommand = new RelayCommand(async _ => await ExecuteBrowseDeeper(), CanExecuteBrowseDeeper);
            GoUpCommand = new RelayCommand(async _ => await ExecuteGoUp(), CanExecuteGoUp);

            
            _ = InitializeAndBrowseAsync(initialNodeIdToStartBrowse);
        }

        private async Task InitializeAndBrowseAsync(string initialNodeId)
        {
            IsLoading = true;
            CurrentNodes.Clear();
            _logger.Information("BrowseOpcUaNodesViewModel: Initialiseren en browsen. StartNode: {InitialNodeId}", initialNodeId ?? "Root");

            if (!_opcUaService.IsConnected)
            {
                
                
                bool connected = await _opcUaService.ConnectAsync(null); 
                if (!connected)
                {
                    _logger.Error("Kon niet verbinden met OPC UA server voor browsen.");
                    
                    
                    IsLoading = false;
                    System.Windows.MessageBox.Show("Kan geen verbinding maken met de OPC UA server om te browsen.", "Verbindingsfout", MessageBoxButton.OK, MessageBoxImage.Error);
                    ExecuteCancel(null); 
                    return;
                }
            }
            await LoadNodesAsync(initialNodeId);
            IsLoading = false;
        }

        private async Task LoadNodesAsync(string nodeIdToBrowse)
        {
            IsLoading = true;
            CurrentNodes.Clear();
            SelectedNodeInView = null; 
            _logger.Debug("Laden van OPC UA nodes voor: {NodeId}", nodeIdToBrowse ?? "Root (ObjectsFolder)");

            _currentNodeIdBeingBrowsed = nodeIdToBrowse; 

            try
            {
                var nodes = await _opcUaService.BrowseNodeAsync(nodeIdToBrowse);
                if (nodes != null)
                {
                    foreach (var node in nodes.OrderBy(n => n.NodeClass).ThenBy(n => n.DisplayName)) 
                    {
                        CurrentNodes.Add(node);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Fout tijdens het laden van OPC UA nodes voor {NodeId}", nodeIdToBrowse ?? "Root");
                
            }
            
            UpdateBrowsePathDisplay();
            ((RelayCommand)GoUpCommand).RaiseCanExecuteChanged(); 
            IsLoading = false;
        }

        private void UpdateBrowsePathDisplay()
        {
            if (!_browseHistoryNodeIds.Any())
            {
                CurrentBrowsePathDisplay = "Root Objects"; 
            }
            else
            {
                
                CurrentBrowsePathDisplay = string.Join(" / ", _browseHistoryNodeIds.Reverse().Select(id => id.Split('=').LastOrDefault() ?? id));
                if (SelectedNodeInView != null && _currentNodeIdBeingBrowsed == SelectedNodeInView.NodeId) 
                {
                     CurrentBrowsePathDisplay += $" / {SelectedNodeInView.DisplayName}";
                }
                else if (!string.IsNullOrEmpty(_currentNodeIdBeingBrowsed))
                {
                     CurrentBrowsePathDisplay += $" / (Browse {_currentNodeIdBeingBrowsed.Split('=').LastOrDefault() ?? _currentNodeIdBeingBrowsed})";
                }
            }
        }

        private bool CanExecuteSelectNode(object parameter)
        {
            
            return SelectedNodeInView != null && SelectedNodeInView.NodeClass == OpcUaNodeClass.Variable;
        }

        private void ExecuteSelectNode(object parameter)
        {
            SelectedNodeToReturn = SelectedNodeInView;
            _logger.Information("Node geselecteerd: {NodeId} ({DisplayName})", SelectedNodeToReturn?.NodeId, SelectedNodeToReturn?.DisplayName);
            DialogResult = true; 
            _closeWindowAction(true); 
        }

        private void ExecuteCancel(object parameter = null)
        {
            _logger.Information("Browsen geannuleerd.");
            SelectedNodeToReturn = null;
            DialogResult = false; 
            _closeWindowAction(false); 
        }

        private bool CanExecuteBrowseDeeper(object parameter)
        {
            var node = parameter as OpcUaNodeInfo ?? SelectedNodeInView;
            
            
            
            return node != null && node.NodeClass != OpcUaNodeClass.Variable && node.HasChildren;
        }

        private async Task ExecuteBrowseDeeper(object parameter = null)
        {
            var nodeToBrowse = parameter as OpcUaNodeInfo ?? SelectedNodeInView;
            if (nodeToBrowse != null && (nodeToBrowse.NodeClass != OpcUaNodeClass.Variable || nodeToBrowse.HasChildren) ) 
            {
                _logger.Information("Doorbrowsen naar kinderen van: {NodeId} ({DisplayName})", nodeToBrowse.NodeId, nodeToBrowse.DisplayName);
                if (_currentNodeIdBeingBrowsed != null) 
                {
                    _browseHistoryNodeIds.Push(_currentNodeIdBeingBrowsed);
                }
                await LoadNodesAsync(nodeToBrowse.NodeId);
            }
        }

        private bool CanExecuteGoUp(object parameter)
        {
            return _browseHistoryNodeIds.Any(); 
        }

        private async Task ExecuteGoUp(object parameter = null)
        {
            if (_browseHistoryNodeIds.Any())
            {
                string parentNodeId = _browseHistoryNodeIds.Pop();
                _logger.Information("Omhoog browsen naar: {ParentNodeId}", parentNodeId ?? "Root");
                await LoadNodesAsync(parentNodeId); 
            }
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\LogViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;
using Serilog.Events;

namespace Data_Logger.ViewModels
{
    public class LogViewModel : ObservableObject
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly ILogger _logger;

        private string _filterText;
        private LogEventLevel? _selectedLogLevelFilter;

        public ObservableCollection<UiLogEntry> LogEntries => _loggingHostService.LogEntries;
        public ICollectionView FilteredLogEntries { get; }

        public string FilterText
        {
            get => _filterText;
            set
            {
                if (SetProperty(ref _filterText, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ObservableCollection<LogEventLevel?> LogLevels { get; } =
            new ObservableCollection<LogEventLevel?>(
                new LogEventLevel?[] { null }.Concat(
                    Enum.GetValues(typeof(LogEventLevel)).Cast<LogEventLevel?>()
                )
            );

        public LogEventLevel? SelectedLogLevelFilter
        {
            get => _selectedLogLevelFilter;
            set
            {
                if (SetProperty(ref _selectedLogLevelFilter, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ICommand ClearLogsCommand { get; }

        public LogViewModel(ILoggingHostService loggingHostService, ILogger logger)
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _logger =
                logger?.ForContext<LogViewModel>()
                ?? throw new ArgumentNullException(nameof(logger));

            FilteredLogEntries = CollectionViewSource.GetDefaultView(LogEntries);
            FilteredLogEntries.Filter = ApplyFilter;

            ClearLogsCommand = new RelayCommand(
                _ => _loggingHostService.ClearLogs(),
                _ => LogEntries.Any()
            );

            LogEntries.CollectionChanged += (sender, e) =>
            {
                ((RelayCommand)ClearLogsCommand).RaiseCanExecuteChanged();
            };
        }

        private bool ApplyFilter(object item)
        {
            if (item is UiLogEntry entry)
            {
                bool logLevelMatch =
                    !_selectedLogLevelFilter.HasValue
                    || entry.Level == _selectedLogLevelFilter.Value;
                bool textMatch =
                    string.IsNullOrWhiteSpace(_filterText)
                    || entry.RenderedMessage.IndexOf(
                        _filterText,
                        StringComparison.OrdinalIgnoreCase
                    ) >= 0
                    || (
                        entry.Exception != null
                        && entry.Exception.IndexOf(_filterText, StringComparison.OrdinalIgnoreCase)
                            >= 0
                    );
                return logLevelMatch && textMatch;
            }
            return false;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\MainViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.Views;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private readonly ISettingsService _settingsService;
        private readonly Func<Action, SettingsViewModel> _settingsViewModelFactory;

        private readonly Func<ModbusTcpConnectionConfig, IModbusService> _modbusServiceFactory;
        
        private readonly IDataLoggingService _dataLoggingService;

        private string _applicationTitle = "Data Logger Applicatie";
        public string ApplicationTitle
        {
            get => _applicationTitle;
            set => SetProperty(ref _applicationTitle, value);
        }

        public LogViewModel LogVm { get; }
        public ApplicationStatus CurrentApplicationStatus => _statusService.CurrentStatus;
        public string CurrentStatusMessage => _statusService.StatusMessage;

        public ObservableCollection<TabViewModelBase> ActiveTabs { get; } =
            new ObservableCollection<TabViewModelBase>();

        private TabViewModelBase _selectedTab;
        public TabViewModelBase SelectedTab
        {
            get => _selectedTab;
            set => SetProperty(ref _selectedTab, value);
        }

        public ICommand OpenSettingsCommand { get; }

        public MainViewModel(
            ILogger logger,
            LogViewModel logViewModel,
            IStatusService statusService,
            ISettingsService settingsService,
            Func<Action, SettingsViewModel> settingsViewModelFactory,
            Func<ModbusTcpConnectionConfig, IModbusService> modbusServiceFactory,
            IDataLoggingService dataLoggingService
        )
        {
            _logger = logger;
            LogVm = logViewModel;
            _statusService = statusService;
            _settingsService = settingsService;
            _settingsViewModelFactory = settingsViewModelFactory;

            _modbusServiceFactory = modbusServiceFactory;
            
            _dataLoggingService = dataLoggingService;

            if (_statusService is INotifyPropertyChanged notifier)
            {
                notifier.PropertyChanged += StatusService_PropertyChanged;
            }

            OpenSettingsCommand = new RelayCommand(_ => OpenSettingsWindow());

            _logger.Information("MainViewModel geïnitialiseerd.");
            _statusService.SetStatus(ApplicationStatus.Idle, "Applicatie succesvol geladen.");

            LoadTabsFromSettings();
        }

        private void OpenSettingsWindow()
        {
            _logger.Information("Instellingenvenster wordt geopend...");
            _statusService.SetStatus(ApplicationStatus.Idle, "Instellingen openen...");

            var settingsView = new Views.SettingsView();
            Action closeAction = () => settingsView.Close();
            var settingsVm = _settingsViewModelFactory(closeAction);
            settingsView.DataContext = settingsVm;

            if (
                Application.Current.MainWindow != null
                && Application.Current.MainWindow != settingsView
            )
            {
                settingsView.Owner = Application.Current.MainWindow;
            }

            settingsView.ShowDialog();

            _logger.Information("Instellingenvenster gesloten.");

            UpdateTabsAfterSettingsChange();

            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar.");
        }

        private void UpdateTabsAfterSettingsChange()
        {
            _logger.Information("Tabs bijwerken na mogelijke instellingwijzigingen...");
            var newEnabledConfigs = _settingsService
                .CurrentSettings.Connections.Where(c => c.IsEnabled)
                .ToDictionary(c => c.ConnectionName);

            var currentActiveTabVMs = ActiveTabs.ToList();

            foreach (var tabVm in currentActiveTabVMs)
            {
                if (
                    !newEnabledConfigs.TryGetValue(
                        tabVm.ConnectionConfiguration.ConnectionName,
                        out var newConfigData
                    ) || !newConfigData.IsEnabled
                )
                {
                    _logger.Information(
                        "Tab verwijderen voor: {ConnectionName}",
                        tabVm.ConnectionConfiguration.ConnectionName
                    );
                    if (tabVm is IDisposable disposable)
                        disposable.Dispose();
                    ActiveTabs.Remove(tabVm);
                }
            }

            foreach (var newConfigPair in newEnabledConfigs)
            {
                var newConfig = newConfigPair.Value;
                var existingTabVm = ActiveTabs.FirstOrDefault(t =>
                    t.ConnectionConfiguration.ConnectionName == newConfig.ConnectionName
                );

                if (existingTabVm != null)
                {
                    bool requiresRestart = false;
                    if (
                        newConfig is ModbusTcpConnectionConfig newModbusConf
                        && existingTabVm.ConnectionConfiguration
                            is ModbusTcpConnectionConfig oldModbusConf
                    )
                    {
                        if (
                            newModbusConf.IpAddress != oldModbusConf.IpAddress
                            || newModbusConf.Port != oldModbusConf.Port
                            || newModbusConf.UnitId != oldModbusConf.UnitId
                        )
                        {
                            requiresRestart = true;
                        }
                    }

                    if (requiresRestart)
                    {
                        _logger.Information(
                            "Kernparameters gewijzigd voor {ConnectionName}. Tab wordt herstart.",
                            newConfig.ConnectionName
                        );
                        if (existingTabVm is IDisposable disposable)
                            disposable.Dispose();
                        ActiveTabs.Remove(existingTabVm);
                        CreateAndAddTab(newConfig);
                    }
                    else
                    {
                        _logger.Information(
                            "Instellingen 'warm' toepassen op bestaande tab: {ConnectionName}",
                            newConfig.ConnectionName
                        );
                        if (
                            existingTabVm is ModbusTabViewModel modbusTabVm
                            && newConfig is ModbusTcpConnectionConfig mc
                        )
                        {
                            modbusTabVm.UpdateConfiguration(mc);
                        }
                    }
                }
                else
                {
                    _logger.Information(
                        "Nieuwe actieve verbinding gevonden, tab aanmaken voor: {ConnectionName}",
                        newConfig.ConnectionName
                    );
                    CreateAndAddTab(newConfig);
                }
            }

            if (ActiveTabs.Any() && SelectedTab == null)
                SelectedTab = ActiveTabs.First();
            else if (!ActiveTabs.Any() && SelectedTab != null)
                SelectedTab = null;
            else if (SelectedTab != null && !ActiveTabs.Contains(SelectedTab))
                SelectedTab = ActiveTabs.FirstOrDefault();
        }

        private void CreateAndAddTab(ConnectionConfigBase config)
        {
            TabViewModelBase tabVm = null;
            if (config is ModbusTcpConnectionConfig modbusConfig)
            {
                if (_modbusServiceFactory != null && _dataLoggingService != null) 
                {
                    var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                    
                    tabVm = new ModbusTabViewModel(modbusConfig, _logger, modbusServiceInstance, _statusService, _dataLoggingService);
                }
                else 
                {
                    _logger.Error("Een of meerdere factories/services zijn niet geïnjecteerd in MainViewModel. Kan ModbusTabViewModel niet aanmaken.");
                }
            }
            else if (config is OpcUaConnectionConfig opcUaConfig)
            {
                tabVm = new OpcUaTabViewModel(opcUaConfig);
                _logger.Debug(
                    "Placeholder OPC UA Tab ViewModel aangemaakt voor: {ConnectionName}",
                    opcUaConfig.ConnectionName
                );
            }

            if (tabVm != null)
            {
                ActiveTabs.Add(tabVm);
                _logger.Information(
                    "Tab aangemaakt en toegevoegd voor {ConnectionName}",
                    config.ConnectionName
                );
            }
        }

        private void LoadTabsFromSettings()
        {
            _logger.Information("Tabs laden op basis van huidige instellingen...");
            ActiveTabs.Clear();

            if (_settingsService.CurrentSettings?.Connections == null)
            {
                _logger.Warning(
                    "Geen verbindingen gevonden in de instellingen om tabs voor te laden."
                );
                return;
            }

            foreach (var config in _settingsService.CurrentSettings.Connections)
            {
                if (config.IsEnabled)
                {
                    TabViewModelBase tabVm = null;
                    switch (config.Type)
                    {
                        case ConnectionType.OpcUa:
                            if (config is OpcUaConnectionConfig opcUaConfig)
                            {
                                tabVm = new OpcUaTabViewModel(opcUaConfig);
                                _logger.Debug(
                                    "OPC UA Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    opcUaConfig.ConnectionName
                                );
                            }
                            break;
                        case ConnectionType.ModbusTcp:
                            if (config is ModbusTcpConnectionConfig modbusConfig)
                            {
                                if (_modbusServiceFactory != null)
                                {
                                    var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                                    tabVm = new ModbusTabViewModel(
                                        modbusConfig,
                                        _logger,
                                        modbusServiceInstance,
                                        _statusService,
                                        _dataLoggingService
                                    );
                                    _logger.Debug(
                                        "Modbus TCP Tab ViewModel aangemaakt voor: {ConnectionName}",
                                        modbusConfig.ConnectionName
                                    );
                                }
                                else
                                {
                                    _logger.Error(
                                        "_modbusServiceFactory is niet geïnjecteerd in MainViewModel."
                                    );
                                }
                            }
                            break;
                        default:
                            _logger.Warning(
                                "Onbekend verbindingstype '{Type}' overgeslagen voor tab: {ConnectionName}",
                                config.Type,
                                config.ConnectionName
                            );
                            break;
                    }

                    if (tabVm != null)
                    {
                        ActiveTabs.Add(tabVm);
                    }
                }
                else
                {
                    _logger.Debug(
                        "Verbinding '{ConnectionName}' is uitgeschakeld en wordt niet als tab geladen.",
                        config.ConnectionName
                    );
                }
            }

            if (ActiveTabs.Any())
            {
                SelectedTab = ActiveTabs.First();
            }
            _logger.Information("{Count} actieve tabs geladen.", ActiveTabs.Count);
        }

        private void StatusService_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(IStatusService.CurrentStatus))
            {
                OnPropertyChanged(nameof(CurrentApplicationStatus));
            }
            else if (e.PropertyName == nameof(IStatusService.StatusMessage))
            {
                OnPropertyChanged(nameof(CurrentStatusMessage));
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ModbusTabViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class ModbusTabViewModel : TabViewModelBase, IDisposable
    {
        private readonly ILogger _logger;
        private readonly IModbusService _modbusService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;
        private DispatcherTimer _scanTimer;

        public ModbusTcpConnectionConfig ModbusConfig =>
            ConnectionConfiguration as ModbusTcpConnectionConfig;
        public bool IsConnected => _modbusService.IsConnected;
        public ObservableCollection<LoggedTagValue> DataValues { get; } =
            new ObservableCollection<LoggedTagValue>();

        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }

        public ObservableCollection<string> AvailableTagNamesForPlotting { get; } =
            new ObservableCollection<string>();
        private string _selectedTagNameForPlotting;
        public string SelectedTagNameForPlotting
        {
            get => _selectedTagNameForPlotting;
            set
            {
                if (SetProperty(ref _selectedTagNameForPlotting, value))
                {
                    _logger.Debug(
                        "Geselecteerde tag voor plotten gewijzigd naar: {SelectedTag}",
                        _selectedTagNameForPlotting
                    );
                    LoadHistoricalDataForPlot();
                    SignalPlotUpdate();
                }
            }
        }

        private readonly List<(double TimeOADate, double Value)> _plotDataBuffer =
            new List<(double TimeOADate, double Value)>();
        private const int MaxPlotBufferSize = 500;
        public double[] PlotXData { get; private set; }
        public double[] PlotYData { get; private set; }
        public event EventHandler PlotDataUpdated;

        public ModbusTabViewModel(
            ModbusTcpConnectionConfig config,
            ILogger logger,
            IModbusService modbusService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService
        )
            : base(config)
        {
            _logger = logger
                .ForContext<ModbusTabViewModel>()
                .ForContext("ConnectionName", config.ConnectionName);
            _modbusService = modbusService;
            _statusService = statusService;
            _dataLoggingService = dataLoggingService;

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(
                async _ => await DisconnectAsync(),
                _ => IsConnected
            );

            _modbusService.ConnectionStatusChanged += OnModbusConnectionStatusChanged;
            _modbusService.TagsDataReceived += OnModbusTagsDataReceived;

            PopulateAvailableTagNames();
            InitializeScanTimer();
        }

        private void PopulateAvailableTagNames()
        {
            AvailableTagNamesForPlotting.Clear();
            if (ModbusConfig?.TagsToMonitor != null)
            {
                foreach (
                    var tag in ModbusConfig.TagsToMonitor.Where(t =>
                        t.IsActive && IsDataTypePlottable(t.DataType)
                    )
                )
                {
                    AvailableTagNamesForPlotting.Add(tag.TagName);
                }
            }

            SelectedTagNameForPlotting = AvailableTagNamesForPlotting.FirstOrDefault();
        }

        private bool IsDataTypePlottable(ModbusDataType dataType)
        {
            switch (dataType)
            {
                case ModbusDataType.Int16:
                case ModbusDataType.UInt16:
                case ModbusDataType.Int32:
                case ModbusDataType.UInt32:
                case ModbusDataType.Float32:
                    return true;
                case ModbusDataType.Boolean:
                default:
                    return false;
            }
        }

        private void LoadHistoricalDataForPlot()
        {
            _plotDataBuffer.Clear();
            if (!string.IsNullOrEmpty(SelectedTagNameForPlotting))
            {
                foreach (
                    var loggedValue in DataValues.Where(dv =>
                        dv.TagName == SelectedTagNameForPlotting && dv.IsGoodQuality
                    )
                )
                {
                    if (TryConvertToDouble(loggedValue.Value, out double numericValue))
                    {
                        _plotDataBuffer.Add((loggedValue.Timestamp.ToOADate(), numericValue));
                    }
                }
                while (_plotDataBuffer.Count > MaxPlotBufferSize)
                {
                    _plotDataBuffer.RemoveAt(0);
                }
            }
        }

        private void OnModbusTagsDataReceived(
            object sender,
            IEnumerable<LoggedTagValue> receivedTagValues
        )
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            _logger.Debug(
                "OnModbusTagsDataReceived event ontvangen. Aantal tagwaarden: {Count}",
                tagValuesList.Count
            );

            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                DataValues.Clear();
                foreach (var tagValue in tagValuesList)
                {
                    DataValues.Add(tagValue);
                }
            });

            if (tagValuesList.Any())
            {
                _dataLoggingService.LogTagValues(ModbusConfig.ConnectionName, tagValuesList);
            }

            if (!string.IsNullOrEmpty(SelectedTagNameForPlotting))
            {
                var selectedTagData = tagValuesList.FirstOrDefault(tv =>
                    tv.TagName == SelectedTagNameForPlotting && tv.IsGoodQuality
                );
                if (selectedTagData != null)
                {
                    if (TryConvertToDouble(selectedTagData.Value, out double numericValue))
                    {
                        _plotDataBuffer.Add((selectedTagData.Timestamp.ToOADate(), numericValue));
                        while (_plotDataBuffer.Count > MaxPlotBufferSize)
                        {
                            _plotDataBuffer.RemoveAt(0);
                        }
                        SignalPlotUpdate();
                    }
                }
            }
        }

        private bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null)
                return false;
            try
            {
                result = System.Convert.ToDouble(value, CultureInfo.InvariantCulture);
                return true;
            }
            catch (FormatException)
            {
                return false;
            }
            catch (InvalidCastException)
            {
                return false;
            }
            catch (OverflowException)
            {
                return false;
            }
        }

        private void SignalPlotUpdate()
        {
            PlotXData = _plotDataBuffer.Select(p => p.TimeOADate).ToArray();
            PlotYData = _plotDataBuffer.Select(p => p.Value).ToArray();

            PlotDataUpdated?.Invoke(this, EventArgs.Empty);

            OnPropertyChanged(nameof(PlotXData));
            OnPropertyChanged(nameof(PlotYData));
        }

        public void UpdateConfiguration(ModbusTcpConnectionConfig newConfig)
        {
            var currentSpecificConfig = this.ConnectionConfiguration as ModbusTcpConnectionConfig;
            if (currentSpecificConfig == null)
            {
                _logger.Error("UpdateConfig: Huidige config is null");
                return;
            }
            if (newConfig == null)
            {
                _logger.Error("UpdateConfig: Nieuwe config is null");
                return;
            }

            if (
                currentSpecificConfig.IpAddress != newConfig.IpAddress
                || currentSpecificConfig.Port != newConfig.Port
                || currentSpecificConfig.UnitId != newConfig.UnitId
            )
            {
                _logger.Error(
                    "ModbusTabViewModel.UpdateConfiguration aangeroepen met gewijzigde IP/Poort/UnitID voor {DisplayName}. Dit is voor een 'warme' update niet de bedoeling.",
                    DisplayName
                );
                return;
            }

            _logger.Information(
                "Warme configuratie update voor {ConnectionName}",
                newConfig.ConnectionName
            );

            bool tagsOrIntervalChanged =
                currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds
                || !currentSpecificConfig.TagsToMonitor.SequenceEqual(newConfig.TagsToMonitor);

            if (
                _scanTimer != null
                && currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds
            )
            {
                _logger.Information(
                    "Scan interval voor {DisplayName} gewijzigd van {OldInterval}s naar {NewInterval}s.",
                    DisplayName,
                    currentSpecificConfig.ScanIntervalSeconds,
                    newConfig.ScanIntervalSeconds
                );
                bool restartTimer = _scanTimer.IsEnabled;
                _scanTimer.Stop();
                _scanTimer.Interval = TimeSpan.FromSeconds(
                    newConfig.ScanIntervalSeconds > 0 ? newConfig.ScanIntervalSeconds : 5
                );
                if (restartTimer && IsConnected)
                {
                    _scanTimer.Start();
                }
            }

            this.ConnectionConfiguration = newConfig;
            OnPropertyChanged(nameof(ModbusConfig));
            _modbusService.Reconfigure(newConfig);
            if (DisplayName != newConfig.ConnectionName)
                DisplayName = newConfig.ConnectionName;

            if (tagsOrIntervalChanged)
            {
                _logger.Debug(
                    "Configuratie gewijzigd, herpopuleren plot tags en trigger plot update."
                );
                PopulateAvailableTagNames();
            }
        }

        private void InitializeScanTimer()
        {
            _scanTimer = new DispatcherTimer();
            _scanTimer.Interval = TimeSpan.FromSeconds(
                ModbusConfig.ScanIntervalSeconds > 0 ? ModbusConfig.ScanIntervalSeconds : 5
            );
            _scanTimer.Tick += async (s, e) => await ScanTimer_TickAsync();
        }

        private async Task ScanTimer_TickAsync()
        {
            if (IsConnected)
            {
                await ReadConfiguredTagsAsync();
            }
        }

        private async Task ConnectAsync()
        {
            _statusService.SetStatus(
                ApplicationStatus.Connecting,
                $"Verbinden met Modbus: {ModbusConfig.ConnectionName}..."
            );
            _logger.Information("Verbindingspoging gestart...");
            bool success = await _modbusService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(
                    ApplicationStatus.Logging,
                    $"Verbonden met Modbus: {ModbusConfig.ConnectionName}."
                );
                _logger.Information("Verbinding succesvol.");
                _plotDataBuffer.Clear();
                SignalPlotUpdate();
                _scanTimer.Start();
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Kon niet verbinden met Modbus: {ModbusConfig.ConnectionName}."
                );
                _logger.Warning("Verbinding mislukt.");
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _scanTimer.Stop();
            _logger.Information("Verbinding verbreken...");
            await _modbusService.DisconnectAsync();
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"Modbus verbinding verbroken: {ModbusConfig.ConnectionName}."
            );
            _logger.Information("Verbinding verbroken.");
            UpdateCommandStates();
            DataValues.Clear();
            _plotDataBuffer.Clear();
            SignalPlotUpdate();
        }

        private async Task ReadConfiguredTagsAsync()
        {
            if (!IsConnected)
                return;
            _logger.Debug(
                "Bezig met pollen van geconfigureerde Modbus tags voor {ConnectionName}",
                ModbusConfig.ConnectionName
            );
            await _modbusService.PollConfiguredTagsAsync();
        }

        private void OnModbusConnectionStatusChanged(object sender, EventArgs e)
        {
            _logger.Debug(
                "ModbusConnectionStatusChanged event ontvangen. IsConnected: {IsConnected}",
                _modbusService.IsConnected
            );
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();
            if (!_modbusService.IsConnected)
            {
                _scanTimer.Stop();
                DataValues.Clear();
                _plotDataBuffer.Clear();
                SignalPlotUpdate();
            }
            else
            {
                if (!_scanTimer.IsEnabled)
                {
                    _plotDataBuffer.Clear();
                    SignalPlotUpdate();
                    _scanTimer.Start();
                }
            }
        }

        private void UpdateCommandStates()
        {
            ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
            ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
        }

        public void Dispose()
        {
            _logger.Debug(
                "Dispose aangeroepen voor ModbusTabViewModel: {ConnectionName}",
                ModbusConfig.ConnectionName
            );
            _scanTimer?.Stop();
            if (_modbusService != null)
            {
                _modbusService.ConnectionStatusChanged -= OnModbusConnectionStatusChanged;
                _modbusService.TagsDataReceived -= OnModbusTagsDataReceived;
                _modbusService.Dispose();
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaTabViewModel.cs"
using Data_Logger.Models;

namespace Data_Logger.ViewModels
{
    public class OpcUaTabViewModel : TabViewModelBase
    {
        public OpcUaConnectionConfig OpcUaConfig => ConnectionConfiguration as OpcUaConnectionConfig;

        public OpcUaTabViewModel(OpcUaConnectionConfig config) : base(config)
        {
            
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\SettingsViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class SettingsViewModel : ObservableObject
    {
        private readonly ISettingsService _settingsService;
        private readonly IStatusService _statusService;
        private readonly ILogger _logger;

        private ObservableCollection<ConnectionConfigBase> _workingConnections;
        public ObservableCollection<ConnectionConfigBase> WorkingConnections
        {
            get => _workingConnections;
            set => SetProperty(ref _workingConnections, value);
        }

        private ConnectionConfigBase _selectedConnection;
        public ConnectionConfigBase SelectedConnection
        {
            get => _selectedConnection;
            set
            {
                if (SetProperty(ref _selectedConnection, value))
                {
                    ((RelayCommand)RemoveConnectionCommand).RaiseCanExecuteChanged();
                    
                }
            }
        }

        public ICommand AddOpcUaConnectionCommand { get; }
        public ICommand AddModbusTcpConnectionCommand { get; }
        public ICommand RemoveConnectionCommand { get; }
        public ICommand SaveCommand { get; }
        public ICommand CancelCommand { get; } 

        private Action _closeWindowAction; 

        public SettingsViewModel(ISettingsService settingsService, IStatusService statusService, ILogger logger, Action closeWindowAction)
        {
            _settingsService = settingsService;
            _statusService = statusService;
            _logger = logger;
            _closeWindowAction = closeWindowAction ?? throw new ArgumentNullException(nameof(closeWindowAction));

            LoadWorkingCopyOfSettings();

            AddOpcUaConnectionCommand = new RelayCommand(_ => AddConnection(ConnectionType.OpcUa));
            AddModbusTcpConnectionCommand = new RelayCommand(_ => AddConnection(ConnectionType.ModbusTcp));
            RemoveConnectionCommand = new RelayCommand(_ => RemoveSelectedConnection(), _ => SelectedConnection != null);
            SaveCommand = new RelayCommand(_ => SaveSettingsAndClose());
            CancelCommand = new RelayCommand(_ => CancelAndClose());

            _logger.Information("SettingsViewModel geïnitialiseerd.");
        }

        private void LoadWorkingCopyOfSettings()
        {
            _logger.Debug("Werkkopie van instellingen laden...");
            
            
            
            var originalConnections = _settingsService.CurrentSettings.Connections;
            var tempWorkingConnections = new ObservableCollection<ConnectionConfigBase>();

            var serializerSettings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.Objects };

            foreach (var conn in originalConnections)
            {
                try
                {
                    string jsonConn = JsonConvert.SerializeObject(conn, serializerSettings);
                    var clonedConn = JsonConvert.DeserializeObject<ConnectionConfigBase>(jsonConn, serializerSettings);
                    if (clonedConn != null)
                    {
                        tempWorkingConnections.Add(clonedConn);
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "Fout bij het klonen van een ConnectionConfig object: {ConnectionName}", conn.ConnectionName);
                }
            }
            WorkingConnections = tempWorkingConnections;
            _logger.Information("Werkkopie van {Count} verbindingen geladen.", WorkingConnections.Count);
        }

        private void AddConnection(ConnectionType type)
        {
            ConnectionConfigBase newConnection = null;
            switch (type)
            {
                case ConnectionType.OpcUa:
                    newConnection = new OpcUaConnectionConfig(); 
                    _logger.Information("Nieuwe OPC UA verbinding toegevoegd aan werkkopie.");
                    break;
                case ConnectionType.ModbusTcp:
                    newConnection = new ModbusTcpConnectionConfig(); 
                    _logger.Information("Nieuwe Modbus TCP verbinding toegevoegd aan werkkopie.");
                    break;
                default:
                    _logger.Warning("Onbekend verbindingstype gevraagd: {Type}", type);
                    return;
            }
            WorkingConnections.Add(newConnection);
            SelectedConnection = newConnection; 
        }

        private void RemoveSelectedConnection()
        {
            if (SelectedConnection != null)
            {
                _logger.Information("Verbinding '{ConnectionName}' verwijderd uit werkkopie.", SelectedConnection.ConnectionName);
                WorkingConnections.Remove(SelectedConnection);
                SelectedConnection = null;
            }
        }

        private void SaveSettingsAndClose()
        {
            _logger.Information("Instellingen opslaan vanuit SettingsViewModel...");
            _statusService.SetStatus(Enums.ApplicationStatus.Saving, "Bezig met opslaan van gewijzigde instellingen...");

            
            _settingsService.CurrentSettings.Connections.Clear();
            foreach (var conn in WorkingConnections)
            {
                
                _settingsService.CurrentSettings.Connections.Add(conn);
            }

            _settingsService.SaveSettings(); 
            _logger.Information("Instellingen succesvol opgeslagen.");
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            _closeWindowAction(); 
        }

        private void CancelAndClose()
        {
            _logger.Information("Wijzigingen in instellingen geannuleerd.");
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Wijzigingen in instellingen geannuleerd.");
            _closeWindowAction(); 
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\TabViewModelBase.cs"
using Data_Logger.Core;
using Data_Logger.Models;

namespace Data_Logger.ViewModels
{
    public abstract class TabViewModelBase : ObservableObject
    {
        private string _displayName;
        
        private ConnectionConfigBase _connectionConfiguration;
        
        public ConnectionConfigBase ConnectionConfiguration
        {
            get => _connectionConfiguration;
            protected set => SetProperty(ref _connectionConfiguration, value);
        }

        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        protected TabViewModelBase(ConnectionConfigBase connectionConfig)
        {
            ConnectionConfiguration = connectionConfig;
            DisplayName = connectionConfig.ConnectionName;
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml"
<Window x:Class="Data_Logger.Views.BrowseOpcUaNodesView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:local="clr-namespace:Data_Logger.Views"
        mc:Ignorable="d"
        Title="BrowseOpcUaNodesView" Height="450" Width="800">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>   <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,5">
            <Button Content="Omhoog" Command="{Binding GoUpCommand}" MinWidth="70" Margin="0,0,10,0"/>
            <TextBlock Text="{Binding CurrentBrowsePathDisplay}" VerticalAlignment="Center" FontWeight="SemiBold" TextTrimming="CharacterEllipsis"/>
        </StackPanel>
        
        <ListView Grid.Row="1" x:Name="NodesListView"
                  ItemsSource="{Binding CurrentNodes}" 
                  SelectedItem="{Binding SelectedNodeInView}" 
                  SelectionMode="Single" Margin="0,0,0,5"
                  HorizontalContentAlignment="Stretch">
            <ListView.InputBindings>
                <MouseBinding MouseAction="LeftDoubleClick" Command="{Binding BrowseDeeperCommand}" CommandParameter="{Binding SelectedItem, ElementName=NodesListView}"/>
            </ListView.InputBindings>
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding NodeClass}" Value="Variable">
                            <Setter Property="FontWeight" Value="Bold"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="Naam" Width="*">
                        <GridViewColumn.CellTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="{Binding DisplayName}" />
                                </StackPanel>
                            </DataTemplate>
                        </GridViewColumn.CellTemplate>
                    </GridViewColumn>
                    <GridViewColumn Header="NodeClass" DisplayMemberBinding="{Binding NodeClass}" Width="100"/>
                    <GridViewColumn Header="NodeId" DisplayMemberBinding="{Binding NodeId}" Width="200"/>
                </GridView>
            </ListView.View>
        </ListView>
        
        <TextBlock Grid.Row="1" Text="Laden..." FontSize="16" HorizontalAlignment="Center" VerticalAlignment="Center"
                   Visibility="{Binding IsLoading, Converter={StaticResource BooleanToVisibilityConverter}}"/>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
            <Button Content="Selecteer" Command="{Binding SelectNodeCommand}" IsDefault="True" MinWidth="80" Margin="0,0,10,0"/>
            <Button Content="Annuleren" Command="{Binding CancelCommand}" IsCancel="True" MinWidth="80"/>
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class BrowseOpcUaNodesView : Window
    {
        public BrowseOpcUaNodesView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance vm:LogViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="600"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.LogView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <StackPanel
            Grid.Row="0"
            Margin="5"
            Orientation="Horizontal">
            <TextBlock
                Margin="0,0,5,0"
                Text="Filter Tekst:"
                VerticalAlignment="Center" />
            <TextBox
                Margin="0,0,10,0"
                Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}"
                VerticalAlignment="Center"
                Width="150" />
            <TextBlock
                Margin="0,0,5,0"
                Text="Niveau:"
                VerticalAlignment="Center" />
            <ComboBox
                ItemsSource="{Binding LogLevels}"
                Margin="0,0,10,0"
                SelectedValue="{Binding SelectedLogLevelFilter}"
                VerticalAlignment="Center"
                Width="100" />
            <Button
                Command="{Binding ClearLogsCommand}"
                Content="Wis Logs"
                VerticalAlignment="Center" />
        </StackPanel>

        <ListView
            AlternationCount="2"
            Grid.Row="1"
            ItemsSource="{Binding LogEntries}"
            Margin="5,0,5,5">
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding Level}" Value="Error">
                            <Setter Property="Background" Value="LightPink" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Fatal">
                            <Setter Property="Background" Value="Red" />
                            <Setter Property="Foreground" Value="White" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Warning">
                            <Setter Property="Background" Value="LightYellow" />
                        </DataTrigger>
                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                            <Setter Property="Background" Value="#EFEFEF" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn
                        DisplayMemberBinding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}"
                        Header="Tijd"
                        Width="150" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding LevelDisplay}"
                        Header="Niveau"
                        Width="80" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding RenderedMessage}"
                        Header="Bericht"
                        Width="Auto" />
                </GridView>
            </ListView.View>
        </ListView>
    </Grid>
</UserControl>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml.cs"
using System.Windows.Controls;

namespace Data_Logger.Views
{
    public partial class LogView : UserControl
    {
        public LogView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml"
<Window
    Height="600"
    Title="{Binding ApplicationTitle}"
    Width="800"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:views="clr-namespace:Data_Logger.Views"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Window.Resources>
        <DataTemplate DataType="{x:Type vm:OpcUaTabViewModel}">
            <views:OpcUaTabView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:ModbusTabViewModel}">
            <views:ModbusTabView />
        </DataTemplate>
    </Window.Resources>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="200" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <Menu Grid.Row="0">
            <MenuItem Header="_Bestand">
                <MenuItem Command="{Binding OpenSettingsCommand}" Header="_Instellingen..." />
                <Separator />
                <MenuItem Click="Afsluiten_Click" Header="_Afsluiten" />
            </MenuItem>
        </Menu>

        <TabControl
            Grid.Row="1"
            ItemsSource="{Binding ActiveTabs}"
            Margin="5"
            SelectedItem="{Binding SelectedTab}">
            <TabControl.ItemTemplate>
                <DataTemplate DataType="{x:Type vm:TabViewModelBase}">
                    <TextBlock Text="{Binding DisplayName}" />
                </DataTemplate>
            </TabControl.ItemTemplate>
        </TabControl>

        <GridSplitter
            Background="LightGray"
            Grid.Row="2"
            Height="5"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Center" />

        <GroupBox
            Grid.Row="3"
            Header="Applicatie Logs"
            Margin="5">
            <views:LogView DataContext="{Binding LogVm}" />
        </GroupBox>

        <StatusBar Grid.Row="4" Padding="5,2">
            <StatusBar.ItemsPanel>
                <ItemsPanelTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                    </Grid>
                </ItemsPanelTemplate>
            </StatusBar.ItemsPanel>
            <StatusBarItem Grid.Column="0">
                <Ellipse
                    Height="15"
                    Margin="0,0,5,0"
                    Width="15">
                    <Ellipse.Style>
                        <Style TargetType="Ellipse">
                            <Setter Property="Fill" Value="Gray" />
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Idle}">
                                    <Setter Property="Fill" Value="LightGray" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Connecting}">
                                    <Setter Property="Fill" Value="Orange" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Logging}">
                                    <Setter Property="Fill" Value="Green" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Warning}">
                                    <Setter Property="Fill" Value="Yellow" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Error}">
                                    <Setter Property="Fill" Value="Red" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Loading}">
                                    <Setter Property="Fill" Value="SkyBlue" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Saving}">
                                    <Setter Property="Fill" Value="Plum" />
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </Ellipse.Style>
                </Ellipse>
            </StatusBarItem>
            <StatusBarItem Grid.Column="1">
                <TextBlock Text="{Binding CurrentStatusMessage}" VerticalAlignment="Center" />
            </StatusBarItem>
        </StatusBar>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class MainWindow
    {
        public MainWindow()
        {
            InitializeComponent();
        }
        
        private void Afsluiten_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance Type=vm:ModbusTabViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="300"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.ModbusTabView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:converters="clr-namespace:Data_Logger.Converters"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:scottplot="http://schemas.scottplot.net/2008/xaml/presentation">
    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
        
        </UserControl.Resources>

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> <RowDefinition Height="200"/>  </Grid.RowDefinitions>
        
        <StackPanel Grid.Row="0" HorizontalAlignment="Left" Margin="0,0,0,10">
            <TextBlock Text="{Binding ModbusConfig.ConnectionName}" FontSize="18" FontWeight="Bold" ToolTip="Naam van de Modbus verbinding"/>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="IP: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.IpAddress}" ToolTip="IP Adres"/>
                <TextBlock Text=":" Margin="2,0,2,0"/>
                <TextBlock Text="{Binding ModbusConfig.Port}" Margin="0,0,10,0" ToolTip="Poortnummer"/>
                <TextBlock Text="Unit ID: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.UnitId}" ToolTip="Modbus Unit ID"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                <TextBlock Text="Status: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" />
                <TextBlock Text=" (Scan Interval: " Margin="5,0,0,0" FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.ScanIntervalSeconds}" />
                <TextBlock Text="s)" />
            </StackPanel>
        </StackPanel>

        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="100" Margin="0,0,5,0"/>
            <Button Content="Verbinding Verbreken" Command="{Binding DisconnectCommand}" MinWidth="100"/>
        </StackPanel>
        
        <DataGrid Grid.Row="2" 
                  ItemsSource="{Binding DataValues}"
                  AutoGenerateColumns="False" 
                  CanUserAddRows="False" 
                  IsReadOnly="True"
                  AlternationCount="2"
                  VerticalScrollBarVisibility="Auto"
                  HorizontalScrollBarVisibility="Auto">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Tijdstempel" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" Width="Auto" SortDirection="Descending"/>
                <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*"/>
                <DataGridTextColumn Header="Waarde" Binding="{Binding FormattedValue}" Width="Auto"/>
                <DataGridTextColumn Header="Kwaliteit" Width="Auto">
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True">
                                    <Setter Property="Foreground" Value="Green"/>
                                </DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                                    <Setter Property="Foreground" Value="Red"/>
                                    <Setter Property="FontWeight" Value="Bold"/>
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.CellStyle>
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Center"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True">
                                    <Setter Property="Text" Value="Goed"/>
                                </DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                                    <Setter Property="Text" Value="Slecht"/>
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
                </DataGrid.Columns>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/> <Style.Triggers>
                        <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                            <Setter Property="Background" Value="#FFF0F0"/> </DataTrigger>
                        <Trigger Property="AlternationIndex" Value="1">
                            <Setter Property="Background" Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}"/>
                             </Trigger>
                         <Trigger Property="AlternationIndex" Value="0">
                            <Setter Property="Background" Value="{DynamicResource {x:Static SystemColors.WindowBrushKey}}"/>
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>
        </DataGrid>
        
        <GridSplitter Grid.Row="3" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray" ShowsPreview="True"/>
        
        <Grid Grid.Row="4">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    </Grid.RowDefinitions>
            
            <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,5,0,5">
                <TextBlock Text="Plot Tag:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                <ComboBox ItemsSource="{Binding AvailableTagNamesForPlotting}" 
                          SelectedItem="{Binding SelectedTagNameForPlotting}"
                          MinWidth="200" VerticalAlignment="Center"/>
            </StackPanel>

            <scottplot:WpfPlot Grid.Row="1" x:Name="DataPlot" Margin="0,5,0,0"/>
        </Grid>
    </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml.cs"
using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using Data_Logger.ViewModels;
using ScottPlot;

namespace Data_Logger.Views
{
    public partial class ModbusTabView : UserControl
    {
        private ModbusTabViewModel _viewModel;
        

        public ModbusTabView()
        {
            InitializeComponent();
            this.Loaded += ModbusTabView_Loaded;
            this.Unloaded += ModbusTabView_Unloaded;
            this.DataContextChanged += ModbusTabView_DataContextChanged;
        }

        private void ModbusTabView_Loaded(object sender, RoutedEventArgs e)
        {
            if (this.DataContext is ModbusTabViewModel vm && _viewModel == null)
            {
                InitializeViewModel(vm);
            }
        }

        private void ModbusTabView_DataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            if (e.OldValue is ModbusTabViewModel oldVm)
            {
                oldVm.PlotDataUpdated -= ViewModel_PlotDataUpdated;
                
            }
            if (e.NewValue is ModbusTabViewModel newVm)
            {
                InitializeViewModel(newVm);
            }
        }
        
        private void InitializeViewModel(ModbusTabViewModel vm)
        {
            _viewModel = vm;
            if (_viewModel != null)
            {
                _viewModel.PlotDataUpdated += ViewModel_PlotDataUpdated;
            }
            
            InitializePlotAppearance();
            RenderPlot(); 
        }

        private void ModbusTabView_Unloaded(object sender, RoutedEventArgs e)
        {
            if (_viewModel != null)
            {
                _viewModel.PlotDataUpdated -= ViewModel_PlotDataUpdated;
            }
            
            _viewModel = null; 
        }

        private void ViewModel_PlotDataUpdated(object sender, EventArgs e)
        {
            Dispatcher.BeginInvoke(new Action(RenderPlot));
        }

        

        private void InitializePlotAppearance() 
        {
            if (DataPlot == null || DataPlot.Plot == null) return;
            DataPlot.Plot.Title("Tag Waarde over Tijd");
            DataPlot.Plot.Axes.Bottom.Label.Text = "Tijdstempel";
        }

        private void RenderPlot()
        {
            if (_viewModel == null || DataPlot == null || DataPlot.Plot == null)
            {
                return;
            }

            

            DataPlot.Plot.PlottableList.Clear(); 
            DataPlot.Plot.Axes.Left.Label.Text = $"Waarde ({_viewModel.SelectedTagNameForPlotting ?? "Selecteer Tag"})";

            if (_viewModel.PlotXData != null && _viewModel.PlotYData != null && _viewModel.PlotXData.Any())
            {
                DataPlot.Plot.Add.Scatter(xs: _viewModel.PlotXData, ys: _viewModel.PlotYData);
                DataPlot.Plot.Axes.DateTimeTicksBottom(); 
                
                
                DataPlot.Plot.Axes.AutoScale();
            }
            else
            {
                DataPlot.Plot.Axes.DateTimeTicksBottom(); 
                var nowOADate = DateTime.Now.ToOADate();
                DataPlot.Plot.Axes.SetLimitsX(nowOADate - TimeSpan.FromMinutes(1).TotalDays, nowOADate); 
                DataPlot.Plot.Axes.SetLimitsY(0, 1);
            }
            
            DataPlot.Refresh();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance Type=vm:OpcUaTabViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="300"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.OpcUaTabView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:local="clr-namespace:Data_Logger.Views"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid Background="AliceBlue">
        <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
            <TextBlock
                FontSize="20"
                FontWeight="Bold"
                Text="OPC UA Tab" />
            <TextBlock
                FontSize="16"
                Margin="0,10,0,0"
                Text="{Binding OpcUaConfig.ConnectionName}" />
            <TextBlock Margin="0,5,0,0" Text="{Binding OpcUaConfig.EndpointUrl}" />
        </StackPanel>
    </Grid>
</UserControl>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml.cs"
using System.Windows.Controls;

namespace Data_Logger.Views
{
    public partial class OpcUaTabView : UserControl
    {
        public OpcUaTabView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml"
<Window
    Height="500"
    MinHeight="400"
    MinWidth="600"
    Title="Instellingen"
    Width="800"
    WindowStartupLocation="CenterOwner"
    d:DataContext="{d:DesignInstance Type=vm:SettingsViewModel,
                                     IsDesignTimeCreatable=False}"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.SettingsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:System="clr-namespace:System;assembly=mscorlib"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:models="clr-namespace:Data_Logger.Models"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Window.Resources>
        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusRegisterTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusRegisterType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusDataTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusDataType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <DataTemplate DataType="{x:Type models:OpcUaConnectionConfig}">
            <StackPanel Margin="10">
                <TextBlock
                    FontWeight="Bold"
                    Margin="0,0,0,10"
                    Text="OPC UA Verbinding Details" />
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto" />
                        <RowDefinition Height="Auto" />
                        <RowDefinition Height="Auto" />
                        <RowDefinition Height="Auto" />
                    </Grid.RowDefinitions>

                    <Label
                        Content="Naam:"
                        Grid.Column="0"
                        Grid.Row="0"
                        VerticalAlignment="Center" />
                    <TextBox
                        Grid.Column="1"
                        Grid.Row="0"
                        Margin="5"
                        Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" />

                    <Label
                        Content="Endpoint URL:"
                        Grid.Column="0"
                        Grid.Row="1"
                        VerticalAlignment="Center" />
                    <TextBox
                        Grid.Column="1"
                        Grid.Row="1"
                        Margin="5"
                        Text="{Binding EndpointUrl, UpdateSourceTrigger=PropertyChanged}" />

                    <Label
                        Content="Scan Interval (sec):"
                        Grid.Column="0"
                        Grid.Row="2"
                        VerticalAlignment="Center" />
                    <TextBox
                        Grid.Column="1"
                        Grid.Row="2"
                        Margin="5"
                        Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" />

                    <CheckBox
                        Content="Actief"
                        Grid.Column="1"
                        Grid.Row="3"
                        IsChecked="{Binding IsEnabled}"
                        Margin="5"
                        VerticalAlignment="Center" />
                </Grid>
            </StackPanel>
        </DataTemplate>

        <DataTemplate DataType="{x:Type models:ModbusTcpConnectionConfig}">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel Margin="10">
                    <TextBlock
                        FontWeight="Bold"
                        Margin="0,0,0,10"
                        Text="Modbus TCP Verbinding Details" />
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition MinWidth="150" Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>

                        <Label
                            Content="Naam:"
                            Grid.Column="0"
                            Grid.Row="0"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="0"
                            Margin="5"
                            Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="IP Adres:"
                            Grid.Column="0"
                            Grid.Row="1"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="1"
                            Margin="5"
                            Text="{Binding IpAddress, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Poort:"
                            Grid.Column="0"
                            Grid.Row="2"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="2"
                            Margin="5"
                            Text="{Binding Port, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Unit ID:"
                            Grid.Column="0"
                            Grid.Row="3"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="3"
                            Margin="5"
                            Text="{Binding UnitId, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Scan Interval (sec):"
                            Grid.Column="0"
                            Grid.Row="4"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="4"
                            Margin="5"
                            Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" />

                        <CheckBox
                            Content="Actief"
                            Grid.Column="1"
                            Grid.Row="5"
                            IsChecked="{Binding IsEnabled}"
                            Margin="5"
                            VerticalAlignment="Center" />
                    </Grid>
                    <GroupBox Header="Te Monitoren Tags" Margin="0,15,0,0">
                        <StackPanel>
                            <DataGrid
                                AutoGenerateColumns="False"
                                CanUserAddRows="True"
                                CanUserDeleteRows="True"
                                ItemsSource="{Binding TagsToMonitor}"
                                Margin="5"
                                MaxHeight="300"
                                MinHeight="150">
                                <DataGrid.Columns>
                                    <DataGridTextColumn
                                        Binding="{Binding TagName, UpdateSourceTrigger=PropertyChanged}"
                                        Header="Tag Naam"
                                        Width="*" />
                                    <DataGridTextColumn
                                        Binding="{Binding Address, UpdateSourceTrigger=PropertyChanged}"
                                        Header="Adres"
                                        Width="Auto" />

                                    <DataGridComboBoxColumn
                                        Header="Register Type"
                                        SelectedItemBinding="{Binding RegisterType, UpdateSourceTrigger=PropertyChanged}"
                                        Width="*">
                                        <DataGridComboBoxColumn.ElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusRegisterTypeEnumValues}}" />
                                            </Style>
                                        </DataGridComboBoxColumn.ElementStyle>
                                        <DataGridComboBoxColumn.EditingElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusRegisterTypeEnumValues}}" />
                                            </Style>
                                        </DataGridComboBoxColumn.EditingElementStyle>
                                    </DataGridComboBoxColumn>

                                    <DataGridComboBoxColumn
                                        Header="Data Type"
                                        SelectedItemBinding="{Binding DataType, UpdateSourceTrigger=PropertyChanged}"
                                        Width="*">
                                        <DataGridComboBoxColumn.ElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusDataTypeEnumValues}}" />
                                                <Setter Property="IsEnabled" Value="{Binding IsDataTypeSelectionEnabled}" />
                                            </Style>
                                        </DataGridComboBoxColumn.ElementStyle>
                                        <DataGridComboBoxColumn.EditingElementStyle>
                                            <Style TargetType="ComboBox">
                                                <Setter Property="ItemsSource" Value="{Binding Source={StaticResource ModbusDataTypeEnumValues}}" />
                                                <Setter Property="IsEnabled" Value="{Binding IsDataTypeSelectionEnabled}" />
                                            </Style>
                                        </DataGridComboBoxColumn.EditingElementStyle>
                                    </DataGridComboBoxColumn>

                                    <DataGridCheckBoxColumn
                                        Binding="{Binding IsActive, UpdateSourceTrigger=PropertyChanged}"
                                        Header="Actief"
                                        Width="Auto" />
                                </DataGrid.Columns>
                            </DataGrid>
                        </StackPanel>
                    </GroupBox>
                </StackPanel>
            </ScrollViewer>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition MinWidth="200" Width="250" />
            <ColumnDefinition Width="5" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <ToolBar
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="0"
            Padding="5">
            <Button
                Command="{Binding AddOpcUaConnectionCommand}"
                Content="Nieuwe OPC UA"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding AddModbusTcpConnectionCommand}"
                Content="Nieuwe Modbus TCP"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding RemoveConnectionCommand}"
                Content="Verwijder Geselecteerde"
                Foreground="Red" />
        </ToolBar>

        <GroupBox
            Grid.Column="0"
            Grid.Row="1"
            Header="Verbindingen"
            Margin="5">
            <ListView
                DisplayMemberPath="ConnectionName"
                ItemsSource="{Binding WorkingConnections}"
                SelectedItem="{Binding SelectedConnection}" />
        </GroupBox>

        <GridSplitter
            Background="LightGray"
            Grid.Column="1"
            Grid.Row="1"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Stretch"
            Width="5" />

        <GroupBox
            Grid.Column="2"
            Grid.Row="1"
            Header="Details"
            Margin="5">
            <ContentControl Content="{Binding SelectedConnection}" />
        </GroupBox>

        <StackPanel
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="2"
            HorizontalAlignment="Right"
            Margin="10"
            Orientation="Horizontal">
            <Button
                Command="{Binding SaveCommand}"
                Content="Opslaan"
                IsDefault="True"
                Margin="0,0,10,0"
                MinWidth="80" />
            <Button
                Command="{Binding CancelCommand}"
                Content="Annuleren"
                IsCancel="True"
                MinWidth="80" />
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class SettingsView : Window
    {
        public SettingsView()
        {
            InitializeComponent();
        }
    }
}



