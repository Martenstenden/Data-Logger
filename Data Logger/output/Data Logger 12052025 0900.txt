// Basis map repository: "C:\Development\Projects\Afstudeeropdracht\Data Logger"
// Script uitgevoerd op: "05/12/2025 08:55:41"
// Inclusie relatieve mappen: Converters, Models, Services, ViewModels, Windows, Assets, Config, Core, Enums, Views, Opc.Ua.Client, .
// Exclusie subpad patronen (-like): \bin\, \obj\, \packages\, \.idea\, \.vs\, \.git\, \output\
// Bestanden verder gefilterd op toegestane extensies en bestandsnamen.

// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml"
<Application
    x:Class="Data_Logger.App"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:converters1="clr-namespace:Data_Logger.Converters"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Application.Resources>
        <converters1:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" xmlns:converters="clr-namespace:Data_Logger.Converters" />
    </Application.Resources>
</Application>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\App.xaml.cs"
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Threading.Tasks;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services;
using Data_Logger.Services.Abstractions;
using Data_Logger.Services.Implementations;
using Data_Logger.ViewModels;
using Data_Logger.Views;
using Microsoft.Extensions.DependencyInjection;
using Opc.Ua;
using Opc.Ua.Configuration;
using Serilog;

namespace Data_Logger
{
    public partial class App
    {
        public IServiceProvider ServiceProvider { get; private set; }

        private ILoggingHostService _theActualLoggingHostService;

        private ApplicationConfiguration _opcUaAppConfig;

        public App()
        {
            _theActualLoggingHostService = new LoggingHostService();

            string logsDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Logs");
            if (!Directory.Exists(logsDirectory))
                Directory.CreateDirectory(logsDirectory);
            string logFilePath = Path.Combine(logsDirectory, "DataLoggerApp_.log");

            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.Console()
                .WriteTo.File(
                    logFilePath,
                    rollingInterval: RollingInterval.Day,
                    retainedFileCountLimit: 7,
                    outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
                )
                .WriteTo.Sink(new UiLogSink(_theActualLoggingHostService))
                .CreateLogger();

            _opcUaAppConfig = CreateOpcUaApplicationConfiguration();

            var serviceCollection = new ServiceCollection();
            ConfigureServices(serviceCollection);
            ServiceProvider = serviceCollection.BuildServiceProvider();

            var loggerFromDI = ServiceProvider.GetService<ILogger>();
            loggerFromDI?.Information(
                "Applicatie initialisatie voltooid in App constructor (ServiceProvider is gebouwd)."
            );
        }

        private void ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton<ILogger>(Log.Logger);
            services.AddSingleton<ILoggingHostService>(_theActualLoggingHostService);

            services.AddSingleton<IStatusService, StatusService>();
            services.AddSingleton<ISettingsService, SettingsService>();
            services.AddSingleton<IDataLoggingService, DataLoggingService>();

            services.AddSingleton<ApplicationConfiguration>(_opcUaAppConfig);

            services.AddSingleton<LogViewModel>(serviceProvider => new LogViewModel(
                serviceProvider.GetRequiredService<ILoggingHostService>(),
                serviceProvider.GetRequiredService<ILogger>()
            ));

            services.AddTransient<Func<ModbusTcpConnectionConfig, IModbusService>>(
                serviceProvider =>
                    config => new ModbusService(
                        serviceProvider.GetRequiredService<ILogger>(),
                        config
                    )
            );

            services.AddTransient<Func<OpcUaConnectionConfig, IOpcUaService>>(serviceProvider =>
                config => new OpcUaService(
                    serviceProvider.GetRequiredService<ILogger>(),
                    config,
                    serviceProvider.GetRequiredService<ApplicationConfiguration>()
                )
            );

            services.AddSingleton<MainViewModel>(serviceProvider => new MainViewModel(
                serviceProvider.GetRequiredService<ILogger>(),
                serviceProvider.GetRequiredService<LogViewModel>(),
                serviceProvider.GetRequiredService<IStatusService>(),
                serviceProvider.GetRequiredService<ISettingsService>(),
                serviceProvider.GetRequiredService<Func<Action, SettingsViewModel>>(),
                serviceProvider.GetRequiredService<
                    Func<ModbusTcpConnectionConfig, IModbusService>
                >(),
                serviceProvider.GetRequiredService<Func<OpcUaConnectionConfig, IOpcUaService>>(),
                serviceProvider.GetRequiredService<IDataLoggingService>()
            ));

            services.AddTransient<Func<Action, SettingsViewModel>>(serviceProvider =>
                closeAction => new SettingsViewModel(
                    serviceProvider.GetRequiredService<ISettingsService>(),
                    serviceProvider.GetRequiredService<IStatusService>(),
                    serviceProvider.GetRequiredService<ILogger>(),
                    closeAction
                )
            );
        }

        protected override void OnStartup(StartupEventArgs e)
        {
            Log.Information("App.OnStartup: Begin van OnStartup.");

            var mainWindow = new MainWindow
            {
                DataContext = ServiceProvider.GetRequiredService<MainViewModel>(),
            };
            mainWindow.Show();

            Log.Debug("App.OnStartup: MainWindow getoond.");

            base.OnStartup(e);
        }

        private ApplicationConfiguration CreateOpcUaApplicationConfiguration()
        {
            var localLogger = Serilog.Log.Logger.ForContext<App>();

            string applicationName = "DataLogger";
            string hostName = Dns.GetHostName();

            string executableLocation = Assembly.GetExecutingAssembly().Location;
            string applicationDirectory = Path.GetDirectoryName(executableLocation);

            string certStoresBasePath = Path.Combine(applicationDirectory, "CertificateStores");
            string ownCertStorePath = Path.Combine(certStoresBasePath, "own");
            string trustedPeersStorePath = Path.Combine(certStoresBasePath, "trusted", "certs");
            string trustedIssuerStorePath = Path.Combine(certStoresBasePath, "issuer", "certs");
            string rejectedCertStorePath = Path.Combine(certStoresBasePath, "rejected", "certs");

            string trustedPeersCrlPath = Path.Combine(certStoresBasePath, "trusted", "crl");
            string trustedIssuerCrlPath = Path.Combine(certStoresBasePath, "issuer", "crl");

            localLogger.Information(
                "OPC UA Client Cert Store Base Path: {Path}",
                certStoresBasePath
            );

            var config = new ApplicationConfiguration
            {
                ApplicationName = applicationName,
                ApplicationUri = Utils.Format(@"urn:{0}:{1}", hostName, applicationName),
                ApplicationType = ApplicationType.Client,
                ProductUri = "urn:DataLogger:OpcUaClient",
                SecurityConfiguration = new SecurityConfiguration
                {
                    ApplicationCertificate = new CertificateIdentifier
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = ownCertStorePath,
                        SubjectName = Utils.Format(@"CN={0}, DC={1}", applicationName, hostName),
                    },
                    TrustedIssuerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = trustedIssuerStorePath,
                    },
                    TrustedPeerCertificates = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = trustedPeersStorePath,
                    },
                    RejectedCertificateStore = new CertificateTrustList
                    {
                        StoreType = CertificateStoreType.Directory,
                        StorePath = rejectedCertStorePath,
                    },
                    AutoAcceptUntrustedCertificates = true,
                    AddAppCertToTrustedStore = true,
                    RejectSHA1SignedCertificates = false,
                    MinimumCertificateKeySize = 2048,
                },
                TransportConfigurations = new TransportConfigurationCollection(),
                TransportQuotas = new TransportQuotas { OperationTimeout = 15000 },
                ClientConfiguration = new ClientConfiguration { DefaultSessionTimeout = 60000 },
                TraceConfiguration = new TraceConfiguration
                {
                    OutputFilePath = Path.Combine(
                        applicationDirectory,
                        "Logs",
                        $"{applicationName}.OpcUaClient.log.txt"
                    ),
                    DeleteOnLoad = true,
                    TraceMasks =
                        Utils.TraceMasks.Error
                        | Utils.TraceMasks.Security
                        | Utils.TraceMasks.StackTrace,
                },
            };
            config.Validate(ApplicationType.Client).GetAwaiter().GetResult();

            if (config.SecurityConfiguration.AutoAcceptUntrustedCertificates)
            {
                config.CertificateValidator.CertificateValidation += (s, e) =>
                {
                    e.Accept = (e.Error.StatusCode == StatusCodes.BadCertificateUntrusted);
                };
            }

            var application = new ApplicationInstance
            {
                ApplicationName = "DataLogger",
                ApplicationType = ApplicationType.Client,
                ApplicationConfiguration = config,
            };

            application.CheckApplicationInstanceCertificates(false, 24).GetAwaiter().GetResult();

            return config;
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Log.CloseAndFlush();
            base.OnExit(e);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\BooleanToConnectionStatusConverter.cs"
using System;
using System.Globalization;
using System.Windows.Data;

namespace Data_Logger.Converters
{
    public class BooleanToConnectionStatusConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isConnected)
            {
                return isConnected ? "Verbonden" : "Niet Verbonden";
            }
            return "Onbekend";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Converters\BooleanToForwardBackwardConverter.cs"
using System;
using System.Globalization;
using System.Windows.Data;

namespace Data_Logger.Converters;

public class BooleanToForwardBackwardConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool isForward)
        {
            return isForward ? "Forward" : "Inverse";
        }
        return string.Empty;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\ObservableObject.cs"
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Data_Logger.Core
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Core\RelayCommand.cs"
using System;
using System.Windows.Input;

namespace Data_Logger.Core
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;
        
        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }
        
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
        
        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ApplicationStatus.cs"
namespace Data_Logger.Enums
{
    public enum ApplicationStatus
    {
        Idle,        
        Connecting,  
        Logging,     
        Warning,     
        Error,       
        Loading,     
        Saving       
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ConnectionType.cs"
namespace Data_Logger.Enums
{
    public enum ConnectionType
    {
        OpcUa,
        ModbusTcp
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusDataType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusDataType
    {
        Boolean,

        Int16,
        UInt16,

        Int32,
        UInt32,
        Float32,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\ModbusRegisterType.cs"
namespace Data_Logger.Enums
{
    public enum ModbusRegisterType
    {
        HoldingRegister,  
        InputRegister,    
        Coil,             
        DiscreteInput     
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Enums\OpcUaDataType.cs"
namespace Data_Logger.Enums
{
    public enum OpcUaDataType
    {
        Variant,
        Boolean,
        SByte,
        Byte,
        Int16,
        UInt16,
        Int32,
        UInt32,
        Int64,
        UInt64,
        Float,
        Double,
        String,
        DateTime,
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\AppSettings.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;

namespace Data_Logger.Models
{
    public class AppSettings : ObservableObject
    {
        private ObservableCollection<ConnectionConfigBase> _connections;

        public ObservableCollection<ConnectionConfigBase> Connections
        {
            get => _connections;
            set => SetProperty(ref _connections, value);
        }

        public AppSettings()
        {
            Connections = new ObservableCollection<ConnectionConfigBase>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ConnectionConfigBase.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public abstract class ConnectionConfigBase : ObservableObject
    {
        private string _connectionName;
        private ConnectionType _type;
        private bool _isEnabled = true;
        private int _scanIntervalSeconds = 5;

        public string ConnectionName
        {
            get => _connectionName;
            set => SetProperty(ref _connectionName, value);
        }

        public ConnectionType Type
        {
            get => _type;
            protected set => SetProperty(ref _type, value);
        }

        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        public int ScanIntervalSeconds
        {
            get => _scanIntervalSeconds;
            set => SetProperty(ref _scanIntervalSeconds, value);
        }

        protected ConnectionConfigBase(ConnectionType type)
        {
            Type = type;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\LoggedTagValue.cs"
using System;
using Data_Logger.Core;

namespace Data_Logger.Models
{
    public class LoggedTagValue : ObservableObject 
    {
        private string _tagName;
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private object _value;
        public object Value
        {
            get => _value;
            set
            {
                if (SetProperty(ref _value, value))
                {
                    OnPropertyChanged(nameof(FormattedValue));
                }
            }
        }

        private DateTime _timestamp;
        public DateTime Timestamp
        {
            get => _timestamp;
            set => SetProperty(ref _timestamp, value);
        }

        private bool _isGoodQuality = true;
        public bool IsGoodQuality
        {
            get => _isGoodQuality;
            set
            {
                if (SetProperty(ref _isGoodQuality, value))
                {
                    OnPropertyChanged(nameof(FormattedValue)); 
                }
            }
        }

        private string _errorMessage;
        public string ErrorMessage
        {
            get => _errorMessage;
            set
            {
                if (SetProperty(ref _errorMessage, value))
                {
                    OnPropertyChanged(nameof(FormattedValue));
                }
            }
        }
        
        public string FormattedValue
        {
            get
            {
                if (!IsGoodQuality)
                    return ErrorMessage ?? "Error";
                return Value?.ToString() ?? "N/A";
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTagConfig.cs"
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private ushort _address;
        public ushort Address
        {
            get => _address;
            set => SetProperty(ref _address, value);
        }

        private ModbusRegisterType _registerType = ModbusRegisterType.HoldingRegister;
        public ModbusRegisterType RegisterType
        {
            get => _registerType;
            set
            {
                if (SetProperty(ref _registerType, value))
                {
                    if (
                        _registerType == ModbusRegisterType.Coil
                        || _registerType == ModbusRegisterType.DiscreteInput
                    )
                    {
                        DataType = ModbusDataType.Boolean;
                    }
                    OnPropertyChanged(nameof(IsDataTypeSelectionEnabled));
                }
            }
        }

        private ModbusDataType _dataType = ModbusDataType.UInt16;
        public ModbusDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        public bool IsDataTypeSelectionEnabled =>
            RegisterType != ModbusRegisterType.Coil
            && RegisterType != ModbusRegisterType.DiscreteInput;

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\ModbusTcpConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class ModbusTcpConnectionConfig : ConnectionConfigBase
    {
        private string _ipAddress = "127.0.0.1";
        private int _port = 502;
        private byte _unitId = 1;

        private ObservableCollection<ModbusTagConfig> _tagsToMonitor;
        public ObservableCollection<ModbusTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public string IpAddress
        {
            get => _ipAddress;
            set => SetProperty(ref _ipAddress, value);
        }

        public int Port
        {
            get => _port;
            set => SetProperty(ref _port, value);
        }

        public byte UnitId
        {
            get => _unitId;
            set => SetProperty(ref _unitId, value);
        }

        public ModbusTcpConnectionConfig()
            : base(ConnectionType.ModbusTcp)
        {
            ConnectionName = "Nieuwe Modbus TCP Verbinding";
            TagsToMonitor = new ObservableCollection<ModbusTagConfig>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaConnectionConfig.cs"
using System.Collections.ObjectModel;
using Data_Logger.Core;
using Data_Logger.Enums;
using Opc.Ua;

namespace Data_Logger.Models
{
    public class OpcUaConnectionConfig : ConnectionConfigBase
    {
        private string _endpointUrl = "opc.tcp://localhost:4840";
        public string EndpointUrl
        {
            get => _endpointUrl;
            set => SetProperty(ref _endpointUrl, value);
        }

        private MessageSecurityMode _securityMode = MessageSecurityMode.None;
        public MessageSecurityMode SecurityMode
        {
            get => _securityMode;
            set => SetProperty(ref _securityMode, value);
        }

        private string _securityPolicyUri = SecurityPolicies.None;
        public string SecurityPolicyUri
        {
            get => _securityPolicyUri;
            set => SetProperty(ref _securityPolicyUri, value);
        }

        private string _userName;
        public string UserName
        {
            get => _userName;
            set => SetProperty(ref _userName, value);
        }

        private string _password;
        public string Password
        {
            get => _password;
            set => SetProperty(ref _password, value);
        }

        private ObservableCollection<OpcUaTagConfig> _tagsToMonitor;
        public ObservableCollection<OpcUaTagConfig> TagsToMonitor
        {
            get => _tagsToMonitor;
            set => SetProperty(ref _tagsToMonitor, value);
        }

        public OpcUaConnectionConfig()
            : base(ConnectionType.OpcUa)
        {
            ConnectionName = "Nieuwe OPC UA Verbinding";
            TagsToMonitor = new ObservableCollection<OpcUaTagConfig>();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\OpcUaTagConfig.cs"
using System;
using Data_Logger.Core;
using Data_Logger.Enums;

namespace Data_Logger.Models
{
    public class OpcUaTagConfig : ObservableObject
    {
        private string _tagName = "Nieuwe OPC UA Tag";
        public string TagName
        {
            get => _tagName;
            set => SetProperty(ref _tagName, value);
        }

        private string _nodeId = "ns=2;s=MyVariable";
        public string NodeId
        {
            get => _nodeId;
            set => SetProperty(ref _nodeId, value);
        }

        private OpcUaDataType _dataType = OpcUaDataType.Variant;
        public OpcUaDataType DataType
        {
            get => _dataType;
            set => SetProperty(ref _dataType, value);
        }

        private int _samplingInterval = 1000;
        public int SamplingInterval
        {
            get => _samplingInterval;
            set => SetProperty(ref _samplingInterval, value);
        }

        private bool _isActive = true;
        public bool IsActive
        {
            get => _isActive;
            set => SetProperty(ref _isActive, value);
        }
        
        private object _currentValue;
        public object CurrentValue 
        {
            get => _currentValue;
            set
            {
                if (SetProperty(ref _currentValue, value))
                {
                    OnPropertyChanged(nameof(FormattedLiveValue));
                }
            }
        }

        private DateTime _timestamp;
        public DateTime Timestamp
        {
            get => _timestamp;
            set => SetProperty(ref _timestamp, value);
        }

        private bool _isGoodQuality = true; 
        public bool IsGoodQuality
        {
            get => _isGoodQuality;
            set
            {
                if (SetProperty(ref _isGoodQuality, value))
                {
                    OnPropertyChanged(nameof(FormattedLiveValue));
                }
            }
        }

        private string _errorMessage;
        public string ErrorMessage
        {
            get => _errorMessage;
            set
            {
                if (SetProperty(ref _errorMessage, value))
                {
                    OnPropertyChanged(nameof(FormattedLiveValue));
                }
            }
        }

        public string FormattedLiveValue
        {
            get
            {
                if (!IsGoodQuality && !string.IsNullOrEmpty(ErrorMessage)) return ErrorMessage;
                if (!IsGoodQuality) return "Bad Quality";
                return CurrentValue?.ToString() ?? "N/A";
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Models\UiLogEntry.cs"
using System;
using Serilog.Events;

namespace Data_Logger.Models
{
    public class UiLogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogEventLevel Level { get; set; }
        public string LevelDisplay => Level.ToString();
        public string Message { get; set; }
        public string RenderedMessage { get; set; }
        public string Exception { get; set; }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\UiLogSink.cs"
using System;
using System.IO;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog.Core;
using Serilog.Events;

namespace Data_Logger.Services
{
    public class UiLogSink : ILogEventSink
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly IFormatProvider _formatProvider;
        private bool _instanceIdLoggedFromEmit = false;

        public UiLogSink(
            ILoggingHostService loggingHostService,
            IFormatProvider formatProvider = null
        )
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _formatProvider = formatProvider;

            Console.WriteLine(
                $"[DIAGNOSTIC] UiLogSink Constructor: Gebruikt LoggingHostService met InstanceId: {_loggingHostService.InstanceId}"
            );
        }

        public void Emit(LogEvent logEvent)
        {
            if (!_instanceIdLoggedFromEmit)
            {
                Console.WriteLine(
                    $"[DIAGNOSTIC] UiLogSink.Emit: Eerste aanroep met LoggingHostService InstanceId: {_loggingHostService.InstanceId}"
                );
                _instanceIdLoggedFromEmit = true;
            }

            if (logEvent == null)
                return;

            var renderedMessage = RenderLogEvent(logEvent);

            var uiEntry = new UiLogEntry
            {
                Timestamp = logEvent.Timestamp.DateTime.ToLocalTime(),
                Level = logEvent.Level,
                Message = logEvent.MessageTemplate.Text,
                RenderedMessage = renderedMessage,
                Exception = logEvent.Exception?.ToString(),
            };

            _loggingHostService.AddLogEntry(uiEntry);
        }

        private string RenderLogEvent(LogEvent logEvent)
        {
            var writer = new StringWriter();
            logEvent.RenderMessage(writer, _formatProvider);
            if (logEvent.Exception != null)
            {
                writer.WriteLine();
                writer.Write(logEvent.Exception.ToString());
            }
            return writer.ToString();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IDataLoggingService.cs"
using System.Collections.Generic;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface IDataLoggingService
    {
        void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ILoggingHostService.cs"
using System.Collections.ObjectModel;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ILoggingHostService
    {
        string InstanceId { get; }
        ObservableCollection<UiLogEntry> LogEntries { get; }
        void AddLogEntry(UiLogEntry entry);
        void ClearLogs();
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IModbusService.cs"
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public class ModbusDataPoint
    {
        public ushort Address { get; set; }
        public ushort Value { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public interface IModbusService : IDisposable
    {
        bool IsConnected { get; }
        event EventHandler ConnectionStatusChanged;
        event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        Task<bool> ConnectAsync();
        Task DisconnectAsync();
        Task PollConfiguredTagsAsync();
        void Reconfigure(ModbusTcpConnectionConfig newConfig);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IOpcUaService.cs"
using Data_Logger.Models;
using Data_Logger.ViewModels;
using Opc.Ua;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Data_Logger.Services.Abstractions
{
    public interface IOpcUaService : IDisposable
    {
        /// <summary>
        /// Geeft aan of er een actieve verbinding is met de OPC UA server.
        /// </summary>
        bool IsConnected { get; }

        /// <summary>
        /// De namespace tabel van de huidige actieve sessie.
        /// Is null als er geen actieve sessie is.
        /// </summary>
        NamespaceTable NamespaceUris { get; }

        /// <summary>
        /// Event dat wordt getriggerd wanneer de connectiestatus verandert.
        /// </summary>
        event EventHandler ConnectionStatusChanged;

        /// <summary>
        /// Event dat wordt getriggerd wanneer er nieuwe data van gemonitorde tags binnenkomt.
        /// </summary>
        event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        /// <summary>
        /// Maakt asynchroon verbinding met de OPC UA server op basis van de huidige configuratie.
        /// </summary>
        /// <returns>True als de verbinding succesvol is, anders false.</returns>
        Task<bool> ConnectAsync();

        /// <summary>
        /// Verbreekt asynchroon de verbinding met de OPC UA server.
        /// </summary>
        Task DisconnectAsync();

        /// <summary>
        /// Herconfigureert de service met nieuwe verbindings- en tag-instellingen.
        /// Als de service verbonden is en de endpoint details veranderen, wordt de verbinding herstart.
        /// Als alleen tags of monitoring parameters veranderen, wordt de subscription bijgewerkt.
        /// </summary>
        /// <param name="newConfig">De nieuwe OPC UA verbindingsconfiguratie.</param>
        void Reconfigure(OpcUaConnectionConfig newConfig);

        /// <summary>
        /// Start asynchroon het monitoren van de tags die geconfigureerd zijn in OpcUaConfig.TagsToMonitor
        /// en waarvoor IsActive true is. Vereist een actieve sessie.
        /// </summary>
        Task StartMonitoringTagsAsync();

        /// <summary>
        /// Stopt asynchroon het monitoren van tags en verwijdert de OPC UA subscription.
        /// </summary>
        Task StopMonitoringTagsAsync();

        /// <summary>
        /// Leest asynchroon de huidige waarden van alle actief geconfigureerde tags.
        /// </summary>
        /// <returns>Een collectie van LoggedTagValue objecten met de gelezen waarden.</returns>
        Task<IEnumerable<LoggedTagValue>> ReadCurrentTagValuesAsync();

        /// <summary>
        /// Browset asynchroon de children van een gegeven NodeId.
        /// </summary>
        /// <param name="nodeIdToBrowse">De NodeId waarvan de children gebrowset moeten worden.</param>
        /// <param name="referenceTypeId">Optioneel: Het type referentie om te volgen (default: HierarchicalReferences).</param>
        /// <param name="includeSubtypes">Optioneel: Of subtypes van de referenceTypeId meegenomen moeten worden (default: true).</param>
        /// <param name="direction">Optioneel: De browse richting (default: Forward).</param>
        /// <param name="nodeClassMask">Optioneel: Filter op NodeClass van de target nodes (default: Unspecified).</param>
        /// <param name="ct">Optioneel: CancellationToken.</param>
        /// <returns>Een collectie van ReferenceDescription objecten die de gevonden referenties representeren.</returns>
        Task<ReferenceDescriptionCollection> BrowseAsync(
            NodeId nodeIdToBrowse,
            NodeId referenceTypeId = null,
            bool includeSubtypes = true,
            BrowseDirection direction = BrowseDirection.Forward,
            NodeClass nodeClassMask = NodeClass.Unspecified,
            CancellationToken ct = default
        );

        /// <summary>
        /// Browset asynchroon de "root" van de OPC UA server (meestal de ObjectsFolder).
        /// </summary>
        /// <returns>Een collectie van ReferenceDescription objecten.</returns>
        Task<ReferenceDescriptionCollection> BrowseRootAsync();

        /// <summary>
        /// Leest asynchroon de waarde van een enkele NodeId.
        /// </summary>
        /// <param name="nodeId">De NodeId waarvan de waarde gelezen moet worden.</param>
        /// <returns>Een DataValue object met de waarde, status en timestamps.</returns>
        Task<DataValue> ReadValueAsync(NodeId nodeId);

        /// <summary>
        /// Leest asynchroon een lijst van standaard attributen voor een gegeven NodeId.
        /// </summary>
        /// <param name="nodeId">De NodeId waarvan de attributen gelezen moeten worden.</param>
        /// <returns>Een lijst van NodeAttributeViewModel objecten.</returns>
        Task<List<NodeAttributeViewModel>> ReadNodeAttributesAsync(NodeId nodeId);
        
        Task<ReferenceDescriptionCollection> BrowseAllReferencesAsync(NodeId nodeIdToBrowse, BrowseDirection direction = BrowseDirection.Both);

        /// <summary>
        /// Leest asynchroon de DisplayName van een gegeven NodeId.
        /// </summary>
        /// <param name="nodeId">De NodeId waarvan de DisplayName gelezen moet worden.</param>
        /// <returns>Een LocalizedText object met de DisplayName, of null bij een fout.</returns>
        Task<LocalizedText> ReadNodeDisplayNameAsync(NodeId nodeId);
        
        /// <summary>
        /// Parset een NodeId string naar een Opc.Ua.NodeId object, gebruikmakend van de huidige sessiecontext.
        /// </summary>
        /// <param name="nodeIdString">De NodeId string om te parsen.</param>
        /// <returns>Een Opc.Ua.NodeId object.</returns>
        /// <exception cref="ServiceResultException">Als de string ongeldig is of parsen mislukt.</exception>
        NodeId ParseNodeId(string nodeIdString);
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\ISettingsService.cs"
using Data_Logger.Models;

namespace Data_Logger.Services.Abstractions
{
    public interface ISettingsService
    {
        AppSettings CurrentSettings { get; }
        void LoadSettings();
        void SaveSettings();
        void LoadDefaultSettings();
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Abstractions\IStatusService.cs"
using Data_Logger.Enums;

namespace Data_Logger.Services.Abstractions
{
    public interface IStatusService
    {
        ApplicationStatus CurrentStatus { get; }
        string StatusMessage { get; }
        void SetStatus(ApplicationStatus status, string message);
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\DataLoggingService.cs"
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class DataLoggingService : IDataLoggingService
    {
        private readonly ILogger _logger;
        private readonly string _baseLogDirectory;
        private readonly object _fileLock = new object();

        public DataLoggingService(ILogger logger)
        {
            _logger = logger.ForContext<DataLoggingService>();

            string executableLocation = Path.GetDirectoryName(
                System.Reflection.Assembly.GetExecutingAssembly().Location
            );
            _baseLogDirectory = Path.Combine(executableLocation, "LoggedData");

            try
            {
                if (!Directory.Exists(_baseLogDirectory))
                {
                    Directory.CreateDirectory(_baseLogDirectory);
                    _logger.Information(
                        "CSV Log data map aangemaakt: {LogDirectory}",
                        _baseLogDirectory
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het aanmaken van de CSV log data map: {LogDirectory}",
                    _baseLogDirectory
                );
            }
        }

        public void LogTagValues(string connectionName, IEnumerable<LoggedTagValue> tagValues)
        {
            if (tagValues == null || !tagValues.Any())
            {
                return;
            }

            string sanitizedConnectionName = SanitizeFileName(connectionName);
            string fileName = $"{sanitizedConnectionName}_{DateTime.Now:yyyyMMdd}.csv";
            string filePath = Path.Combine(_baseLogDirectory, fileName);

            StringBuilder csvBuilder = new StringBuilder();
            bool fileExistsAndHasContent =
                File.Exists(filePath) && new FileInfo(filePath).Length > 0;

            if (!fileExistsAndHasContent)
            {
                csvBuilder.AppendLine("Timestamp,TagName,Value,IsGoodQuality,ErrorMessage");
            }

            foreach (var tagValue in tagValues)
            {
                string safeTagName = EscapeCsvField(tagValue.TagName);
                string safeValue = EscapeCsvField(tagValue.Value?.ToString() ?? string.Empty);
                string safeErrorMessage = EscapeCsvField(tagValue.ErrorMessage ?? string.Empty);

                csvBuilder.AppendFormat(
                    CultureInfo.InvariantCulture,
                    "{0},{1},{2},{3},{4}{5}",
                    tagValue.Timestamp.ToString(
                        "yyyy-MM-dd HH:mm:ss.fff",
                        CultureInfo.InvariantCulture
                    ),
                    safeTagName,
                    safeValue,
                    tagValue.IsGoodQuality,
                    safeErrorMessage,
                    Environment.NewLine
                );
            }

            string contentToWrite = csvBuilder.ToString();

            if (
                string.IsNullOrWhiteSpace(
                    contentToWrite
                        .Replace(
                            "Timestamp,TagName,Value,IsGoodQuality,ErrorMessage"
                                + Environment.NewLine,
                            ""
                        )
                        .Replace(Environment.NewLine, "")
                )
            )
            {
                if (!tagValues.Any() && !fileExistsAndHasContent)
                    return;
                if (
                    tagValues.Any()
                    && !fileExistsAndHasContent
                    && contentToWrite.StartsWith("Timestamp,TagName")
                )
                { /* Alleen header, wel schrijven als er data is */
                }
                else if (string.IsNullOrWhiteSpace(contentToWrite.Replace(Environment.NewLine, "")))
                {
                    return;
                }
            }

            try
            {
                lock (_fileLock)
                {
                    using (
                        FileStream stream = new FileStream(
                            filePath,
                            FileMode.Append,
                            FileAccess.Write,
                            FileShare.Read
                        )
                    )
                    using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8))
                    {
                        writer.Write(contentToWrite);
                    }
                }
                _logger.Debug(
                    "Data gelogd naar {FilePath} voor connectie {ConnectionName}. Aantal tags: {TagCount}",
                    filePath,
                    connectionName,
                    tagValues.Count()
                );
            }
            catch (IOException ioEx) when (IsFileLocked(ioEx))
            {
                _logger.Warning(
                    ioEx,
                    "CSV bestand {FilePath} is geblokkeerd (sharing violation/lock) tijdens poging tot schrijven. Data voor dit interval mogelijk niet gelogd.",
                    filePath
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout bij het wegschrijven van tag data naar CSV voor connectie {ConnectionName} naar bestand {FilePath}",
                    connectionName,
                    filePath
                );
            }
        }

        private bool IsFileLocked(IOException exception)
        {
            int errorCode = Marshal.GetHRForException(exception) & 0xFFFF;
            return errorCode == 32 || errorCode == 33;
        }

        private string SanitizeFileName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return "DefaultConnection";
            return Path.GetInvalidFileNameChars()
                .Aggregate(name, (current, c) => current.Replace(c.ToString(), string.Empty));
        }

        private string EscapeCsvField(string field)
        {
            if (string.IsNullOrEmpty(field))
                return string.Empty;
            if (
                field.Contains(",")
                || field.Contains("\"")
                || field.Contains("\r")
                || field.Contains("\n")
            )
            {
                return $"\"{field.Replace("\"", "\"\"")}\"";
            }
            return field;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\LoggingHostService.cs"
using System.Collections.ObjectModel;
using System.Threading;
using System.Windows;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;

namespace Data_Logger.Services.Implementations
{
    public class LoggingHostService : ILoggingHostService
    {
        public string InstanceId { get; }
        private static int _instanceCounter = 0;

        public ObservableCollection<UiLogEntry> LogEntries { get; }

        private const int MaxLogEntries = 1000;

        public LoggingHostService()
        {
            InstanceId = $"LHS_Instance_{Interlocked.Increment(ref _instanceCounter)}";

            LogEntries = new ObservableCollection<UiLogEntry>();
        }

        public void AddLogEntry(UiLogEntry entry)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (MaxLogEntries > 0 && LogEntries.Count >= MaxLogEntries)
                {
                    LogEntries.RemoveAt(LogEntries.Count - 1);
                }
                LogEntries.Insert(0, entry);
            });
        }

        public void ClearLogs()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                LogEntries.Clear();
            });
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\ModbusService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Modbus;
using Modbus.Device;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class ModbusService : IModbusService
    {
        private readonly ILogger _logger;
        private ModbusTcpConnectionConfig _config;
        private TcpClient _tcpClient;
        private ModbusIpMaster _master;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);

        private bool _isConnected;
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;

        public ModbusService(ILogger logger, ModbusTcpConnectionConfig config)
        {
            _logger = logger
                .ForContext<ModbusService>()
                .ForContext("ConnectionName", config.ConnectionName);
            _config = config;
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            _logger.Information(
                "Bezig met verbinden met Modbus server: {IpAddress}:{Port}",
                _config.IpAddress,
                _config.Port
            );
            try
            {
                _tcpClient = new TcpClient();
                Task connectTask = _tcpClient.ConnectAsync(_config.IpAddress, _config.Port);
                Task timeoutTask = Task.Delay(5000);

                Task completedTask = await Task.WhenAny(connectTask, timeoutTask);

                if (completedTask == connectTask)
                {
                    await connectTask;

                    if (_tcpClient.Connected)
                    {
                        _master = ModbusIpMaster.CreateIp(_tcpClient);
                        if (_master != null)
                        {
                            _master.Transport.ReadTimeout = 2000;
                            _master.Transport.WriteTimeout = 2000;
                            IsConnected = true;
                            _logger.Information("Succesvol verbonden met Modbus server.");
                            return true;
                        }
                        else
                        {
                            _logger.Error(
                                "Kon ModbusIpMaster niet aanmaken na succesvolle TCP verbinding."
                            );
                            _tcpClient?.Close();
                            _tcpClient = null;
                            IsConnected = false;
                            return false;
                        }
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon niet verbinden met Modbus server (ConnectAsync voltooid, maar niet verbonden). IP: {IpAddress}",
                            _config.IpAddress
                        );
                        _tcpClient?.Close();
                        _tcpClient = null;
                        IsConnected = false;
                        return false;
                    }
                }
                else
                {
                    _logger.Warning(
                        "Timeout ({Timeout}ms) tijdens verbinden met Modbus server: {IpAddress}:{Port}",
                        5000,
                        _config.IpAddress,
                        _config.Port
                    );

                    _tcpClient?.Close();
                    _tcpClient = null;
                    IsConnected = false;

                    return false;
                }
            }
            catch (SocketException sockEx)
            {
                _logger.Error(
                    sockEx,
                    "SocketException tijdens verbinden met Modbus server {IpAddress}:{Port}. Foutcode: {ErrorCode}",
                    _config.IpAddress,
                    _config.Port,
                    sockEx.SocketErrorCode
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout tijdens verbinden met Modbus server {IpAddress}:{Port}",
                    _config.IpAddress,
                    _config.Port
                );
                IsConnected = false;
                _tcpClient?.Close();
                _tcpClient = null;
                return false;
            }
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;
            _logger.Information("Verbinding met Modbus server verbreken...");
            await _semaphore.WaitAsync().ConfigureAwait(false);
            try
            {
                _logger.Debug("DisconnectAsync: Semaphore verkregen. Resources sluiten.");

                _master?.Dispose();
                _tcpClient?.Close();
                _tcpClient?.Dispose();

                _master = null;
                _tcpClient = null;
                IsConnected = false;
                _logger.Information("Verbinding met Modbus server daadwerkelijk verbroken.");
            }
            catch (Exception ex)
            {
                _logger.Warning(
                    ex,
                    "Fout tijdens daadwerkelijk sluiten van Modbus resources in DisconnectAsync."
                );

                _master = null;
                _tcpClient = null;
                IsConnected = false;
            }
            finally
            {
                _semaphore.Release();
                _logger.Debug("DisconnectAsync: Semaphore vrijgegeven.");
            }
        }

        public void Reconfigure(ModbusTcpConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));

            _logger.Information(
                "Herconfigureren van ModbusService {ConnectionName} met nieuwe instellingen. Oude scan interval: {OldInterval}, Nieuw: {NewInterval}. Aantal oude tags: {OldTagCount}, Nieuw: {NewTagCount}",
                _config.ConnectionName,
                _config.ScanIntervalSeconds,
                newConfig.ScanIntervalSeconds,
                _config.TagsToMonitor.Count,
                newConfig.TagsToMonitor.Count
            );

            _config = newConfig;
        }

        public async Task PollConfiguredTagsAsync()
        {
            if (!IsConnected || _master == null)
            {
                _logger.Warning("Kan geconfigureerde tags niet pollen, niet verbonden.");
                return;
            }

            var results = new List<LoggedTagValue>();
            var now = DateTime.Now;

            foreach (var tag in _config.TagsToMonitor.Where(t => t.IsActive))
            {
                var loggedTag = new LoggedTagValue { TagName = tag.TagName, Timestamp = now };
                await _semaphore.WaitAsync();
                try
                {
                    object value = null;
                    ushort numRegistersToRead = 1;
                    if (
                        tag.DataType == ModbusDataType.Int32
                        || tag.DataType == ModbusDataType.UInt32
                        || tag.DataType == ModbusDataType.Float32
                    )
                    {
                        numRegistersToRead = 2;
                    }

                    switch (tag.RegisterType)
                    {
                        case ModbusRegisterType.Coil:
                            bool[] coilValues = await _master.ReadCoilsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (coilValues != null && coilValues.Length > 0)
                                value = coilValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Coil mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.DiscreteInput:
                            bool[] discreteValues = await _master.ReadInputsAsync(
                                _config.UnitId,
                                tag.Address,
                                1
                            );
                            if (discreteValues != null && discreteValues.Length > 0)
                                value = discreteValues[0];
                            else
                                throw new InvalidOperationException(
                                    "Lezen van Discrete Input mislukt of gaf geen data."
                                );
                            break;

                        case ModbusRegisterType.HoldingRegister:
                            ushort[] holdingRegs = await _master.ReadHoldingRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (holdingRegs == null || holdingRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Holding Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(holdingRegs, tag.DataType);
                            break;

                        case ModbusRegisterType.InputRegister:
                            ushort[] inputRegs = await _master.ReadInputRegistersAsync(
                                _config.UnitId,
                                tag.Address,
                                numRegistersToRead
                            );
                            if (inputRegs == null || inputRegs.Length < numRegistersToRead)
                                throw new InvalidOperationException(
                                    "Lezen van Input Register mislukt of gaf onvoldoende data."
                                );
                            value = InterpretRegisterData(inputRegs, tag.DataType);
                            break;
                    }
                    loggedTag.Value = value;
                    loggedTag.IsGoodQuality = true;
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het lezen/interpreteren van Modbus tag: {TagName} (Adres: {Address}, Type: {RegisterType})",
                        tag.TagName,
                        tag.Address,
                        tag.RegisterType
                    );
                    loggedTag.IsGoodQuality = false;
                    loggedTag.ErrorMessage = ex.Message;
                }
                finally
                {
                    _semaphore.Release();
                }
                results.Add(loggedTag);
            }
            TagsDataReceived?.Invoke(this, results);
        }

        private object InterpretRegisterData(ushort[] registers, ModbusDataType dataType)
        {
            switch (dataType)
            {
                case ModbusDataType.Boolean:
                    return registers[0] != 0;
                case ModbusDataType.Int16:
                    return (short)registers[0];
                case ModbusDataType.UInt16:
                    return registers[0];

                case ModbusDataType.Int32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Int32.");

                    byte[] bytesInt32 = new byte[4];
                    bytesInt32[0] = (byte)(registers[0] >> 8);
                    bytesInt32[1] = (byte)(registers[0] & 0xFF);
                    bytesInt32[2] = (byte)(registers[1] >> 8);
                    bytesInt32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesInt32);
                    return BitConverter.ToInt32(bytesInt32, 0);

                case ModbusDataType.UInt32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor UInt32.");
                    byte[] bytesUInt32 = new byte[4];
                    bytesUInt32[0] = (byte)(registers[0] >> 8);
                    bytesUInt32[1] = (byte)registers[0];
                    bytesUInt32[2] = (byte)(registers[1] >> 8);
                    bytesUInt32[3] = (byte)registers[1];
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesUInt32);
                    return BitConverter.ToUInt32(bytesUInt32, 0);

                case ModbusDataType.Float32:
                    if (registers.Length < 2)
                        throw new ArgumentException("Onvoldoende registers voor Float32.");
                    byte[] bytesFloat32 = new byte[4];

                    bytesFloat32[0] = (byte)(registers[0] >> 8);
                    bytesFloat32[1] = (byte)(registers[0] & 0xFF);
                    bytesFloat32[2] = (byte)(registers[1] >> 8);
                    bytesFloat32[3] = (byte)(registers[1] & 0xFF);
                    if (BitConverter.IsLittleEndian)
                        Array.Reverse(bytesFloat32);
                    return BitConverter.ToSingle(bytesFloat32, 0);

                default:
                    _logger.Warning(
                        "Niet-ondersteund ModbusDataType voor interpretatie: {DataType}. Geeft ruwe ushort[0] terug.",
                        dataType
                    );
                    return registers[0];
            }
        }

        private bool _disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (disposing)
            {
                _logger.Debug(
                    "ModbusService.Dispose({Disposing}) aangeroepen voor {ConnectionName}",
                    disposing,
                    _config.ConnectionName
                );

                bool acquired = false;
                try
                {
                    acquired = _semaphore.Wait(1000);
                    if (acquired)
                    {
                        _logger.Debug(
                            "ModbusService.Dispose: Semaphore verkregen. Resources sluiten."
                        );
                        _master?.Dispose();
                        _tcpClient?.Close();
                        _tcpClient?.Dispose();
                    }
                    else
                    {
                        _logger.Warning(
                            "ModbusService.Dispose: Timeout bij wachten op semaphore. Resources worden mogelijk niet correct vrijgegeven door deze Dispose aanroep."
                        );
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "ModbusService.Dispose: Fout bij vrijgeven resources.");
                }
                finally
                {
                    if (acquired)
                        _semaphore.Release();
                }

                _master = null;
                _tcpClient = null;
                IsConnected = false;

                _semaphore?.Dispose();
            }
            _disposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\OpcUaService.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.ViewModels;
using Opc.Ua;
using Opc.Ua.Client;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class OpcUaService : IOpcUaService
    {
        #region Fields
        private readonly ILogger _logger;
        private OpcUaConnectionConfig _config;
        private Session _session;
        private Subscription _subscription;
        private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);
        private readonly ApplicationConfiguration _appConfig;
        private bool _isConnected;
        #endregion

        #region Properties
        public bool IsConnected
        {
            get => _isConnected;
            private set
            {
                if (_isConnected != value)
                {
                    _isConnected = value;
                    ConnectionStatusChanged?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        public NamespaceTable NamespaceUris => _session?.NamespaceUris;
        #endregion

        #region Events
        public event EventHandler ConnectionStatusChanged;
        public event EventHandler<IEnumerable<LoggedTagValue>> TagsDataReceived;
        #endregion

        #region Constructor
        public OpcUaService(
            ILogger logger,
            OpcUaConnectionConfig config,
            ApplicationConfiguration appConfig
        )
        {
            _logger =
                logger
                    ?.ForContext<OpcUaService>()
                    .ForContext(
                        "ConnectionName",
                        config?.ConnectionName ?? "UnknownOpcUaConnection"
                    ) ?? throw new ArgumentNullException(nameof(logger));
            _config = config ?? throw new ArgumentNullException(nameof(config));
            _appConfig = appConfig ?? throw new ArgumentNullException(nameof(appConfig));
            _logger.Debug(
                "OpcUaService geïnstantieerd voor {ConnectionName}",
                _config.ConnectionName
            );
        }
        #endregion

        #region Connection Management
        public async Task<bool> ConnectAsync()
        {
            if (IsConnected)
                return true;

            await _semaphore.WaitAsync();
            try
            {
                if (IsConnected)
                    return true;

                _logger.Information(
                    "Bezig met verbinden met OPC UA server: {EndpointUrl} voor connectie {ConnectionName}",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );

                EndpointDescription endpointDescription = null;
                EndpointDescriptionCollection serverEndpoints = null;

                try
                {
                    var discoveryEndpointConfiguration = EndpointConfiguration.Create(_appConfig);
                    discoveryEndpointConfiguration.OperationTimeout = 5000;

                    using (
                        var discoveryClient = DiscoveryClient.Create(
                            _appConfig,
                            new Uri(_config.EndpointUrl),
                            discoveryEndpointConfiguration
                        )
                    )
                    {
                        _logger.Information(
                            "Probeert endpoints op te halen van {DiscoveryUrl} voor {ConnectionName}",
                            discoveryClient.Endpoint.EndpointUrl,
                            _config.ConnectionName
                        );
                        serverEndpoints = await discoveryClient
                            .GetEndpointsAsync(null)
                            .ConfigureAwait(false);
                        _logger.Information(
                            "{Count} endpoints ontvangen van server {EndpointUrl} voor {ConnectionName}.",
                            serverEndpoints?.Count ?? 0,
                            _config.EndpointUrl,
                            _config.ConnectionName
                        );
                    }

                    if (serverEndpoints == null || serverEndpoints.Count == 0)
                    {
                        _logger.Error(
                            "Geen endpoints ontvangen van server via {EndpointUrl} voor {ConnectionName}",
                            _config.EndpointUrl,
                            _config.ConnectionName
                        );
                        return false;
                    }

                    endpointDescription = CoreClientUtils.SelectEndpoint(
                        _appConfig,
                        new Uri(_config.EndpointUrl),
                        serverEndpoints,
                        _config.SecurityMode != MessageSecurityMode.None
                    );
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het ophalen of selecteren van het OPC UA endpoint voor {EndpointUrl} (Conn: {ConnectionName})",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );
                    return false;
                }

                if (endpointDescription == null)
                {
                    _logger.Error(
                        "Geen geschikt OPC UA endpoint gevonden voor {EndpointUrl} (Conn: {ConnectionName}) met huidige security instellingen.",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );
                    return false;
                }

                _logger.Information(
                    "Geselecteerd endpoint voor {ConnectionName}: {SelectedEndpointUrl}, SecurityMode: {SecurityMode}, SecurityPolicy: {SecurityPolicy}",
                    _config.ConnectionName,
                    endpointDescription.EndpointUrl,
                    endpointDescription.SecurityMode,
                    endpointDescription.SecurityPolicyUri
                );

                bool userSpecifiedSecurity =
                    !string.IsNullOrEmpty(_config.SecurityPolicyUri)
                    && _config.SecurityPolicyUri != SecurityPolicies.None;
                if (
                    userSpecifiedSecurity
                    && (
                        endpointDescription.SecurityMode != _config.SecurityMode
                        || endpointDescription.SecurityPolicyUri != _config.SecurityPolicyUri
                    )
                )
                {
                    _logger.Information(
                        "Gebruiker heeft specifieke security policy ({UserPolicy}) en mode ({UserMode}) opgegeven voor {ConnectionName}.",
                        _config.SecurityPolicyUri,
                        _config.SecurityMode,
                        _config.ConnectionName
                    );
                    var matchingEndpoint = serverEndpoints.FirstOrDefault(ep =>
                        IsEndpointUrlMatch(ep.EndpointUrl, endpointDescription.EndpointUrl)
                        && ep.SecurityMode == _config.SecurityMode
                        && ep.SecurityPolicyUri == _config.SecurityPolicyUri
                    );
                    if (matchingEndpoint != null)
                    {
                        endpointDescription = matchingEndpoint;
                        _logger.Information(
                            "Endpoint voor {ConnectionName} succesvol aangepast aan gebruikersspecificatie: Policy {SecurityPolicy}, Mode {SecurityMode}",
                            _config.ConnectionName,
                            endpointDescription.SecurityPolicyUri,
                            endpointDescription.SecurityMode
                        );
                    }
                    else
                    {
                        _logger.Warning(
                            "Kon geen endpoint vinden voor {ConnectionName} dat exact overeenkomt met gespecificeerde SecurityMode '{UserMode}' en Policy '{UserPolicy}'. Valt terug op automatisch geselecteerd endpoint.",
                            _config.ConnectionName,
                            _config.SecurityMode,
                            _config.SecurityPolicyUri
                        );
                    }
                }

                var endpointConfiguration = EndpointConfiguration.Create(_appConfig);
                var configuredEndpoint = new ConfiguredEndpoint(
                    null,
                    endpointDescription,
                    endpointConfiguration
                );

                _session = await Session
                    .Create(
                        _appConfig,
                        configuredEndpoint,
                        updateBeforeConnect: false,
                        checkDomain: false,
                        sessionName: $"{_appConfig.ApplicationName} Session ({_config.ConnectionName})",
                        sessionTimeout: (uint)(
                            _appConfig.ClientConfiguration.DefaultSessionTimeout > 0
                                ? _appConfig.ClientConfiguration.DefaultSessionTimeout
                                : 60000
                        ),
                        identity: GetUserIdentity(),
                        preferredLocales: null
                    )
                    .ConfigureAwait(false);

                if (_session == null)
                {
                    _logger.Error(
                        "Kon geen OPC UA sessie aanmaken met {EndpointUrl} voor {ConnectionName}",
                        _config.EndpointUrl,
                        _config.ConnectionName
                    );
                    return false;
                }

                _session.KeepAlive += Session_KeepAlive;
                IsConnected = true;
                _logger.Information(
                    "Succesvol verbonden met OPC UA server: {EndpointUrl} voor {ConnectionName}",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );
                return true;
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Algemene fout bij verbinden met OPC UA server {EndpointUrl} (Conn: {ConnectionName})",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );
                IsConnected = false;
                _session?.Dispose();
                _session = null;
                return false;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public async Task DisconnectAsync()
        {
            if (!IsConnected)
                return;
            await _semaphore.WaitAsync();
            try
            {
                _logger.Information(
                    "Verbinding met OPC UA server verbreken: {EndpointUrl} (Conn: {ConnectionName})",
                    _config.EndpointUrl,
                    _config.ConnectionName
                );
                await StopMonitoringTagsAsync();

                _session?.Close();
                _session?.Dispose();
                _session = null;
                IsConnected = false;
                _logger.Information(
                    "Verbinding met OPC UA server verbroken voor {ConnectionName}.",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij verbreken van OPC UA verbinding voor {ConnectionName}.",
                    _config.ConnectionName
                );
                IsConnected = false;
                _session = null;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public void Reconfigure(OpcUaConnectionConfig newConfig)
        {
            if (newConfig == null)
                throw new ArgumentNullException(nameof(newConfig));
            _logger.Information(
                "Herconfigureren van OpcUaService {OldConnectionName} naar {NewConnectionName}. Endpoint: {NewEndpoint}",
                _config.ConnectionName,
                newConfig.ConnectionName,
                newConfig.EndpointUrl
            );

            bool endpointChanged =
                _config.EndpointUrl != newConfig.EndpointUrl
                || _config.SecurityMode != newConfig.SecurityMode
                || _config.SecurityPolicyUri != newConfig.SecurityPolicyUri
                || _config.UserName != newConfig.UserName
                || _config.Password != newConfig.Password;

            _config = newConfig;

            if (IsConnected)
            {
                if (endpointChanged)
                {
                    _logger.Information(
                        "Endpoint parameters gewijzigd voor {ConnectionName}, verbinding wordt herstart.",
                        _config.ConnectionName
                    );
                    Task.Run(async () =>
                    {
                        await DisconnectAsync();
                        await ConnectAsync();
                    });
                }
                else
                {
                    _logger.Information(
                        "Tags of subscription parameters gewijzigd voor {ConnectionName}, herstart monitoring.",
                        _config.ConnectionName
                    );
                    Task.Run(async () =>
                    {
                        await StopMonitoringTagsAsync();
                        await StartMonitoringTagsAsync();
                    });
                }
            }
        }

        private IUserIdentity GetUserIdentity()
        {
            if (!string.IsNullOrEmpty(_config.UserName))
            {
                return new UserIdentity(_config.UserName, _config.Password ?? string.Empty);
            }
            return new UserIdentity();
        }

        private bool IsEndpointUrlMatch(string urlFromServerList, string selectedUrl)
        {
            if (string.Equals(urlFromServerList, selectedUrl, StringComparison.OrdinalIgnoreCase))
                return true;
            try
            {
                var uriFromServer = new Uri(urlFromServerList);
                var uriSelected = new Uri(selectedUrl);
                return uriFromServer.Scheme == uriSelected.Scheme
                    && string.Equals(
                        uriFromServer.DnsSafeHost,
                        uriSelected.DnsSafeHost,
                        StringComparison.OrdinalIgnoreCase
                    )
                    && uriFromServer.Port == uriSelected.Port;
            }
            catch (UriFormatException)
            {
                return false;
            }
        }

        private void Session_KeepAlive(ISession session, KeepAliveEventArgs e)
        {
            if (ServiceResult.IsBad(e.Status))
            {
                _logger.Warning(
                    "OPC UA Sessie KeepAlive mislukt voor {ConnectionName}: {Status}. Server status: {CurrentState}",
                    _config.ConnectionName,
                    e.Status,
                    e.CurrentState
                );
                IsConnected = false;

                return;
            }
            _logger.Debug(
                "OPC UA Sessie KeepAlive ontvangen voor {ConnectionName}. Server status: {CurrentState}",
                _config.ConnectionName,
                e.CurrentState
            );
        }
        #endregion

        #region Tag Monitoring (Subscriptions)
        public async Task StartMonitoringTagsAsync()
        {
            if (!IsConnected || _session == null)
            {
                _logger.Information(
                    "Kan monitoring niet starten voor {ConnectionName}: niet verbonden of geen sessie.",
                    _config.ConnectionName
                );
                return;
            }
            if (
                _config == null
                || _config.TagsToMonitor == null
                || !_config.TagsToMonitor.Any(t => t.IsActive)
            )
            {
                _logger.Information(
                    "Kan monitoring niet starten voor {ConnectionName}: geen actieve tags geconfigureerd.",
                    _config.ConnectionName
                );
                return;
            }

            await _semaphore.WaitAsync();
            try
            {
                if (_subscription != null)
                {
                    _logger.Information(
                        "Verwijdert bestaande subscription voor {ConnectionName} alvorens een nieuwe te starten.",
                        _config.ConnectionName
                    );
                    try
                    {
                        _subscription.Delete(true);
                    }
                    catch (Exception ex)
                    {
                        _logger.Warning(
                            ex,
                            "Fout bij verwijderen oude subscription voor {ConnectionName}.",
                            _config.ConnectionName
                        );
                    }
                    _subscription.Dispose();
                    _subscription = null;
                }

                _subscription = new Subscription(_session.DefaultSubscription)
                {
                    DisplayName = $"{_config.ConnectionName} Subscription",
                    PublishingInterval = _config
                        .TagsToMonitor.Where(t => t.IsActive && t.SamplingInterval > 0)
                        .Any()
                        ? _config
                            .TagsToMonitor.Where(t => t.IsActive && t.SamplingInterval > 0)
                            .Min(t => t.SamplingInterval)
                        : 1000,
                    KeepAliveCount = 10,
                    LifetimeCount = 30,
                    MaxNotificationsPerPublish = 0,
                    PublishingEnabled = true,
                    TimestampsToReturn = TimestampsToReturn.Both,
                };

                var itemsToMonitor = new List<MonitoredItem>();
                foreach (var tagConfig in _config.TagsToMonitor.Where(t => t.IsActive))
                {
                    try
                    {
                        var item = new MonitoredItem(_subscription.DefaultItem)
                        {
                            DisplayName = tagConfig.TagName,
                            StartNodeId = ParseNodeId(tagConfig.NodeId),
                            AttributeId = Attributes.Value,
                            SamplingInterval =
                                tagConfig.SamplingInterval > 0 ? tagConfig.SamplingInterval : -1,
                            QueueSize = 1,
                            DiscardOldest = true,
                        };
                        item.Notification += OnMonitoredItemNotification;
                        itemsToMonitor.Add(item);
                    }
                    catch (Exception ex)
                    {
                        _logger.Error(
                            ex,
                            "Fout bij voorbereiden MonitoredItem voor NodeId {NodeId} (Tag: {TagName}) voor {ConnectionName}.",
                            tagConfig.NodeId,
                            tagConfig.TagName,
                            _config.ConnectionName
                        );
                    }
                }

                if (!itemsToMonitor.Any())
                {
                    _logger.Information(
                        "Geen actieve en valide tags om te monitoren voor {ConnectionName}",
                        _config.ConnectionName
                    );
                    _subscription.Dispose();
                    _subscription = null;
                    return;
                }

                _subscription.AddItems(itemsToMonitor);
                _logger.Information(
                    "Probeert subscription aan te maken voor {ItemCount} items op {ConnectionName}",
                    itemsToMonitor.Count,
                    _config.ConnectionName
                );
                _session.AddSubscription(_subscription);
                await _subscription.CreateAsync().ConfigureAwait(false);
                await _subscription.ApplyChangesAsync().ConfigureAwait(false);
                _logger.Information(
                    "Subscription succesvol aangemaakt en items worden gemonitord voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij starten van OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
                if (_subscription != null)
                {
                    try
                    {
                        _subscription.Delete(true);
                    }
                    catch
                    { /* ignore */
                    }
                    _subscription.Dispose();
                    _subscription = null;
                }
            }
            finally
            {
                _semaphore.Release();
            }
        }

        public async Task StopMonitoringTagsAsync()
        {
            if (_subscription == null)
                return;
            await _semaphore.WaitAsync();
            try
            {
                if (_subscription == null || !_session.Subscriptions.Contains(_subscription))
                {
                    _logger.Debug(
                        "Subscription al verwijderd of niet aanwezig in sessie voor {ConnectionName}.",
                        _config.ConnectionName
                    );
                    _subscription?.Dispose();
                    _subscription = null;
                    return;
                }

                _logger.Information(
                    "Stopt OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );
                _subscription.Delete(true);
                _session.RemoveSubscription(_subscription);
                _subscription.Dispose();
                _subscription = null;
                _logger.Information(
                    "OPC UA tag monitoring gestopt voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij stoppen van OPC UA tag monitoring voor {ConnectionName}",
                    _config.ConnectionName
                );

                _subscription?.Dispose();
                _subscription = null;
            }
            finally
            {
                _semaphore.Release();
            }
        }

        private void OnMonitoredItemNotification(
            MonitoredItem monitoredItem,
            MonitoredItemNotificationEventArgs e
        )
        {
            if (
                !(e.NotificationValue is MonitoredItemNotification notification)
                || notification.Value == null
            )
                return;

            var loggedValue = new LoggedTagValue
            {
                TagName = monitoredItem.DisplayName,
                Value = notification.Value.Value,
                Timestamp =
                    notification.Value.SourceTimestamp != DateTime.MinValue
                        ? notification.Value.SourceTimestamp
                        : notification.Value.ServerTimestamp,
                IsGoodQuality = StatusCode.IsGood(notification.Value.StatusCode),
                ErrorMessage = StatusCode.IsBad(notification.Value.StatusCode)
                    ? notification.Value.StatusCode.ToString()
                    : null,
            };
            TagsDataReceived?.Invoke(this, new List<LoggedTagValue> { loggedValue });
        }
        #endregion

        #region Data Reading
        public async Task<IEnumerable<LoggedTagValue>> ReadCurrentTagValuesAsync()
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning(
                    "Kan tags niet lezen voor {ConnectionName}: niet verbonden of geen sessie.",
                    _config.ConnectionName
                );
                return Enumerable.Empty<LoggedTagValue>();
            }
            if (
                _config == null
                || _config.TagsToMonitor == null
                || !_config.TagsToMonitor.Any(t => t.IsActive)
            )
            {
                _logger.Warning(
                    "Kan tags niet lezen voor {ConnectionName}: geen actieve tags geconfigureerd.",
                    _config.ConnectionName
                );
                return Enumerable.Empty<LoggedTagValue>();
            }

            var loggedValues = new List<LoggedTagValue>();
            var nodesToRead = new ReadValueIdCollection();
            var activeTagConfigs = _config.TagsToMonitor.Where(t => t.IsActive).ToList();

            foreach (var tagConfig in activeTagConfigs)
            {
                try
                {
                    nodesToRead.Add(
                        new ReadValueId
                        {
                            NodeId = ParseNodeId(tagConfig.NodeId),
                            AttributeId = Attributes.Value,
                        }
                    );
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Ongeldige NodeId {NodeId} voor tag {TagName} (Conn: {ConnectionName})",
                        tagConfig.NodeId,
                        tagConfig.TagName,
                        _config.ConnectionName
                    );
                    loggedValues.Add(
                        new LoggedTagValue
                        {
                            TagName = tagConfig.TagName,
                            IsGoodQuality = false,
                            ErrorMessage = $"Ongeldige NodeId: {tagConfig.NodeId}",
                            Timestamp = DateTime.UtcNow,
                        }
                    );
                }
            }

            if (!nodesToRead.Any())
                return loggedValues;

            try
            {
                _logger.Debug(
                    "Leest {Count} OPC UA tags voor {ConnectionName}.",
                    nodesToRead.Count,
                    _config.ConnectionName
                );
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Source,
                        nodesToRead,
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                DataValueCollection results = response.Results;
                DiagnosticInfoCollection diagnosticInfos = response.DiagnosticInfos;

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                for (int i = 0; i < results.Count; i++)
                {
                    var correspondingTagConfig = activeTagConfigs.FirstOrDefault(tc =>
                    {
                        try
                        {
                            return ParseNodeId(tc.NodeId).Equals(nodesToRead[i].NodeId);
                        }
                        catch
                        {
                            return false;
                        }
                    });

                    if (correspondingTagConfig == null)
                    {
                        _logger.Warning(
                            "Kon geen overeenkomende tagConfig vinden voor gelezen NodeId {ReadNodeId} (Conn: {ConnectionName})",
                            nodesToRead[i].NodeId,
                            _config.ConnectionName
                        );
                        continue;
                    }

                    loggedValues.Add(
                        new LoggedTagValue
                        {
                            TagName = correspondingTagConfig.TagName,
                            Value = results[i].Value,
                            Timestamp =
                                results[i].SourceTimestamp != DateTime.MinValue
                                    ? results[i].SourceTimestamp
                                    : results[i].ServerTimestamp,
                            IsGoodQuality = StatusCode.IsGood(results[i].StatusCode),
                            ErrorMessage = StatusCode.IsBad(results[i].StatusCode)
                                ? results[i].StatusCode.ToString()
                                : null,
                        }
                    );
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens het lezen van OPC UA tags voor {ConnectionName}.",
                    _config.ConnectionName
                );
                foreach (var readValueIdWithError in nodesToRead)
                {
                    var tagConfig = activeTagConfigs.FirstOrDefault(tc =>
                    {
                        try
                        {
                            return ParseNodeId(tc.NodeId).Equals(readValueIdWithError.NodeId);
                        }
                        catch
                        {
                            return false;
                        }
                    });
                    if (
                        tagConfig != null
                        && !loggedValues.Any(lv =>
                            lv.TagName == tagConfig.TagName && !lv.IsGoodQuality
                        )
                    )
                    {
                        loggedValues.Add(
                            new LoggedTagValue
                            {
                                TagName = tagConfig.TagName,
                                IsGoodQuality = false,
                                ErrorMessage = $"Algemene leesfout: {ex.Message}",
                                Timestamp = DateTime.UtcNow,
                            }
                        );
                    }
                }
            }
            return loggedValues;
        }

        public async Task<DataValue> ReadValueAsync(NodeId nodeId)
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning(
                    "Kan waarde niet lezen voor {NodeId} (Conn: {ConnectionName}): geen actieve sessie.",
                    nodeId,
                    _config.ConnectionName
                );
                return new DataValue(StatusCodes.BadNotConnected);
            }
            ReadValueId nodeToRead = new ReadValueId
            {
                NodeId = nodeId,
                AttributeId = Attributes.Value,
            };
            ReadValueIdCollection nodesToRead = new ReadValueIdCollection { nodeToRead };
            try
            {
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Source,
                        nodesToRead,
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                ClientBase.ValidateResponse(response.Results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(response.DiagnosticInfos, nodesToRead);
                return (response.Results != null && response.Results.Count > 0)
                    ? response.Results[0]
                    : new DataValue(StatusCodes.BadNoDataAvailable);
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens lezen waarde voor NodeId: {NodeId} (Conn: {ConnectionName})",
                    nodeId,
                    _config.ConnectionName
                );
            }

            return null;
        }

        public async Task<List<NodeAttributeViewModel>> ReadNodeAttributesAsync(NodeId nodeId)
        {
            var attributes = new List<NodeAttributeViewModel>();
            if (!IsConnected || _session == null)
            {
                attributes.Add(
                    new NodeAttributeViewModel(
                        "Error",
                        "Niet verbonden",
                        StatusCodes.BadNotConnected
                    )
                );
                return attributes;
            }
            uint[] attributeIdsToRead = new uint[]
            {
                Attributes.NodeId,
                Attributes.NodeClass,
                Attributes.BrowseName,
                Attributes.DisplayName,
                Attributes.Description,
                Attributes.WriteMask,
                Attributes.UserWriteMask,
                Attributes.DataType,
                Attributes.ValueRank,
                Attributes.ArrayDimensions,
                Attributes.AccessLevel,
                Attributes.UserAccessLevel,
                Attributes.MinimumSamplingInterval,
                Attributes.Historizing,
                Attributes.Value,
            };
            var nodesToRead = new ReadValueIdCollection(
                attributeIdsToRead.Select(attrId => new ReadValueId
                {
                    NodeId = nodeId,
                    AttributeId = attrId,
                })
            );
            try
            {
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Neither,
                        nodesToRead,
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                ClientBase.ValidateResponse(response.Results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(response.DiagnosticInfos, nodesToRead);
                for (int i = 0; i < response.Results.Count; i++)
                {
                    string attrName =
                        Attributes.GetBrowseName(nodesToRead[i].AttributeId)
                        ?? $"AttrID {nodesToRead[i].AttributeId}";
                    object val = response.Results[i].Value;
                    if (nodesToRead[i].AttributeId == Attributes.NodeClass && val is int ncInt)
                        val = (NodeClass)ncInt;
                    else if (
                        nodesToRead[i].AttributeId == Attributes.DataType
                        && val is NodeId dtNodeId
                    )
                    {
                        var dtNode = _session.NodeCache.Find(dtNodeId);
                        val = dtNode?.DisplayName?.Text ?? dtNodeId.ToString();
                    }
                    attributes.Add(
                        new NodeAttributeViewModel(attrName, val, response.Results[i].StatusCode)
                    );
                }
            }
            catch (Exception ex)
            {
                attributes.Add(
                    new NodeAttributeViewModel("Error", ex.Message, StatusCodes.BadUnexpectedError)
                );
                _logger.Error(ex, "Error ReadNodeAttributesAsync");
            }
            return attributes;
        }

        public async Task<LocalizedText> ReadNodeDisplayNameAsync(NodeId nodeId)
        {
            if (!IsConnected || _session == null)
                return null;
            ReadValueId nodeToRead = new ReadValueId
            {
                NodeId = nodeId,
                AttributeId = Attributes.DisplayName,
            };
            try
            {
                var response = await _session
                    .ReadAsync(
                        null,
                        0,
                        TimestampsToReturn.Neither,
                        new ReadValueIdCollection { nodeToRead },
                        CancellationToken.None
                    )
                    .ConfigureAwait(false);
                return (
                    response.Results != null
                    && response.Results.Count > 0
                    && StatusCode.IsGood(response.Results[0].StatusCode)
                )
                    ? response.Results[0].Value as LocalizedText
                    : null;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Error ReadNodeDisplayNameAsync for {NodeId}", nodeId);
                return null;
            }
        }

        public async Task<ReferenceDescriptionCollection> BrowseAllReferencesAsync(
            NodeId nodeIdToBrowse,
            BrowseDirection direction = BrowseDirection.Both
        )
        {
            return await BrowseAsync(
                nodeIdToBrowse,
                null,
                true,
                direction,
                NodeClass.Unspecified,
                CancellationToken.None
            );
        }
        #endregion

        #region Browse
        public async Task<ReferenceDescriptionCollection> BrowseAsync(
            NodeId nodeIdToBrowse,
            NodeId referenceTypeId = null,
            bool includeSubtypes = true,
            BrowseDirection direction = BrowseDirection.Forward,
            NodeClass nodeClassMask = NodeClass.Unspecified,
            CancellationToken ct = default
        )
        {
            if (!IsConnected || _session == null)
            {
                _logger.Warning("BrowseAsync: Not connected.");
                return new ReferenceDescriptionCollection();
            }
            try
            {
                BrowseDescription nodeToBrowseDesc = new BrowseDescription
                {
                    NodeId = nodeIdToBrowse,
                    BrowseDirection = direction,
                    ReferenceTypeId = referenceTypeId ?? ReferenceTypeIds.HierarchicalReferences,
                    IncludeSubtypes = includeSubtypes,
                    NodeClassMask = (uint)nodeClassMask,
                    ResultMask = (uint)BrowseResultMask.All,
                };
                BrowseResponse response = await _session
                    .BrowseAsync(
                        null,
                        null,
                        0,
                        new BrowseDescriptionCollection { nodeToBrowseDesc },
                        ct
                    )
                    .ConfigureAwait(false);
                ClientBase.ValidateResponse(
                    response.Results,
                    new BrowseDescriptionCollection { nodeToBrowseDesc }
                );
                ClientBase.ValidateDiagnosticInfos(
                    response.DiagnosticInfos,
                    new BrowseDescriptionCollection { nodeToBrowseDesc }
                );
                if (StatusCode.IsBad(response.Results[0].StatusCode))
                {
                    _logger.Error(
                        "Browse error for {NodeId}: {StatusCode}",
                        nodeIdToBrowse,
                        response.Results[0].StatusCode
                    );
                    return new ReferenceDescriptionCollection();
                }

                ReferenceDescriptionCollection references = response.Results[0].References;
                ByteStringCollection continuationPoints = new ByteStringCollection();
                if (response.Results[0].ContinuationPoint != null)
                    continuationPoints.Add(response.Results[0].ContinuationPoint);

                while (continuationPoints.Any() && continuationPoints[0] != null)
                {
                    var browseNextResponse = await _session
                        .BrowseNextAsync(null, false, continuationPoints, ct)
                        .ConfigureAwait(false);
                    ClientBase.ValidateResponse(browseNextResponse.Results, continuationPoints);
                    ClientBase.ValidateDiagnosticInfos(
                        browseNextResponse.DiagnosticInfos,
                        continuationPoints
                    );
                    if (StatusCode.IsBad(browseNextResponse.Results[0].StatusCode))
                    {
                        _logger.Error(
                            "BrowseNext error for {NodeId}: {StatusCode}",
                            nodeIdToBrowse,
                            browseNextResponse.Results[0].StatusCode
                        );
                        break;
                    }
                    references.AddRange(browseNextResponse.Results[0].References);
                    continuationPoints.Clear();
                    if (browseNextResponse.Results[0].ContinuationPoint != null)
                        continuationPoints.Add(browseNextResponse.Results[0].ContinuationPoint);
                }
                return references;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Exception during BrowseAsync for {NodeId}", nodeIdToBrowse);
                return new ReferenceDescriptionCollection();
            }
        }

        public async Task<ReferenceDescriptionCollection> BrowseRootAsync()
        {
            return await BrowseAsync(ObjectIds.ObjectsFolder, ct: CancellationToken.None);
        }

        public NodeId ParseNodeId(string nodeIdString)
        {
            if (_session == null || _session.MessageContext == null)
            {
                _logger.Warning(
                    "ParseNodeId: No active session/context, using default parse for '{NodeIdString}'.",
                    nodeIdString
                );
                return NodeId.Parse(nodeIdString);
            }
            return NodeId.Parse(_session.MessageContext, nodeIdString);
        }
        #endregion

        #region IDisposable
        public void Dispose()
        {
            _logger.Debug(
                "Dispose aangeroepen voor OpcUaService {ConnectionName}",
                _config.ConnectionName
            );
            bool waited = _semaphore.Wait(1000);
            try
            {
                if (IsConnected)
                {
                    Task.Run(async () => await DisconnectAsync()).Wait(TimeSpan.FromSeconds(2));
                }
                _subscription?.Dispose();
                _session?.Dispose();
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout tijdens Dispose van OpcUaService voor {ConnectionName}",
                    _config.ConnectionName
                );
            }
            finally
            {
                if (waited)
                    _semaphore.Release();
                _semaphore?.Dispose();
            }
        }
        #endregion
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\SettingsService.cs"
using System;
using System.IO;
using System.Reflection;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class SettingsService : ISettingsService
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private const string SettingsFileName = "DataLoggerSettings.json";
        private string _settingsFilePath;

        private AppSettings _currentSettings;
        public AppSettings CurrentSettings
        {
            get => _currentSettings;
            private set => _currentSettings = value;
        }

        public SettingsService(ILogger logger, IStatusService statusService)
        {
            _logger = logger;
            _statusService = statusService;

            string executableLocation = Path.GetDirectoryName(
                Assembly.GetExecutingAssembly().Location
            );
            _settingsFilePath = Path.Combine(executableLocation, SettingsFileName);
            _logger.Information(
                "Pad naar instellingenbestand: {SettingsFilePath}",
                _settingsFilePath
            );

            LoadSettings();
        }

        public void LoadSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Loading, "Instellingen laden...");
            try
            {
                if (File.Exists(_settingsFilePath))
                {
                    _logger.Information("Instellingenbestand gevonden. Bezig met laden...");
                    string json = File.ReadAllText(_settingsFilePath);

                    var serializerSettings = new JsonSerializerSettings
                    {
                        TypeNameHandling = TypeNameHandling.Objects,
                        Formatting = Formatting.Indented,
                    };

                    _currentSettings = JsonConvert.DeserializeObject<AppSettings>(
                        json,
                        serializerSettings
                    );
                    _logger.Information("Instellingen succesvol geladen.");
                }
                else
                {
                    _logger.Warning(
                        "Instellingenbestand niet gevonden op {SettingsFilePath}. Standaardinstellingen worden geladen.",
                        _settingsFilePath
                    );
                    LoadDefaultSettings();
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van instellingen. Standaardinstellingen worden geladen."
                );
                LoadDefaultSettings();
            }
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen verwerkt.");
        }

        public void SaveSettings()
        {
            _statusService.SetStatus(Enums.ApplicationStatus.Saving, "Instellingen opslaan...");
            try
            {
                var serializerSettings = new JsonSerializerSettings
                {
                    TypeNameHandling = TypeNameHandling.Objects,
                    Formatting = Formatting.Indented,
                };

                string json = JsonConvert.SerializeObject(CurrentSettings, serializerSettings);
                File.WriteAllText(_settingsFilePath, json);
                _logger.Information(
                    "Instellingen succesvol opgeslagen in {SettingsFilePath}",
                    _settingsFilePath
                );
                _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het opslaan van instellingen naar {SettingsFilePath}",
                    _settingsFilePath
                );
                _statusService.SetStatus(
                    Enums.ApplicationStatus.Error,
                    "Fout bij opslaan instellingen."
                );
            }
        }

        public void LoadDefaultSettings()
        {
            _logger.Information("Standaardinstellingen worden geconfigureerd.");
            _currentSettings = new AppSettings();
            _currentSettings.Connections.Add(
                new ModbusTcpConnectionConfig
                {
                    ConnectionName = "Voorbeeld Modbus Device",
                    IpAddress = "192.168.1.100",
                    Port = 502,
                    IsEnabled = false,
                    ScanIntervalSeconds = 5,
                }
            );
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Services\Implementations\StatusService.cs"
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Services.Abstractions;
using Serilog;

namespace Data_Logger.Services.Implementations
{
    public class StatusService : ObservableObject, IStatusService
    {
        private readonly ILogger _logger;
        private ApplicationStatus _currentStatus;
        private string _statusMessage;

        public ApplicationStatus CurrentStatus
        {
            get => _currentStatus;
            private set => SetProperty(ref _currentStatus, value);
        }

        public string StatusMessage
        {
            get => _statusMessage;
            private set => SetProperty(ref _statusMessage, value);
        }

        public StatusService(ILogger logger)
        {
            _logger = logger;

            SetStatus(ApplicationStatus.Idle, "Applicatie gereed.");
        }

        public void SetStatus(ApplicationStatus status, string message)
        {
            CurrentStatus = status;
            StatusMessage = message;
            _logger.Information(
                "Applicatiestatus gewijzigd naar: {Status} - Bericht: {Message}",
                status,
                message
            );
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ChartTabViewModel.cs"

using Data_Logger.Core;
using LiveChartsCore;
using LiveChartsCore.Defaults;
using LiveChartsCore.SkiaSharpView;
using LiveChartsCore.SkiaSharpView.Painting;
using Opc.Ua; 
using Serilog;
using SkiaSharp;
using System;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;

namespace Data_Logger.ViewModels
{
    public class ChartTabViewModel : ObservableObject
    {
        private readonly Serilog.ILogger _logger;
        private string _header;
        public string Header
        {
            get => _header;
            set => SetProperty(ref _header, value);
        }

        public NodeId NodeIdToPlot { get; }

        private readonly ObservableCollection<ObservablePoint> _plotDataPoints;
        public ObservableCollection<ISeries> Series { get; }
        public Axis[] XAxes { get; }
        public Axis[] YAxes { get; }

        internal const int MaxPlotBufferSizeInternal = 500; 
        private static readonly Random _colorRandom = new Random();
        private static readonly SKColor[] _predefinedPlotColors = new SKColor[] {
            SKColors.DodgerBlue, SKColors.ForestGreen, SKColors.OrangeRed, SKColors.MediumPurple,
            SKColors.Tomato, SKColors.SteelBlue, SKColors.SeaGreen, SKColors.Goldenrod, SKColors.SlateGray,
            SKColors.DarkCyan, SKColors.DarkMagenta, SKColors.DarkOliveGreen
        };
        private static int _lastColorIndex = -1;


        public ChartTabViewModel(NodeId nodeId, string tagName, Serilog.ILogger logger)
        {
            _logger = logger.ForContext<ChartTabViewModel>().ForContext("ChartTag", tagName);
            NodeIdToPlot = nodeId ?? throw new ArgumentNullException(nameof(nodeId));
            Header = tagName ?? "Grafiek";

            _plotDataPoints = new ObservableCollection<ObservablePoint>();
            
            SKColor plotColor = GetNextPlotColor();
            Series = new ObservableCollection<ISeries>
            {
                new LineSeries<ObservablePoint>
                {
                    Values = _plotDataPoints,
                    Name = tagName,
                    Fill = null,
                    GeometrySize = 4,
                    LineSmoothness = 0,
                    Stroke = new SolidColorPaint(plotColor) { StrokeThickness = 2 },
                    GeometryStroke = new SolidColorPaint(plotColor) { StrokeThickness = 1 }, 
                }
            };

            XAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Tijdstempel",
                    Labeler = value =>
                    {
                        long ticks = (long)value;
                        if (ticks >= DateTime.MinValue.Ticks && ticks <= DateTime.MaxValue.Ticks)
                        {
                            return new DateTime(ticks).ToString("HH:mm:ss");
                        }
                        return "";
                    },
                    UnitWidth = TimeSpan.TicksPerSecond, 
                    MinStep = TimeSpan.TicksPerSecond * 1,
                    TextSize = 10,
                    NameTextSize = 12
                }
            };

            YAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Waarde",
                    TextSize = 10,
                    NameTextSize = 12
                }
            };
            RefreshChartAppearance(); 
            _logger.Debug("ChartTabViewModel gecreëerd voor Node: {NodeId}, Tag: {TagName}", NodeIdToPlot, Header);
        }

        private static SKColor GetNextPlotColor()
        {
            _lastColorIndex = (_lastColorIndex + 1) % _predefinedPlotColors.Length;
            return _predefinedPlotColors[_lastColorIndex];
        }

        public void RefreshChartAppearance()
        {
            string seriesName = string.IsNullOrEmpty(Header) ? "Selecteer Tag" : Header;
            string yAxisName = string.IsNullOrEmpty(Header) ? "Waarde" : $"Waarde ({Header})";

            if (Series.Any() && Series[0] is LineSeries<ObservablePoint> lineSeries)
            {
                lineSeries.Name = seriesName;
            }
            if (YAxes.Any())
            {
                YAxes[0].Name = yAxisName;
            }

            if (!_plotDataPoints.Any())
            {
                if (XAxes.Any())
                {
                    var nowTicks = DateTime.Now.Ticks;
                    var defaultStartTicks = DateTime.Now.AddMinutes(-1).Ticks;
                    XAxes[0].MinLimit = defaultStartTicks;
                    XAxes[0].MaxLimit = nowTicks;
                }
                if (YAxes.Any())
                {
                    YAxes[0].MinLimit = 0;
                    YAxes[0].MaxLimit = 10;
                }
            }
            else
            {
                if (XAxes.Any()) { XAxes[0].MinLimit = null; XAxes[0].MaxLimit = null; }
                if (YAxes.Any()) { YAxes[0].MinLimit = null; YAxes[0].MaxLimit = null; }
            }
            OnPropertyChanged(nameof(Series));
            OnPropertyChanged(nameof(XAxes));
            OnPropertyChanged(nameof(YAxes));
            _logger.Debug("ChartTabVM {Header}: RefreshChartAppearance aangeroepen.", Header);
        }

        public void AddDataPoint(DateTime timestamp, double value)
        {
            _logger.Verbose("ChartTabVM {Header}: AddDataPoint. Ticks: {Ticks}, Waarde: {Value}", Header, timestamp.Ticks, value);
            bool needsRefresh = false;
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                bool wasEmpty = !_plotDataPoints.Any(); 
                _plotDataPoints.Add(new ObservablePoint(timestamp.Ticks, value));
                
                while (_plotDataPoints.Count > MaxPlotBufferSizeInternal)
                {
                    _plotDataPoints.RemoveAt(0);
                }
                
                if (wasEmpty && _plotDataPoints.Any())
                {
                    needsRefresh = true;
                }
            }));
            
            if (needsRefresh)
            {
                
                System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
                {
                    RefreshChartAppearance(); 
                }));
                _logger.Debug("ChartTabVM {Header}: RefreshChartAppearance aangeroepen na toevoegen datapunt.", Header);
            }
        }

        public void ClearData()
        {
            _logger.Debug("ChartTabVM {Header}: ClearData aangeroepen.", Header);
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                _plotDataPoints.Clear();
                RefreshChartAppearance(); 
            }));
        }

        public static bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null) return false;
            try
            {
                result = Convert.ToDouble(value, CultureInfo.InvariantCulture);
                return true;
            }
            catch { return false; }
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\LogViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Threading;
using Data_Logger.Core;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;
using Serilog.Events;

namespace Data_Logger.ViewModels
{
    public class LogViewModel : ObservableObject
    {
        private readonly ILoggingHostService _loggingHostService;
        private readonly ILogger _logger;

        private string _filterText;
        private LogEventLevel? _selectedLogLevelFilter;

        public ObservableCollection<UiLogEntry> LogEntries => _loggingHostService.LogEntries;
        public ICollectionView FilteredLogEntries { get; }

        public string FilterText
        {
            get => _filterText;
            set
            {
                if (SetProperty(ref _filterText, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ObservableCollection<LogEventLevel?> LogLevels { get; } =
            new ObservableCollection<LogEventLevel?>(
                new LogEventLevel?[] { null }.Concat(
                    Enum.GetValues(typeof(LogEventLevel)).Cast<LogEventLevel?>()
                )
            );

        public LogEventLevel? SelectedLogLevelFilter
        {
            get => _selectedLogLevelFilter;
            set
            {
                if (SetProperty(ref _selectedLogLevelFilter, value))
                    FilteredLogEntries.Refresh();
            }
        }

        public ICommand ClearLogsCommand { get; }

        public LogViewModel(ILoggingHostService loggingHostService, ILogger logger)
        {
            _loggingHostService =
                loggingHostService ?? throw new ArgumentNullException(nameof(loggingHostService));
            _logger =
                logger?.ForContext<LogViewModel>()
                ?? throw new ArgumentNullException(nameof(logger));

            FilteredLogEntries = CollectionViewSource.GetDefaultView(LogEntries);
            FilteredLogEntries.Filter = ApplyFilter;

            ClearLogsCommand = new RelayCommand(
                _ => _loggingHostService.ClearLogs(),
                _ => LogEntries.Any()
            );

            LogEntries.CollectionChanged += (sender, e) =>
            {
                ((RelayCommand)ClearLogsCommand).RaiseCanExecuteChanged();
            };
        }

        private bool ApplyFilter(object item)
        {
            if (item is UiLogEntry entry)
            {
                bool logLevelMatch =
                    !_selectedLogLevelFilter.HasValue
                    || entry.Level == _selectedLogLevelFilter.Value;
                bool textMatch =
                    string.IsNullOrWhiteSpace(_filterText)
                    || entry.RenderedMessage.IndexOf(
                        _filterText,
                        StringComparison.OrdinalIgnoreCase
                    ) >= 0
                    || (
                        entry.Exception != null
                        && entry.Exception.IndexOf(_filterText, StringComparison.OrdinalIgnoreCase)
                            >= 0
                    );
                return logLevelMatch && textMatch;
            }
            return false;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\MainViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Data_Logger.Views;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly ILogger _logger;
        private readonly IStatusService _statusService;
        private readonly ISettingsService _settingsService;
        private readonly Func<Action, SettingsViewModel> _settingsViewModelFactory;

        private readonly Func<ModbusTcpConnectionConfig, IModbusService> _modbusServiceFactory;
        private readonly Func<OpcUaConnectionConfig, IOpcUaService> _opcUaServiceFactory;

        private readonly IDataLoggingService _dataLoggingService;

        private string _applicationTitle = "Data Logger Applicatie";
        public string ApplicationTitle
        {
            get => _applicationTitle;
            set => SetProperty(ref _applicationTitle, value);
        }

        public LogViewModel LogVm { get; }
        public ApplicationStatus CurrentApplicationStatus => _statusService.CurrentStatus;
        public string CurrentStatusMessage => _statusService.StatusMessage;

        public ObservableCollection<TabViewModelBase> ActiveTabs { get; } =
            new ObservableCollection<TabViewModelBase>();

        private TabViewModelBase _selectedTab;
        public TabViewModelBase SelectedTab
        {
            get => _selectedTab;
            set => SetProperty(ref _selectedTab, value);
        }

        public ICommand OpenSettingsCommand { get; }

        public MainViewModel(
            ILogger logger,
            LogViewModel logViewModel,
            IStatusService statusService,
            ISettingsService settingsService,
            Func<Action, SettingsViewModel> settingsViewModelFactory,
            Func<ModbusTcpConnectionConfig, IModbusService> modbusServiceFactory,
            Func<OpcUaConnectionConfig, IOpcUaService> opcUaServiceFactory,
            IDataLoggingService dataLoggingService
        )
        {
            _logger = logger;
            LogVm = logViewModel;
            _statusService = statusService;
            _settingsService = settingsService;
            _settingsViewModelFactory = settingsViewModelFactory;

            _modbusServiceFactory = modbusServiceFactory;
            _opcUaServiceFactory = opcUaServiceFactory;

            _dataLoggingService = dataLoggingService;

            if (_statusService is INotifyPropertyChanged notifier)
            {
                notifier.PropertyChanged += StatusService_PropertyChanged;
            }

            OpenSettingsCommand = new RelayCommand(_ => OpenSettingsWindow());

            _logger.Information("MainViewModel geïnitialiseerd.");
            _statusService.SetStatus(ApplicationStatus.Idle, "Applicatie succesvol geladen.");

            LoadTabsFromSettings();
        }

        private void OpenSettingsWindow()
        {
            _logger.Information("Instellingenvenster wordt geopend...");
            _statusService.SetStatus(ApplicationStatus.Idle, "Instellingen openen...");

            var settingsView = new Views.SettingsView();
            Action closeAction = () => settingsView.Close();
            var settingsVm = _settingsViewModelFactory(closeAction);
            settingsView.DataContext = settingsVm;

            if (
                Application.Current.MainWindow != null
                && Application.Current.MainWindow != settingsView
            )
            {
                settingsView.Owner = Application.Current.MainWindow;
            }

            settingsView.ShowDialog();

            _logger.Information("Instellingenvenster gesloten.");

            UpdateTabsAfterSettingsChange();

            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar.");
        }

        private void UpdateTabsAfterSettingsChange()
        {
            _logger.Information("Tabs bijwerken na mogelijke instellingwijzigingen...");
            var newEnabledConfigs = _settingsService
                .CurrentSettings.Connections.Where(c => c.IsEnabled)
                .ToDictionary(c => c.ConnectionName);

            var currentActiveTabVMs = ActiveTabs.ToList();

            foreach (var tabVm in currentActiveTabVMs)
            {
                if (
                    !newEnabledConfigs.TryGetValue(
                        tabVm.ConnectionConfiguration.ConnectionName,
                        out var newConfigData
                    ) || !newConfigData.IsEnabled
                )
                {
                    _logger.Information(
                        "Tab verwijderen voor: {ConnectionName}",
                        tabVm.ConnectionConfiguration.ConnectionName
                    );
                    if (tabVm is IDisposable disposable)
                        disposable.Dispose();
                    ActiveTabs.Remove(tabVm);
                }
            }

            foreach (var newConfigPair in newEnabledConfigs)
            {
                var newConfig = newConfigPair.Value;
                var existingTabVm = ActiveTabs.FirstOrDefault(t =>
                    t.ConnectionConfiguration.ConnectionName == newConfig.ConnectionName
                );

                if (existingTabVm != null)
                {
                    bool requiresRestart = false;
                    if (
                        newConfig is ModbusTcpConnectionConfig newModbusConf
                        && existingTabVm.ConnectionConfiguration
                            is ModbusTcpConnectionConfig oldModbusConf
                    )
                    {
                        if (
                            newModbusConf.IpAddress != oldModbusConf.IpAddress
                            || newModbusConf.Port != oldModbusConf.Port
                            || newModbusConf.UnitId != oldModbusConf.UnitId
                        )
                        {
                            requiresRestart = true;
                        }
                    }
                    else if (
                        newConfig is OpcUaConnectionConfig newOpcUaConf
                        && existingTabVm.ConnectionConfiguration
                            is OpcUaConnectionConfig oldOpcUaConf
                    )
                    {
                        if (
                            newOpcUaConf.EndpointUrl != oldOpcUaConf.EndpointUrl
                            || newOpcUaConf.SecurityMode != oldOpcUaConf.SecurityMode
                            || newOpcUaConf.SecurityPolicyUri != oldOpcUaConf.SecurityPolicyUri
                            || newOpcUaConf.UserName != oldOpcUaConf.UserName /* || Wachtwoord gewijzigd? */
                        )
                        {
                            requiresRestart = true;
                        }
                    }

                    if (requiresRestart)
                    {
                        _logger.Information(
                            "Kernparameters gewijzigd voor {ConnectionName}. Tab wordt herstart.",
                            newConfig.ConnectionName
                        );
                        if (existingTabVm is IDisposable disposable)
                            disposable.Dispose();
                        ActiveTabs.Remove(existingTabVm);
                        CreateAndAddTab(newConfig);
                    }
                    else
                    {
                        _logger.Information(
                            "Instellingen 'warm' toepassen op bestaande tab: {ConnectionName}",
                            newConfig.ConnectionName
                        );
                        if (
                            existingTabVm is ModbusTabViewModel modbusTabVm
                            && newConfig is ModbusTcpConnectionConfig mc
                        )
                        {
                            modbusTabVm.UpdateConfiguration(mc);
                        }
                        else if (
                            existingTabVm is OpcUaTabViewModel opcUaTabVm
                            && newConfig is OpcUaConnectionConfig oc
                        )
                        {
                            opcUaTabVm.UpdateConfiguration(oc);
                        }
                    }
                }
                else
                {
                    _logger.Information(
                        "Nieuwe actieve verbinding gevonden, tab aanmaken voor: {ConnectionName}",
                        newConfig.ConnectionName
                    );
                    CreateAndAddTab(newConfig);
                }
            }

            if (ActiveTabs.Any() && SelectedTab == null)
                SelectedTab = ActiveTabs.First();
            else if (!ActiveTabs.Any())
                SelectedTab = null;
            else if (SelectedTab != null && !ActiveTabs.Contains(SelectedTab))
                SelectedTab = ActiveTabs.FirstOrDefault();
        }

        private void CreateAndAddTab(ConnectionConfigBase config)
        {
            TabViewModelBase tabVm = null;
            if (config is ModbusTcpConnectionConfig modbusConfig)
            {
                if (_modbusServiceFactory != null && _dataLoggingService != null)
                {
                    var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                    tabVm = new ModbusTabViewModel(
                        modbusConfig,
                        _logger,
                        modbusServiceInstance,
                        _statusService,
                        _dataLoggingService
                    );
                }
                else
                {
                    _logger.Error(
                        "Modbus service factory of data logging service niet geïnjecteerd. Kan ModbusTabViewModel niet aanmaken."
                    );
                }
            }
            else if (config is OpcUaConnectionConfig opcUaConfig)
            {
                if (_opcUaServiceFactory != null && _dataLoggingService != null)
                {
                    var opcUaServiceInstance = _opcUaServiceFactory(opcUaConfig);
                    tabVm = new OpcUaTabViewModel(
                        opcUaConfig,
                        _logger,
                        opcUaServiceInstance,
                        _statusService,
                        _dataLoggingService,
                        _settingsService
                    );
                }
                else
                {
                    _logger.Error(
                        "OPC UA service factory of data logging service niet geïnjecteerd. Kan OpcUaTabViewModel niet aanmaken."
                    );
                }
            }

            if (tabVm != null)
            {
                ActiveTabs.Add(tabVm);
                _logger.Information(
                    "Tab aangemaakt en toegevoegd voor {ConnectionName} ({ConnectionType})",
                    config.ConnectionName,
                    config.Type
                );
            }
        }

        private void LoadTabsFromSettings()
        {
            _logger.Information("Tabs laden op basis van huidige instellingen...");
            var currentSelectedTabName = SelectedTab?.ConnectionConfiguration?.ConnectionName;
            var currentTabs = ActiveTabs.ToList();

            foreach (var tab in currentTabs)
            {
                if (tab is IDisposable disposable)
                {
                    disposable.Dispose();
                }
                ActiveTabs.Remove(tab);
            }

            if (_settingsService.CurrentSettings?.Connections == null)
            {
                _logger.Warning(
                    "Geen verbindingen gevonden in de instellingen om tabs voor te laden."
                );
                SelectedTab = null;
                return;
            }

            foreach (var config in _settingsService.CurrentSettings.Connections)
            {
                if (config.IsEnabled)
                {
                    TabViewModelBase tabVm = null;
                    switch (config.Type)
                    {
                        case ConnectionType.ModbusTcp:
                            if (
                                config is ModbusTcpConnectionConfig modbusConfig
                                && _modbusServiceFactory != null
                            )
                            {
                                var modbusServiceInstance = _modbusServiceFactory(modbusConfig);
                                tabVm = new ModbusTabViewModel(
                                    modbusConfig,
                                    _logger,
                                    modbusServiceInstance,
                                    _statusService,
                                    _dataLoggingService
                                );
                                _logger.Debug(
                                    "Modbus TCP Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    modbusConfig.ConnectionName
                                );
                            }
                            else if (_modbusServiceFactory == null)
                            {
                                _logger.Error(
                                    "_modbusServiceFactory is niet geïnjecteerd in MainViewModel."
                                );
                            }
                            break;
                        case ConnectionType.OpcUa:
                            if (
                                config is OpcUaConnectionConfig opcUaConfig
                                && _opcUaServiceFactory != null
                            )
                            {
                                var opcUaServiceInstance = _opcUaServiceFactory(opcUaConfig);
                                tabVm = new OpcUaTabViewModel(
                                    opcUaConfig,
                                    _logger,
                                    opcUaServiceInstance,
                                    _statusService,
                                    _dataLoggingService,
                                    _settingsService
                                );
                                _logger.Debug(
                                    "OPC UA Tab ViewModel aangemaakt voor: {ConnectionName}",
                                    opcUaConfig.ConnectionName
                                );
                            }
                            else if (_opcUaServiceFactory == null)
                            {
                                _logger.Error(
                                    "_opcUaServiceFactory is niet geïnjecteerd in MainViewModel."
                                );
                            }
                            break;
                        default:
                            _logger.Warning(
                                "Onbekend verbindingstype '{Type}' overgeslagen voor tab: {ConnectionName}",
                                config.Type,
                                config.ConnectionName
                            );
                            break;
                    }

                    if (tabVm != null)
                    {
                        ActiveTabs.Add(tabVm);
                    }
                }
                else
                {
                    _logger.Debug(
                        "Verbinding '{ConnectionName}' is uitgeschakeld en wordt niet als tab geladen.",
                        config.ConnectionName
                    );
                }
            }

            if (!string.IsNullOrEmpty(currentSelectedTabName))
            {
                SelectedTab = ActiveTabs.FirstOrDefault(t =>
                    t.ConnectionConfiguration.ConnectionName == currentSelectedTabName
                );
            }

            if (SelectedTab == null && ActiveTabs.Any())
            {
                SelectedTab = ActiveTabs.First();
            }
            else if (!ActiveTabs.Any())
            {
                SelectedTab = null;
            }
            _logger.Information("{Count} actieve tabs geladen.", ActiveTabs.Count);
        }

        private void StatusService_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(IStatusService.CurrentStatus))
            {
                OnPropertyChanged(nameof(CurrentApplicationStatus));
            }
            else if (e.PropertyName == nameof(IStatusService.StatusMessage))
            {
                OnPropertyChanged(nameof(CurrentStatusMessage));
            }
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ModbusTabViewModel.cs"

using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Serilog;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Threading;

namespace Data_Logger.ViewModels
{
    public class ModbusTabViewModel : PlottingTabViewModelBase, IDisposable
    {
        private readonly ILogger _specificLogger;
        private readonly IModbusService _modbusService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;
        private DispatcherTimer _scanTimer;

        public ModbusTcpConnectionConfig ModbusConfig => ConnectionConfiguration as ModbusTcpConnectionConfig;
        public bool IsConnected => _modbusService?.IsConnected ?? false;
        public ObservableCollection<LoggedTagValue> DataValues { get; } = new ObservableCollection<LoggedTagValue>();

        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }

        public ModbusTabViewModel(
            ModbusTcpConnectionConfig config,
            ILogger logger,
            IModbusService modbusService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService)
            : base(config, logger)
        {
            _specificLogger = logger.ForContext<ModbusTabViewModel>().ForContext("ConnectionName", config.ConnectionName);
            _modbusService = modbusService ?? throw new ArgumentNullException(nameof(modbusService));
            _statusService = statusService ?? throw new ArgumentNullException(nameof(statusService));
            _dataLoggingService = dataLoggingService ?? throw new ArgumentNullException(nameof(dataLoggingService));

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(async _ => await DisconnectAsync(), _ => IsConnected);

            _modbusService.ConnectionStatusChanged += OnModbusConnectionStatusChanged;
            _modbusService.TagsDataReceived += OnModbusTagsDataReceived;
            
            PopulateAvailableTagNames();
            InitializeScanTimer();
            
        }

        protected override void PopulateAvailableTagNamesInternal()
        {
            if (ModbusConfig?.TagsToMonitor != null)
            {
                foreach (var tag in ModbusConfig.TagsToMonitor.Where(t => t.IsActive && IsDataTypePlottableInternal(t.DataType)))
                {
                    AvailableTagNamesForPlotting.Add(tag.TagName);
                }
            }
        }

        protected override bool IsDataTypePlottableInternal(object dataType)
        {
            if (dataType is ModbusDataType modbusDataType)
            {
                switch (modbusDataType)
                {
                    case ModbusDataType.Int16: case ModbusDataType.UInt16:
                    case ModbusDataType.Int32: case ModbusDataType.UInt32:
                    case ModbusDataType.Float32:
                        return true;
                    default:
                        return false;
                }
            }
            return false;
        }
        
        protected override void LoadHistoricalDataForPlot()
        {
            base.LoadHistoricalData(this.DataValues);
        }

        private void OnModbusTagsDataReceived(object sender, IEnumerable<LoggedTagValue> receivedTagValues)
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            if (!tagValuesList.Any()) return;

            _specificLogger.Debug("OnModbusTagsDataReceived: {Count} tag(s) ontvangen voor {ConnectionName}", tagValuesList.Count, DisplayName);

            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                foreach (var newTagValue in tagValuesList)
                {
                    var existingTag = DataValues.FirstOrDefault(t => t.TagName == newTagValue.TagName);
                    if (existingTag != null)
                    {
                        existingTag.Value = newTagValue.Value;
                        existingTag.Timestamp = newTagValue.Timestamp;
                        existingTag.IsGoodQuality = newTagValue.IsGoodQuality;
                        existingTag.ErrorMessage = newTagValue.ErrorMessage;
                    }
                    else
                    {
                        DataValues.Add(newTagValue);
                    }
                    HandleIncomingTagDataForPlot(newTagValue);
                }
            }));
            _dataLoggingService.LogTagValues(ModbusConfig.ConnectionName, tagValuesList);
        }
        
        public void UpdateConfiguration(ModbusTcpConnectionConfig newConfig)
        {
            var currentSpecificConfig = this.ModbusConfig;
            if (currentSpecificConfig == null) {_specificLogger.Error("UpdateConfig: Huidige ModbusConfig is null voor {DisplayName}", DisplayName); return;}
            if (newConfig == null) { _specificLogger.Error("UpdateConfig: Nieuwe config is null voor {DisplayName}", DisplayName); return; }

            _specificLogger.Information("Warme configuratie update voor Modbus {ConnectionName}", newConfig.ConnectionName);
            
            bool tagsOrIntervalChanged = currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds ||
                                         !TagsSequentiallyEqual(currentSpecificConfig.TagsToMonitor, newConfig.TagsToMonitor);

            ConnectionConfiguration = newConfig; 
            OnPropertyChanged(nameof(ModbusConfig)); 
            
            if (DisplayName != newConfig.ConnectionName) 
                DisplayName = newConfig.ConnectionName;

            _modbusService.Reconfigure(newConfig); 

            if (tagsOrIntervalChanged || DisplayName != newConfig.ConnectionName)
            {
                _specificLogger.Debug("Configuratie gewijzigd voor {DisplayName}, herpopuleren plot tags.", DisplayName);
                PopulateAvailableTagNames(); 
            }

            if (_scanTimer != null && currentSpecificConfig.ScanIntervalSeconds != newConfig.ScanIntervalSeconds)
            {
                _specificLogger.Information("Scan interval voor {DisplayName} gewijzigd van {OldInterval}s naar {NewInterval}s.",
                    DisplayName, currentSpecificConfig.ScanIntervalSeconds, newConfig.ScanIntervalSeconds);
                bool restartTimer = _scanTimer.IsEnabled;
                _scanTimer.Stop();
                _scanTimer.Interval = TimeSpan.FromSeconds(newConfig.ScanIntervalSeconds > 0 ? newConfig.ScanIntervalSeconds : 5);
                if (restartTimer && IsConnected)
                {
                    _scanTimer.Start();
                }
            }
        }
        
        private bool TagsSequentiallyEqual(ObservableCollection<ModbusTagConfig> list1, ObservableCollection<ModbusTagConfig> list2)
        {
            if (ReferenceEquals(list1, list2)) return true;
            if (list1 == null || list2 == null) return false;
            if (list1.Count != list2.Count) return false;
            for (int i = 0; i < list1.Count; i++)
            {
                if (list1[i].TagName != list2[i].TagName || list1[i].Address != list2[i].Address || 
                    list1[i].DataType != list2[i].DataType || list1[i].RegisterType != list2[i].RegisterType || 
                    list1[i].IsActive != list2[i].IsActive)
                    return false;
            }
            return true;
        }

        private void InitializeScanTimer()
        {
            _scanTimer = new DispatcherTimer {IsEnabled = false}; 
            _scanTimer.Interval = TimeSpan.FromSeconds(ModbusConfig?.ScanIntervalSeconds > 0 ? ModbusConfig.ScanIntervalSeconds : 5);
            _scanTimer.Tick += async (s, e) => await ScanTimer_TickAsync();
        }

        private async Task ScanTimer_TickAsync()
        {
            if (IsConnected)
            {
                await ReadConfiguredTagsAsync();
            }
        }

        private async Task ConnectAsync()
        {
            _statusService.SetStatus(ApplicationStatus.Connecting, $"Verbinden met Modbus: {ModbusConfig?.ConnectionName}...");
            _specificLogger.Information("Verbindingspoging gestart voor {ConnectionName}...", DisplayName);
            bool success = await _modbusService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(ApplicationStatus.Logging, $"Verbonden met Modbus: {ModbusConfig?.ConnectionName}.");
                _specificLogger.Information("Verbinding succesvol voor {ConnectionName}.", DisplayName);
                ClearDataAndPlot(); 
                _scanTimer.Start();
            }
            else
            {
                _statusService.SetStatus(ApplicationStatus.Error, $"Kon niet verbinden met Modbus: {ModbusConfig?.ConnectionName}.");
                _specificLogger.Warning("Verbinding mislukt voor {ConnectionName}.", DisplayName);
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _scanTimer.Stop();
            _specificLogger.Information("Verbinding verbreken voor {ConnectionName}...", DisplayName);
            await _modbusService.DisconnectAsync();
            _statusService.SetStatus(ApplicationStatus.Idle, $"Modbus verbinding verbroken: {ModbusConfig?.ConnectionName}.");
            _specificLogger.Information("Verbinding verbroken voor {ConnectionName}.", DisplayName);
            UpdateCommandStates();
            ClearDataAndPlot();
        }

        private async Task ReadConfiguredTagsAsync()
        {
            if (!IsConnected) return;
            _specificLogger.Debug("Bezig met pollen van geconfigureerde Modbus tags voor {ConnectionName}", ModbusConfig?.ConnectionName);
            await _modbusService.PollConfiguredTagsAsync();
        }

        private void OnModbusConnectionStatusChanged(object sender, EventArgs e)
        {
            _specificLogger.Debug("ModbusConnectionStatusChanged. IsConnected: {IsConnected} voor {ConnectionName}", _modbusService.IsConnected, DisplayName);
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();
            if (!_modbusService.IsConnected)
            {
                _scanTimer.Stop();
                ClearDataAndPlot();
            }
            else
            {
                if (!_scanTimer.IsEnabled && (ModbusConfig?.TagsToMonitor?.Any(t => t.IsActive) ?? false))
                {
                    ClearDataAndPlot(); 
                    _scanTimer.Start();
                }
            }
        }
        
        private void ClearDataAndPlot()
        {
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                DataValues.Clear();
                _plotDataPoints.Clear(); 
                RefreshChartAppearance(); 
            }));
        }

        private void UpdateCommandStates()
        {
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
                ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
            }));
        }

        private bool _disposedValue;
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    _specificLogger.Debug("Dispose(true) aangeroepen voor ModbusTabViewModel: {ConnectionName}", DisplayName);
                    _scanTimer?.Stop();
                    _scanTimer = null;
                    if (_modbusService != null)
                    {
                        _modbusService.ConnectionStatusChanged -= OnModbusConnectionStatusChanged;
                        _modbusService.TagsDataReceived -= OnModbusTagsDataReceived;
                        _modbusService.Dispose();
                    }
                }
                _disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\NodeAttributeViewModel.cs"
using Data_Logger.Core;
using Opc.Ua;

namespace Data_Logger.ViewModels;

public class NodeAttributeViewModel : ObservableObject
{
    private string _attributeName;
    public string AttributeName
    {
        get => _attributeName;
        set => SetProperty(ref _attributeName, value);
    }

    private object _value;
    public object Value
    {
        get => _value;
        set => SetProperty(ref _value, value);
    }

    private StatusCode _statusCode;
    public StatusCode StatusCode
    {
        get => _statusCode;
        set => SetProperty(ref _statusCode, value);
    }

    public string StatusCodeDisplay => StatusCode.ToString();
    public bool IsGood => StatusCode.IsGood(StatusCode);

    public NodeAttributeViewModel(string attributeName, object value, StatusCode statusCode)
    {
        AttributeName = attributeName;
        Value = value;
        StatusCode = statusCode;
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaNodeViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using Data_Logger.Core;
using Data_Logger.Services.Abstractions;
using Opc.Ua;

namespace Data_Logger.ViewModels
{
    public class OpcUaNodeViewModel : ObservableObject
    {
        private readonly NodeId _nodeId;
        private readonly IOpcUaService _opcUaService;
        private readonly Serilog.ILogger _logger;

        private string _displayName;
        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        private NodeClass _nodeClass;
        public NodeClass NodeClass
        {
            get => _nodeClass;
            set => SetProperty(ref _nodeClass, value);
        }

        public NodeId NodeId => _nodeId;

        private bool _isExpanded;
        public bool IsExpanded
        {
            get => _isExpanded;
            set
            {
                if (SetProperty(ref _isExpanded, value))
                {
                    if (_isExpanded && !_childrenLoaded && Children.Any(c => c == null))
                    {
                        LoadChildren();
                    }
                }
            }
        }

        public ObservableCollection<OpcUaNodeViewModel> Children { get; }

        private bool _childrenLoaded = false;

        public OpcUaNodeViewModel(
            NodeId nodeId,
            string displayName,
            NodeClass nodeClass,
            IOpcUaService opcUaService,
            Serilog.ILogger logger,
            bool hasChildren
        )
        {
            _nodeId = nodeId;
            DisplayName = displayName;
            NodeClass = nodeClass;
            _opcUaService = opcUaService;
            _logger = logger;
            Children = new ObservableCollection<OpcUaNodeViewModel>();
            if (hasChildren)
            {
                Children.Add(null);
            }
        }

        private async void LoadChildren()
        {
            _childrenLoaded = true;
            Children.Clear();

            _logger.Debug(
                "Laden van children voor OPC UA Node: {NodeIdString} - {DisplayName}",
                _nodeId.ToString(),
                DisplayName
            );

            if (_opcUaService == null || !_opcUaService.IsConnected)
            {
                _logger.Warning("Kan children niet laden: OpcUaService is null of niet verbonden.");

                return;
            }

            try
            {
                ReferenceDescriptionCollection childReferences = await _opcUaService.BrowseAsync(
                    _nodeId,
                    ct: CancellationToken.None
                );

                if (childReferences != null)
                {
                    foreach (var childData in childReferences)
                    {
                        bool hasGrandChildren =
                            childData.NodeClass == Opc.Ua.NodeClass.Object
                            || childData.NodeClass == Opc.Ua.NodeClass.View;

                        NodeId actualNodeId = null;
                        if (_opcUaService.NamespaceUris != null)
                        {
                            try
                            {
                                actualNodeId = ExpandedNodeId.ToNodeId(
                                    childData.NodeId,
                                    _opcUaService.NamespaceUris
                                );
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(
                                    ex,
                                    "Fout bij het converteren van ExpandedNodeId {ExpandedNodeId} naar NodeId voor DisplayName {DisplayName}",
                                    childData.NodeId,
                                    childData.DisplayName?.Text
                                );
                                continue;
                            }
                        }
                        else
                        {
                            _logger.Warning(
                                "NamespaceUris is null in OpcUaService, kan ExpandedNodeId niet correct converteren voor {DisplayName}",
                                childData.DisplayName?.Text
                            );

                            try
                            {
                                actualNodeId = ExpandedNodeId.ToNodeId(childData.NodeId, null);
                            }
                            catch
                            {
                                continue;
                            }
                        }

                        if (actualNodeId == null)
                            continue;

                        System.Windows.Application.Current.Dispatcher.Invoke(
                            (Action)(
                                () =>
                                {
                                    Children.Add(
                                        new OpcUaNodeViewModel(
                                            actualNodeId,
                                            childData.DisplayName?.Text ?? "Unknown",
                                            childData.NodeClass,
                                            _opcUaService,
                                            _logger,
                                            hasGrandChildren
                                        )
                                    );
                                }
                            )
                        );
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van children voor node {NodeIdString}",
                    _nodeId.ToString()
                );
            }
            OnPropertyChanged(nameof(Children));
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\OpcUaTabViewModel.cs"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Opc.Ua;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class OpcUaTabViewModel : TabViewModelBase, IDisposable
    {
        #region Fields
        private readonly ILogger _logger;
        private readonly IOpcUaService _opcUaService;
        private readonly IStatusService _statusService;
        private readonly IDataLoggingService _dataLoggingService;
        private readonly ISettingsService _settingsService;

        private bool _isBrowse = false;
        private OpcUaNodeViewModel _selectedOpcUaNode;
        private string _lastReadNodeValue = "Nog geen waarde gelezen.";
        private ChartTabViewModel _selectedPlotTab;
        private bool _disposedValue;
        private bool _isLoadingNodeDetails = false;
        #endregion

        #region Properties
        public OpcUaConnectionConfig OpcUaConfig =>
            ConnectionConfiguration as OpcUaConnectionConfig;
        public bool IsConnected => _opcUaService?.IsConnected ?? false;

        public ObservableCollection<LoggedTagValue> DataValues { get; } =
            new ObservableCollection<LoggedTagValue>();
        public ObservableCollection<OpcUaNodeViewModel> RootNodes { get; } =
            new ObservableCollection<OpcUaNodeViewModel>();

        public bool IsBrowse
        {
            get => _isBrowse;
            set
            {
                if (SetProperty(ref _isBrowse, value))
                    UpdateCommandStates();
            }
        }

        public string LastReadNodeValue
        {
            get => _lastReadNodeValue;
            set => SetProperty(ref _lastReadNodeValue, value);
        }

        public ObservableCollection<ChartTabViewModel> PlottedSeriesViewModels { get; }
        public ChartTabViewModel SelectedPlotTab
        {
            get => _selectedPlotTab;
            set => SetProperty(ref _selectedPlotTab, value);
        }

        public ObservableCollection<NodeAttributeViewModel> SelectedNodeAttributes { get; } =
            new ObservableCollection<NodeAttributeViewModel>();
        public ObservableCollection<ReferenceDescriptionViewModel> SelectedNodeReferences { get; } =
            new ObservableCollection<ReferenceDescriptionViewModel>();

        public bool IsLoadingNodeDetails
        {
            get => _isLoadingNodeDetails;
            set => SetProperty(ref _isLoadingNodeDetails, value);
        }

        public OpcUaNodeViewModel SelectedOpcUaNode
        {
            get => _selectedOpcUaNode;
            set
            {
                if (SetProperty(ref _selectedOpcUaNode, value))
                {
                    _logger.Debug(
                        "Geselecteerde OPC UA Node in TreeView: {DisplayName}",
                        _selectedOpcUaNode?.DisplayName ?? "null"
                    );
                    UpdateCommandStates();
                    if (_selectedOpcUaNode != null && IsConnected)
                    {
                        Task.Run(async () => await LoadSelectedNodeDetailsAsync());
                    }
                    else
                    {
                        System.Windows.Application.Current.Dispatcher.Invoke(
                            (Action)(
                                () =>
                                {
                                    SelectedNodeAttributes.Clear();
                                    SelectedNodeReferences.Clear();
                                }
                            )
                        );
                    }
                }
            }
        }
        #endregion

        #region Commands
        public ICommand ConnectCommand { get; }
        public ICommand DisconnectCommand { get; }
        public ICommand ReadAllConfiguredTagsCommand { get; }
        public ICommand LoadAddressSpaceCommand { get; }
        public ICommand AddSelectedNodeToMonitoringCommand { get; }
        public ICommand RemoveSelectedNodeFromMonitoringCommand { get; }
        public ICommand ReadSelectedNodeValueCommand { get; }
        public ICommand AddNodeToPlotCommand { get; }
        public ICommand ClosePlotTabCommand { get; }

        public ICommand PlotConfiguredTagCommand { get; }

        public ICommand UnmonitorTagCommand { get; }
        #endregion

        #region Constructor
        public OpcUaTabViewModel(
            OpcUaConnectionConfig config,
            ILogger logger,
            IOpcUaService opcUaService,
            IStatusService statusService,
            IDataLoggingService dataLoggingService,
            ISettingsService settingsService
        )
            : base(config)
        {
            _logger = logger
                .ForContext<OpcUaTabViewModel>()
                .ForContext("ConnectionName", config.ConnectionName);
            _opcUaService = opcUaService ?? throw new ArgumentNullException(nameof(opcUaService));
            _statusService =
                statusService ?? throw new ArgumentNullException(nameof(statusService));
            _dataLoggingService =
                dataLoggingService ?? throw new ArgumentNullException(nameof(dataLoggingService));
            _settingsService =
                settingsService ?? throw new ArgumentNullException(nameof(settingsService));

            ConnectCommand = new RelayCommand(async _ => await ConnectAsync(), _ => !IsConnected);
            DisconnectCommand = new RelayCommand(
                async _ => await DisconnectAsync(),
                _ => IsConnected
            );
            ReadAllConfiguredTagsCommand = new RelayCommand(
                async _ => await ReadAllConfiguredTagsAsync(),
                _ => IsConnected
            );
            LoadAddressSpaceCommand = new RelayCommand(
                async _ => await LoadInitialAddressSpaceAsync(),
                _ => IsConnected && !IsBrowse
            );

            AddSelectedNodeToMonitoringCommand = new RelayCommand(
                param => AddSelectedNodeToMonitoring(param as OpcUaNodeViewModel),
                param => CanAddSelectedNodeToMonitoring(param as OpcUaNodeViewModel)
            );
            RemoveSelectedNodeFromMonitoringCommand = new RelayCommand(
                param => RemoveSelectedNodeFromMonitoring(param as OpcUaNodeViewModel),
                param => CanRemoveSelectedNodeFromMonitoring(param as OpcUaNodeViewModel)
            );
            ReadSelectedNodeValueCommand = new RelayCommand(
                async param => await ReadSelectedNodeValueAsync(param as OpcUaNodeViewModel),
                param => CanReadSelectedNodeValue(param as OpcUaNodeViewModel)
            );

            PlottedSeriesViewModels = new ObservableCollection<ChartTabViewModel>();
            AddNodeToPlotCommand = new RelayCommand(
                param => AddNodeToPlot(param as OpcUaNodeViewModel),
                param => CanAddNodeToPlot(param as OpcUaNodeViewModel)
            );
            ClosePlotTabCommand = new RelayCommand(
                param => ClosePlotTab(param as ChartTabViewModel),
                param => param is ChartTabViewModel
            );

            PlotConfiguredTagCommand = new RelayCommand(
                param => PlotConfiguredTag(param as OpcUaTagConfig),
                param => param is OpcUaTagConfig
            );

            UnmonitorTagCommand = new RelayCommand(
                param => UnmonitorTag(param as OpcUaTagConfig),
                param => param is OpcUaTagConfig
            );

            _opcUaService.ConnectionStatusChanged += OnOpcUaConnectionStatusChanged;
            _opcUaService.TagsDataReceived += OnOpcUaTagsDataReceived;

            _logger.Debug("OpcUaTabViewModel geïnitialiseerd voor {ConnectionName}", DisplayName);
        }
        #endregion

        #region Connection and Data Handling
        private async Task ConnectAsync()
        {
            _statusService.SetStatus(
                ApplicationStatus.Connecting,
                $"Verbinden met OPC UA: {OpcUaConfig.ConnectionName}..."
            );
            _logger.Information("Verbindingspoging gestart voor {ConnectionName}...", DisplayName);
            bool success = await _opcUaService.ConnectAsync();
            if (success)
            {
                _statusService.SetStatus(
                    ApplicationStatus.Logging,
                    $"Verbonden met OPC UA: {OpcUaConfig.ConnectionName}."
                );
                _logger.Information("Verbinding succesvol voor {ConnectionName}.", DisplayName);
                ClearAllPlotData();
                await LoadInitialAddressSpaceAsync();
                await _opcUaService.StartMonitoringTagsAsync();
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Kon niet verbinden met OPC UA: {OpcUaConfig.ConnectionName}."
                );
                _logger.Warning("Verbinding mislukt voor {ConnectionName}.", DisplayName);
            }
            UpdateCommandStates();
        }

        private async Task DisconnectAsync()
        {
            _logger.Information("Verbinding verbreken voor {ConnectionName}...", DisplayName);
            await _opcUaService.DisconnectAsync();
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"OPC UA verbinding verbroken: {OpcUaConfig.ConnectionName}."
            );
            _logger.Information("Verbinding verbroken voor {ConnectionName}.", DisplayName);
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        RootNodes.Clear();
                        DataValues.Clear();
                        ClearAllPlotData();
                    }
                )
            );
            UpdateCommandStates();
        }

        private void OnOpcUaConnectionStatusChanged(object sender, EventArgs e)
        {
            _logger.Debug(
                "OpcUaConnectionStatusChanged. IsConnected: {IsConnected} voor {ConnectionName}",
                _opcUaService.IsConnected,
                DisplayName
            );
            OnPropertyChanged(nameof(IsConnected));
            UpdateCommandStates();
            if (!_opcUaService.IsConnected)
            {
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            RootNodes.Clear();
                            DataValues.Clear();
                            ClearAllPlotData();
                        }
                    )
                );
            }
            else
            {
                if (!RootNodes.Any() && !IsBrowse)
                {
                    Task.Run(async () => await LoadInitialAddressSpaceAsync());
                }
            }
        }

        private void OnOpcUaTagsDataReceived(
            object sender,
            IEnumerable<LoggedTagValue> receivedTagValues
        )
        {
            var tagValuesList = receivedTagValues?.ToList() ?? new List<LoggedTagValue>();
            if (!tagValuesList.Any())
                return;

            _logger.Debug(
                "OnOpcUaTagsDataReceived: {Count} tag(s) ontvangen voor {ConnectionName}",
                tagValuesList.Count,
                DisplayName
            );

            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        foreach (var liveValue in tagValuesList)
                        {
                            var configuredTag = OpcUaConfig?.TagsToMonitor.FirstOrDefault(t =>
                                t.TagName == liveValue.TagName
                            );

                            if (configuredTag != null)
                            {
                                configuredTag.CurrentValue = liveValue.Value;
                                configuredTag.Timestamp = liveValue.Timestamp;
                                configuredTag.IsGoodQuality = liveValue.IsGoodQuality;
                                configuredTag.ErrorMessage = liveValue.ErrorMessage;
                            }
                            else
                            {
                                _logger.Verbose(
                                    "OnOpcUaTagsDataReceived: Geen geconfigureerde tag gevonden voor binnenkomende live data met TagName '{TagName}'",
                                    liveValue.TagName
                                );
                            }

                            var plotVm = PlottedSeriesViewModels.FirstOrDefault(p =>
                                p.Header == liveValue.TagName
                            );
                            if (plotVm != null && liveValue.IsGoodQuality)
                            {
                                if (
                                    ChartTabViewModel.TryConvertToDouble(
                                        liveValue.Value,
                                        out double numericValue
                                    )
                                )
                                {
                                    plotVm.AddDataPoint(liveValue.Timestamp, numericValue);
                                }
                            }
                        }
                    }
                )
            );
            _dataLoggingService.LogTagValues(OpcUaConfig.ConnectionName, tagValuesList);
        }
        #endregion

        #region Configuration Handling
        public void UpdateConfiguration(OpcUaConnectionConfig newConfig)
        {
            _logger.Information(
                "Warme configuratie update (via Settings) voor OPC UA verbinding {ConnectionName}",
                newConfig.ConnectionName
            );

            bool tagsInMemoryChanged = !TagsSequentiallyEqual(
                OpcUaConfig?.TagsToMonitor,
                newConfig?.TagsToMonitor
            );

            ConnectionConfiguration = newConfig;
            OnPropertyChanged(nameof(OpcUaConfig));
            if (DisplayName != newConfig.ConnectionName)
                DisplayName = newConfig.ConnectionName;

            _opcUaService.Reconfigure(newConfig);

            if (tagsInMemoryChanged)
            {
                _logger.Debug(
                    "TagsToMonitor zijn gewijzigd via settings, plot tabs worden gesynchroniseerd."
                );
                SyncPlotTabsWithMonitoredTags();
            }

            if (IsConnected)
            {
                _logger.Information(
                    "Configuratie (mogelijk verbindingsparameters) gewijzigd, herstart monitoring voor {ConnectionName}",
                    DisplayName
                );
                Task.Run(async () =>
                {
                    await _opcUaService.StopMonitoringTagsAsync();
                    await _opcUaService.StartMonitoringTagsAsync();
                });
            }
        }

        private bool TagsSequentiallyEqual(
            ObservableCollection<OpcUaTagConfig> list1,
            ObservableCollection<OpcUaTagConfig> list2
        )
        {
            if (ReferenceEquals(list1, list2))
                return true;
            if (list1 == null || list2 == null)
                return false;
            if (list1.Count != list2.Count)
                return false;
            for (int i = 0; i < list1.Count; i++)
            {
                if (
                    list1[i].TagName != list2[i].TagName
                    || list1[i].NodeId != list2[i].NodeId
                    || list1[i].DataType != list2[i].DataType
                    || list1[i].SamplingInterval != list2[i].SamplingInterval
                    || list1[i].IsActive != list2[i].IsActive
                )
                    return false;
            }
            return true;
        }
        #endregion

        #region Node Browser Logic
        private async Task LoadInitialAddressSpaceAsync()
        {
            if (!IsConnected || _opcUaService == null)
                return;
            if (IsBrowse)
                return;

            IsBrowse = true;
            _logger.Information(
                "Laden van initiële OPC UA address space voor {ConnectionName}",
                DisplayName
            );
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() => RootNodes.Clear()));

            try
            {
                ReferenceDescriptionCollection rootItems = await _opcUaService.BrowseRootAsync();
                if (rootItems != null)
                {
                    var namespaceUris = _opcUaService.NamespaceUris;
                    foreach (var item in rootItems)
                    {
                        bool hasChildren =
                            item.NodeClass == NodeClass.Object || item.NodeClass == NodeClass.View;
                        NodeId nodeId = null;
                        if (namespaceUris != null)
                        {
                            try
                            {
                                nodeId = ExpandedNodeId.ToNodeId(item.NodeId, namespaceUris);
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(
                                    ex,
                                    "Fout bij converteren root ExpandedNodeId {ExpNodeId} voor {ItemDisplayName}",
                                    item.NodeId,
                                    item.DisplayName?.Text
                                );
                            }
                        }
                        else
                        {
                            _logger.Warning(
                                "NamespaceUris is null, kan ExpandedNodeId niet converteren voor {ItemDisplayName}",
                                item.DisplayName?.Text
                            );
                            try
                            {
                                nodeId = ExpandedNodeId.ToNodeId(item.NodeId, null);
                            }
                            catch
                            { /* ignore */
                            }
                        }

                        if (nodeId != null)
                        {
                            System.Windows.Application.Current.Dispatcher.Invoke(
                                (Action)(
                                    () =>
                                    {
                                        RootNodes.Add(
                                            new OpcUaNodeViewModel(
                                                nodeId,
                                                item.DisplayName?.Text ?? "Unknown",
                                                item.NodeClass,
                                                _opcUaService,
                                                _logger,
                                                hasChildren
                                            )
                                        );
                                    }
                                )
                            );
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van de initiële address space voor {ConnectionName}",
                    DisplayName
                );
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Fout bij laden address space: {ex.Message}"
                );
            }
            finally
            {
                IsBrowse = false;
            }
        }
        #endregion

        #region Node Details Logic
        private async Task LoadSelectedNodeDetailsAsync()
        {
            if (SelectedOpcUaNode == null || _opcUaService == null || !_opcUaService.IsConnected)
            {
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            SelectedNodeAttributes.Clear();
                            SelectedNodeReferences.Clear();
                        }
                    )
                );
                return;
            }

            IsLoadingNodeDetails = true;
            _logger.Information(
                "Laden van details voor geselecteerde node: {NodeId}",
                SelectedOpcUaNode.NodeId
            );

            try
            {
                var attributes = await _opcUaService.ReadNodeAttributesAsync(
                    SelectedOpcUaNode.NodeId
                );
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            SelectedNodeAttributes.Clear();
                            foreach (var attr in attributes)
                            {
                                SelectedNodeAttributes.Add(attr);
                            }
                        }
                    )
                );

                var references = await _opcUaService.BrowseAllReferencesAsync(
                    SelectedOpcUaNode.NodeId
                );
                System.Windows.Application.Current.Dispatcher.Invoke(
                    (Action)(
                        () =>
                        {
                            SelectedNodeReferences.Clear();
                            if (references != null)
                            {
                                var namespaceUris = _opcUaService.NamespaceUris;
                                foreach (var rd in references)
                                {
                                    NodeId targetNodeId = null;
                                    if (namespaceUris != null)
                                    {
                                        try
                                        {
                                            targetNodeId = ExpandedNodeId.ToNodeId(
                                                rd.NodeId,
                                                namespaceUris
                                            );
                                        }
                                        catch (Exception ex)
                                        {
                                            _logger.Error(
                                                ex,
                                                "Fout bij converteren target ExpandedNodeId {ExpNodeId} voor ref naar {ItemDisplayName}",
                                                rd.NodeId,
                                                rd.DisplayName?.Text
                                            );
                                        }
                                    }
                                    else
                                    {
                                        try
                                        {
                                            targetNodeId = ExpandedNodeId.ToNodeId(rd.NodeId, null);
                                        }
                                        catch
                                        { /* ignore */
                                        }
                                    }

                                    if (targetNodeId != null)
                                    {
                                        string refTypeDisplay = rd.ReferenceTypeId.ToString();

                                        LocalizedText refTypeLocText = Task.Run(async () =>
                                                await _opcUaService.ReadNodeDisplayNameAsync(
                                                    ExpandedNodeId.ToNodeId(
                                                        rd.ReferenceTypeId,
                                                        namespaceUris
                                                    )
                                                )
                                            )
                                            .GetAwaiter()
                                            .GetResult();
                                        if (
                                            refTypeLocText != null
                                            && !LocalizedText.IsNullOrEmpty(refTypeLocText)
                                        )
                                        {
                                            refTypeDisplay = refTypeLocText.Text;
                                        }

                                        SelectedNodeReferences.Add(
                                            new ReferenceDescriptionViewModel(
                                                rd,
                                                ExpandedNodeId.ToNodeId(
                                                    rd.ReferenceTypeId,
                                                    namespaceUris
                                                ),
                                                refTypeDisplay,
                                                rd.IsForward,
                                                targetNodeId
                                            )
                                        );
                                    }
                                }
                            }
                        }
                    )
                );
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Fout bij het laden van node details voor {NodeId}",
                    SelectedOpcUaNode.NodeId
                );
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Fout bij laden node details: {ex.Message}"
                );
            }
            finally
            {
                IsLoadingNodeDetails = false;
            }
        }
        #endregion

        #region Monitoring Configuration from TreeView & Auto-Save
        private bool CanAddSelectedNodeToMonitoring(OpcUaNodeViewModel node)
        {
            if (node == null)
                return false;

            bool isCorrectNodeClass = (
                node.NodeClass == NodeClass.Variable || node.NodeClass == NodeClass.VariableType
            );

            bool isAlreadyMonitored = IsNodeCurrentlyMonitored(node);

            _logger.Verbose(
                "CanAddSelectedNodeToMonitoring for Node: {NodeDisplayName} (Class: {NodeClass}) - IsCorrectNodeClass: {IsCorrectClass}, IsAlreadyMonitored: {IsMonitored}, Result: {CanAdd}",
                node.DisplayName,
                node.NodeClass,
                isCorrectNodeClass,
                isAlreadyMonitored,
                (isCorrectNodeClass && !isAlreadyMonitored)
            );

            return isCorrectNodeClass && !isAlreadyMonitored;
        }

        private bool CanRemoveSelectedNodeFromMonitoring(OpcUaNodeViewModel node)
        {
            if (node == null)
                return false;
            return IsNodeCurrentlyMonitored(node);
        }

        private bool IsNodeCurrentlyMonitored(OpcUaNodeViewModel node)
        {
            if (node == null || OpcUaConfig?.TagsToMonitor == null)
            {
                _logger.Verbose(
                    "IsNodeCurrentlyMonitored: Node or TagsToMonitor is null for {NodeDisplayName}",
                    node?.DisplayName
                );
                return false;
            }

            string nodeStringToCompare = node.NodeId.ToString();
            _logger.Verbose(
                "IsNodeCurrentlyMonitored: Checking if NodeId string '{NodeStringToCompare}' (DisplayName: {NodeDisplayName}) is in monitoring list.",
                nodeStringToCompare,
                node.DisplayName
            );

            bool isFound = false;
            foreach (var monitoredTag in OpcUaConfig.TagsToMonitor)
            {
                _logger.Verbose(
                    " - Comparing with configured tag: NodeId='{ConfiguredNodeId}', TagName='{ConfiguredTagName}'",
                    monitoredTag.NodeId,
                    monitoredTag.TagName
                );
                if (monitoredTag.NodeId == nodeStringToCompare)
                {
                    isFound = true;
                    break;
                }
            }

            if (isFound)
            {
                _logger.Information(
                    "IsNodeCurrentlyMonitored: Match FOUND for {NodeDisplayName}. Node IS currently monitored.",
                    node.DisplayName
                );
            }
            else
            {
                _logger.Information(
                    "IsNodeCurrentlyMonitored: No match found for {NodeDisplayName} in {TagCount} configured tags. Node IS NOT currently monitored.",
                    node.DisplayName,
                    OpcUaConfig.TagsToMonitor.Count
                );
            }
            return isFound;
        }

        private void AddSelectedNodeToMonitoring(OpcUaNodeViewModel nodeToAdd)
        {
            if (nodeToAdd == null || !CanAddSelectedNodeToMonitoring(nodeToAdd))
                return;

            var newTagConfig = new OpcUaTagConfig
            {
                TagName = nodeToAdd.DisplayName,
                NodeId = nodeToAdd.NodeId.ToString(),
                IsActive = true,
                SamplingInterval =
                    OpcUaConfig?.TagsToMonitor?.FirstOrDefault()?.SamplingInterval ?? 1000,
                DataType = OpcUaDataType.Variant,
            };
            OpcUaConfig.TagsToMonitor.Add(newTagConfig);
            _logger.Information(
                "Tag {NodeId} ({DisplayName}) toegevoegd aan monitoring.",
                newTagConfig.NodeId,
                newTagConfig.TagName
            );
            _statusService.SetStatus(
                ApplicationStatus.Saving,
                $"Tag '{newTagConfig.TagName}' toegevoegd & instellingen opslaan..."
            );

            SaveAndUpdateService();
            UpdateCommandStates();
        }

        private void RemoveSelectedNodeFromMonitoring(OpcUaNodeViewModel nodeToRemove)
        {
            if (nodeToRemove == null || !CanRemoveSelectedNodeFromMonitoring(nodeToRemove))
                return;
            var tagToRemove = OpcUaConfig.TagsToMonitor.FirstOrDefault(t =>
                t.NodeId == nodeToRemove.NodeId.ToString()
            );

            if (tagToRemove != null)
            {
                OpcUaConfig.TagsToMonitor.Remove(tagToRemove);
                _logger.Information(
                    "Tag {NodeId} ({DisplayName}) verwijderd uit monitoring.",
                    nodeToRemove.NodeId,
                    nodeToRemove.DisplayName
                );
                _statusService.SetStatus(
                    ApplicationStatus.Saving,
                    $"Tag '{nodeToRemove.DisplayName}' verwijderd & instellingen opslaan..."
                );

                SaveAndUpdateService();
                UpdateCommandStates();
            }
        }

        private void SaveAndUpdateService()
        {
            _settingsService.SaveSettings();
            _logger.Information("Instellingen automatisch opgeslagen na tag wijziging.");

            if (IsConnected)
            {
                _logger.Information(
                    "Monitoring herstarten na tag wijziging voor {ConnectionName}",
                    DisplayName
                );
                Task.Run(async () =>
                {
                    await _opcUaService.StopMonitoringTagsAsync();
                    _opcUaService.Reconfigure(OpcUaConfig);
                    await _opcUaService.StartMonitoringTagsAsync();
                    _statusService.SetStatus(
                        ApplicationStatus.Logging,
                        $"Monitoring geüpdatet voor {DisplayName}."
                    );
                });
            }
            else
            {
                _statusService.SetStatus(
                    ApplicationStatus.Idle,
                    "Tag configuratie gewijzigd en opgeslagen."
                );
            }
        }
        #endregion

        #region Node Interaction Commands (Read Value, Plot)
        private bool CanReadSelectedNodeValue(OpcUaNodeViewModel node)
        {
            if (node == null)
                node = SelectedOpcUaNode;
            return node != null
                && IsConnected
                && (
                    node.NodeClass == NodeClass.Variable || node.NodeClass == NodeClass.VariableType
                );
        }

        private async Task ReadSelectedNodeValueAsync(OpcUaNodeViewModel nodeToRead)
        {
            if (nodeToRead == null || !CanReadSelectedNodeValue(nodeToRead))
            {
                LastReadNodeValue = "Kan waarde niet lezen.";
                return;
            }
            _logger.Information(
                "Lezen van waarde voor geselecteerde node: {NodeId}",
                nodeToRead.NodeId
            );
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Leest waarde van {nodeToRead.DisplayName}..."
            );
            try
            {
                DataValue dataValue = await _opcUaService.ReadValueAsync(nodeToRead.NodeId);
                if (dataValue != null)
                {
                    if (StatusCode.IsGood(dataValue.StatusCode))
                    {
                        LastReadNodeValue =
                            $"Waarde: {dataValue.Value?.ToString() ?? "null"} @ {dataValue.SourceTimestamp.ToLocalTime():HH:mm:ss.fff} (Kwaliteit: Goed)";
                        _logger.Information(
                            "Waarde gelezen voor {NodeId}: {Value}",
                            nodeToRead.NodeId,
                            dataValue.Value
                        );
                    }
                    else
                    {
                        LastReadNodeValue = $"Fout bij lezen: {dataValue.StatusCode}";
                        _logger.Warning(
                            "Fout bij lezen waarde voor {NodeId}: {StatusCode}",
                            nodeToRead.NodeId,
                            dataValue.StatusCode
                        );
                    }
                }
                else
                {
                    LastReadNodeValue = "Geen waarde object ontvangen.";
                    _logger.Warning(
                        "Geen DataValue object ontvangen bij lezen van {NodeId}",
                        nodeToRead.NodeId
                    );
                }
            }
            catch (Exception ex)
            {
                LastReadNodeValue = $"Fout: {ex.Message}";
                _logger.Error(
                    ex,
                    "Exception bij lezen van geselecteerde node {NodeId}",
                    nodeToRead.NodeId
                );
            }
            _statusService.SetStatus(ApplicationStatus.Idle, "Klaar met lezen.");
        }

        private bool CanAddNodeToPlot(OpcUaNodeViewModel node)
        {
            if (node == null)
                node = SelectedOpcUaNode;
            if (
                node == null
                || (
                    node.NodeClass != NodeClass.Variable && node.NodeClass != NodeClass.VariableType
                )
            )
                return false;

            return true;
        }

        private void AddNodeToPlot(OpcUaNodeViewModel nodeToAdd)
        {
            if (nodeToAdd == null || !CanAddNodeToPlot(nodeToAdd))
            {
                _logger.Warning(
                    "AddNodeToPlot: Kan node niet plotten (null of ongeldige NodeClass)."
                );
                return;
            }

            _logger.Information(
                "Plotten van Node: {NodeId} ({DisplayName})",
                nodeToAdd.NodeId,
                nodeToAdd.DisplayName
            );

            var existingPlotTab = PlottedSeriesViewModels.FirstOrDefault(p =>
                p.NodeIdToPlot.Equals(nodeToAdd.NodeId)
            );
            if (existingPlotTab != null)
            {
                _logger.Debug(
                    "Plot tab voor {DisplayName} bestaat al, wordt geactiveerd.",
                    nodeToAdd.DisplayName
                );
                SelectedPlotTab = existingPlotTab;
            }
            else
            {
                _logger.Debug(
                    "Nieuwe plot tab wordt aangemaakt voor {DisplayName}.",
                    nodeToAdd.DisplayName
                );
                var newPlotTab = new ChartTabViewModel(
                    nodeToAdd.NodeId,
                    nodeToAdd.DisplayName,
                    _logger
                );
                PlottedSeriesViewModels.Add(newPlotTab);
                SelectedPlotTab = newPlotTab;
                LoadHistoricalDataForSpecificPlot(newPlotTab);
            }

            if (!IsNodeCurrentlyMonitored(nodeToAdd))
            {
                _logger.Information(
                    "Node {DisplayName} wordt nog niet gemonitord, toevoegen aan monitoring lijst...",
                    nodeToAdd.DisplayName
                );

                var newTagConfig = new OpcUaTagConfig
                {
                    TagName = nodeToAdd.DisplayName,
                    NodeId = nodeToAdd.NodeId.ToString(),
                    IsActive = true,
                    SamplingInterval =
                        OpcUaConfig
                            ?.TagsToMonitor?.FirstOrDefault(t => t.IsActive)
                            ?.SamplingInterval ?? 1000,
                    DataType = OpcUaDataType.Variant,
                };
                OpcUaConfig.TagsToMonitor.Add(newTagConfig);
                _logger.Information(
                    "Tag {NodeId} ({DisplayName}) toegevoegd aan monitoring configuratie via 'Plot deze Node'.",
                    newTagConfig.NodeId,
                    newTagConfig.TagName
                );

                SaveAndUpdateService();
            }
            else
            {
                _logger.Debug("Node {DisplayName} werd al gemonitord.", nodeToAdd.DisplayName);
            }

            UpdateCommandStates();
        }

        private void ClosePlotTab(ChartTabViewModel plotTabToClose)
        {
            if (plotTabToClose != null)
            {
                _logger.Information("Plot tab gesloten voor: {Header}", plotTabToClose.Header);
                PlottedSeriesViewModels.Remove(plotTabToClose);
                plotTabToClose.ClearData();
                UpdateCommandStates();
            }
        }

        private void LoadHistoricalDataForSpecificPlot(ChartTabViewModel plotVm)
        {
            if (plotVm == null)
                return;
            _logger.Debug(
                "LoadHistoricalDataForSpecificPlot voor Node: {NodeId}, Header: {Header}",
                plotVm.NodeIdToPlot,
                plotVm.Header
            );
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        plotVm.ClearData();
                        var relevantValues = DataValues
                            .Where(dv => dv.TagName == plotVm.Header && dv.IsGoodQuality)
                            .OrderBy(dv => dv.Timestamp)
                            .ToList();

                        int count = relevantValues.Count;
                        int itemsToSkip = Math.Max(
                            0,
                            count - ChartTabViewModel.MaxPlotBufferSizeInternal
                        );
                        var historicalValuesToDisplay = relevantValues.Skip(itemsToSkip);

                        foreach (var loggedValue in historicalValuesToDisplay)
                        {
                            if (
                                ChartTabViewModel.TryConvertToDouble(
                                    loggedValue.Value,
                                    out double numericValue
                                )
                            )
                            {
                                plotVm.AddDataPoint(loggedValue.Timestamp, numericValue);
                            }
                        }
                        _logger.Debug(
                            "LoadHistoricalDataForSpecificPlot: {Count} punten geladen voor Node: {NodeId}",
                            plotVm.Series.FirstOrDefault()?.Values?.Cast<object>().Count() ?? 0,
                            plotVm.NodeIdToPlot
                        );
                        plotVm.RefreshChartAppearance();
                    }
                )
            );
        }

        private void ClearAllPlotData()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        foreach (var plotTab in PlottedSeriesViewModels)
                        {
                            plotTab.ClearData();
                        }
                    }
                )
            );
        }

        private async Task ReadAllConfiguredTagsAsync()
        {
            if (!IsConnected)
            {
                _logger.Warning(
                    "Kan geconfigureerde tags niet lezen, niet verbonden: {DisplayName}",
                    DisplayName
                );
                return;
            }
            _logger.Information(
                "Eenmalige leesactie voor geconfigureerde tags gestart voor {DisplayName}",
                DisplayName
            );
            _statusService.SetStatus(
                ApplicationStatus.Logging,
                $"Leest geconfigureerde tags van {OpcUaConfig.ConnectionName}..."
            );
            var values = await _opcUaService.ReadCurrentTagValuesAsync();
            OnOpcUaTagsDataReceived(this, values);
            _statusService.SetStatus(
                ApplicationStatus.Idle,
                $"Klaar met lezen van geconfigureerde tags van {OpcUaConfig.ConnectionName}."
            );
        }

        private void PlotConfiguredTag(OpcUaTagConfig tagConfig)
        {
            if (tagConfig == null)
                return;

            _logger.Information(
                "Plotten van geconfigureerde tag: {TagName} ({NodeId})",
                tagConfig.TagName,
                tagConfig.NodeId
            );

            NodeId nodeIdToPlot = null;
            try
            {
                nodeIdToPlot = _opcUaService.ParseNodeId(tagConfig.NodeId);
            }
            catch (Exception ex)
            {
                _logger.Error(
                    ex,
                    "Kan NodeId string '{NodeIdStr}' niet parsen voor plotten.",
                    tagConfig.NodeId
                );
                _statusService.SetStatus(
                    ApplicationStatus.Error,
                    $"Ongeldige NodeId: {tagConfig.NodeId}"
                );
                return;
            }

            if (PlottedSeriesViewModels.Any(p => p.NodeIdToPlot.Equals(nodeIdToPlot)))
            {
                SelectedPlotTab = PlottedSeriesViewModels.FirstOrDefault(p =>
                    p.NodeIdToPlot.Equals(nodeIdToPlot)
                );
                _logger.Debug(
                    "Plot tab voor {TagName} is al open en nu actief.",
                    tagConfig.TagName
                );
                return;
            }

            var newPlotTab = new ChartTabViewModel(nodeIdToPlot, tagConfig.TagName, _logger);
            PlottedSeriesViewModels.Add(newPlotTab);
            SelectedPlotTab = newPlotTab;
            LoadHistoricalDataForSpecificPlot(newPlotTab);
        }

        private void UnmonitorTag(OpcUaTagConfig tagConfig)
        {
            if (tagConfig == null || !OpcUaConfig.TagsToMonitor.Contains(tagConfig))
                return;

            _logger.Information(
                "Stopt monitoring en verwijdert tag: {TagName} ({NodeId})",
                tagConfig.TagName,
                tagConfig.NodeId
            );

            OpcUaConfig.TagsToMonitor.Remove(tagConfig);
            _statusService.SetStatus(
                ApplicationStatus.Saving,
                $"Tag '{tagConfig.TagName}' verwijderd & instellingen opslaan..."
            );

            SaveAndUpdateService();

            var plotTabToRemove = PlottedSeriesViewModels.FirstOrDefault(p =>
                p.NodeIdToPlot.ToString() == tagConfig.NodeId
            );
            if (plotTabToRemove != null)
            {
                ClosePlotTab(plotTabToRemove);
            }
        }

        public void SaveChangesForTagConfig(OpcUaTagConfig modifiedTagConfig)
        {
            if (modifiedTagConfig == null)
                return;

            _logger.Information(
                "Wijzigingen voor tag '{TagName}' (IsActive: {IsActive}, Interval: {Interval}) worden opgeslagen.",
                modifiedTagConfig.TagName,
                modifiedTagConfig.IsActive,
                modifiedTagConfig.SamplingInterval
            );
            _statusService.SetStatus(
                ApplicationStatus.Saving,
                $"Wijziging voor '{modifiedTagConfig.TagName}' opslaan..."
            );

            SaveAndUpdateService();
        }

        #endregion

        #region UI Update and Dispose
        private void UpdateCommandStates()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        ((RelayCommand)ConnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)DisconnectCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)ReadAllConfiguredTagsCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)LoadAddressSpaceCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)AddSelectedNodeToMonitoringCommand).RaiseCanExecuteChanged();
                        (
                            (RelayCommand)RemoveSelectedNodeFromMonitoringCommand
                        ).RaiseCanExecuteChanged();
                        ((RelayCommand)ReadSelectedNodeValueCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)AddNodeToPlotCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)ClosePlotTabCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)PlotConfiguredTagCommand).RaiseCanExecuteChanged();
                        ((RelayCommand)UnmonitorTagCommand).RaiseCanExecuteChanged();
                    }
                )
            );
        }

        private void SyncPlotTabsWithMonitoredTags()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(
                (Action)(
                    () =>
                    {
                        List<OpcUaTagConfig> activeConfiguredTags =
                            OpcUaConfig?.TagsToMonitor?.Where(t => t.IsActive).ToList()
                            ?? new List<OpcUaTagConfig>();

                        var tabsToRemove = PlottedSeriesViewModels
                            .Where(pt =>
                                !activeConfiguredTags.Any(cfg =>
                                    cfg.NodeId == pt.NodeIdToPlot.ToString()
                                )
                            )
                            .ToList();

                        foreach (var tabToRemove in tabsToRemove)
                        {
                            _logger.Debug(
                                "Plot tab verwijderen (sync): {Header}",
                                tabToRemove.Header
                            );
                            PlottedSeriesViewModels.Remove(tabToRemove);
                            tabToRemove.ClearData();
                        }

                        foreach (var plotTab in PlottedSeriesViewModels)
                        {
                            LoadHistoricalDataForSpecificPlot(plotTab);
                        }
                        UpdateCommandStates();
                    }
                )
            );
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposedValue)
            {
                if (disposing)
                {
                    _logger.Debug(
                        "Dispose(true) aangeroepen voor OpcUaTabViewModel: {ConnectionName}",
                        DisplayName
                    );
                    if (_opcUaService != null)
                    {
                        _opcUaService.ConnectionStatusChanged -= OnOpcUaConnectionStatusChanged;
                        _opcUaService.TagsDataReceived -= OnOpcUaTagsDataReceived;
                        _opcUaService.Dispose();
                    }
                    System.Windows.Application.Current.Dispatcher.Invoke(
                        (Action)(
                            () =>
                            {
                                PlottedSeriesViewModels?.Clear();
                                RootNodes?.Clear();
                                DataValues?.Clear();
                            }
                        )
                    );
                }
                _disposedValue = true;
            }
        }
        #endregion
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\PlottingTabViewModelBase.cs"

using Data_Logger.Core;
using Data_Logger.Models;
using LiveChartsCore;
using LiveChartsCore.Defaults;
using LiveChartsCore.SkiaSharpView;
using LiveChartsCore.SkiaSharpView.Painting;
using Serilog;
using SkiaSharp;
using System;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;

namespace Data_Logger.ViewModels
{
    public abstract class PlottingTabViewModelBase : TabViewModelBase
    {
        protected readonly ILogger _plotLogger;
        protected const int MaxPlotBufferSize = 500;
        protected readonly ObservableCollection<ObservablePoint> _plotDataPoints;

        public ObservableCollection<ISeries> Series { get; set; }
        public Axis[] XAxes { get; set; }
        public Axis[] YAxes { get; set; }

        public ObservableCollection<string> AvailableTagNamesForPlotting { get; }

        private string _selectedTagNameForPlotting;
        public string SelectedTagNameForPlotting
        {
            get => _selectedTagNameForPlotting;
            set
            {
                var logger = _plotLogger ?? Serilog.Log.Logger.ForContext(GetType());
                logger.Debug("Probeer SelectedTagNameForPlotting te zetten. Oud: '{OldValue}', Nieuw: '{NewValue}' voor {DisplayName}", _selectedTagNameForPlotting, value, DisplayName);
                if (SetProperty(ref _selectedTagNameForPlotting, value))
                {
                    logger.Information("SelectedTagNameForPlotting GEWIJZIGD naar: {SelectedTag} voor {DisplayName}. Aanroepen UpdatePlotSeriesNameAndYAxis en LoadHistoricalDataForPlot.", _selectedTagNameForPlotting, DisplayName);
                    RefreshChartAppearance(); 
                    LoadHistoricalDataForPlot();
                }
                else
                {
                    logger.Debug("SelectedTagNameForPlotting NIET gewijzigd (zelfde waarde) voor {DisplayName}.", DisplayName);
                }
            }
        }

        protected PlottingTabViewModelBase(ConnectionConfigBase connectionConfig, ILogger logger) : base(connectionConfig)
        {
            _plotLogger = logger?.ForContext(GetType()).ForContext("PlotContext", connectionConfig?.ConnectionName ?? "UnknownConnection") ?? throw new ArgumentNullException(nameof(logger));

            _plotDataPoints = new ObservableCollection<ObservablePoint>();
            Series = new ObservableCollection<ISeries>
            {
                new LineSeries<ObservablePoint>
                {
                    Values = _plotDataPoints,
                    Name = "Selecteer Tag",
                    Fill = null,
                    GeometrySize = 4,
                    LineSmoothness = 0,
                    Stroke = new SolidColorPaint(SKColors.RoyalBlue) { StrokeThickness = 2 },
                    GeometryStroke = new SolidColorPaint(SKColors.RoyalBlue) { StrokeThickness = 2 },
                }
            };

            XAxes = new Axis[]
            {
                new Axis
                {
                    Name = "Tijdstempel",
                    Labeler = value =>
                    {
                        long ticks = (long)value;
                        if (ticks >= DateTime.MinValue.Ticks && ticks <= DateTime.MaxValue.Ticks)
                        {
                            return new DateTime(ticks).ToString("HH:mm:ss");
                        }
                        return "";
                    },
                    UnitWidth = TimeSpan.TicksPerSecond,
                    MinStep = TimeSpan.TicksPerSecond * 1, TextSize = 10, NameTextSize = 12
                }
            };
            YAxes = new Axis[] { new Axis { Name = "Waarde", TextSize = 10, NameTextSize = 12 } };
            AvailableTagNamesForPlotting = new ObservableCollection<string>();
            RefreshChartAppearance(); 
        }

        protected virtual void RefreshChartAppearance() 
        {
            string seriesName = string.IsNullOrEmpty(_selectedTagNameForPlotting) ? "Selecteer Tag" : _selectedTagNameForPlotting;
            string yAxisName = string.IsNullOrEmpty(_selectedTagNameForPlotting) ? "Waarde" : $"Waarde ({_selectedTagNameForPlotting})";

            if (Series.Any() && Series[0] is LineSeries<ObservablePoint> lineSeries)
            {
                lineSeries.Name = seriesName;
            }
            if (YAxes.Any())
            {
                YAxes[0].Name = yAxisName;
            }

            if (!_plotDataPoints.Any())
            {
                if (XAxes.Any())
                {
                    var nowTicks = DateTime.Now.Ticks;
                    var defaultStartTicks = DateTime.Now.AddMinutes(-1).Ticks;
                    XAxes[0].MinLimit = defaultStartTicks;
                    XAxes[0].MaxLimit = nowTicks;
                }
                if (YAxes.Any()) { YAxes[0].MinLimit = 0; YAxes[0].MaxLimit = 10; }
            }
            else
            {
                if (XAxes.Any()) { XAxes[0].MinLimit = null; XAxes[0].MaxLimit = null; }
                if (YAxes.Any()) { YAxes[0].MinLimit = null; YAxes[0].MaxLimit = null; }
            }
            OnPropertyChanged(nameof(Series));
            OnPropertyChanged(nameof(XAxes));
            OnPropertyChanged(nameof(YAxes));
            _plotLogger.Debug("PlottingTabVMBase {DisplayName}: RefreshChartAppearance aangeroepen.", DisplayName);
        }

        protected abstract void LoadHistoricalDataForPlot();

        protected void LoadHistoricalData(ObservableCollection<LoggedTagValue> sourceDataValues)
        {
            _plotLogger.Debug("Base LoadHistoricalData voor tag: {SelectedTag} voor {DisplayName}. Bron count: {SourceCount}", SelectedTagNameForPlotting, DisplayName, sourceDataValues?.Count ?? -1);
            System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
            {
                _plotDataPoints.Clear();
                if (string.IsNullOrEmpty(SelectedTagNameForPlotting) || sourceDataValues == null)
                {
                    _plotLogger.Debug("LoadHistoricalData: Geen data geladen voor {DisplayName}.", DisplayName);
                    RefreshChartAppearance(); 
                    return;
                }
                var relevantValues = sourceDataValues
                    .Where(dv => dv.TagName == SelectedTagNameForPlotting && dv.IsGoodQuality)
                    .OrderBy(dv => dv.Timestamp).ToList();
                int count = relevantValues.Count;
                int itemsToSkip = Math.Max(0, count - MaxPlotBufferSize);
                var historicalValuesToDisplay = relevantValues.Skip(itemsToSkip);
                foreach (var loggedValue in historicalValuesToDisplay)
                {
                    if (TryConvertToDouble(loggedValue.Value, out double numericValue))
                    {
                        _plotDataPoints.Add(new ObservablePoint(loggedValue.Timestamp.Ticks, numericValue));
                    }
                }
                _plotLogger.Debug("LoadHistoricalData: {Count} punten geladen voor tag {SelectedTag} voor {DisplayName}.", _plotDataPoints.Count, SelectedTagNameForPlotting, DisplayName);
                RefreshChartAppearance();
            }));
        }

        protected void HandleIncomingTagDataForPlot(LoggedTagValue newTagValue)
        {
            if (newTagValue.TagName == SelectedTagNameForPlotting && newTagValue.IsGoodQuality)
            {
                if (TryConvertToDouble(newTagValue.Value, out double numericValue))
                {
                    System.Windows.Application.Current.Dispatcher.Invoke((Action)(() =>
                    {
                        _plotDataPoints.Add(new ObservablePoint(newTagValue.Timestamp.Ticks, numericValue));
                        while (_plotDataPoints.Count > MaxPlotBufferSize)
                        {
                            _plotDataPoints.RemoveAt(0);
                        }
                    }));
                }
                else
                {
                    _plotLogger.Verbose("Waarde '{Value}' voor tag '{TagName}' (conn: {ConnName}) kon niet naar double geconverteerd worden voor plotten.", newTagValue.Value, newTagValue.TagName, DisplayName);
                }
            }
        }

        protected bool TryConvertToDouble(object value, out double result)
        {
            result = 0;
            if (value == null) return false;
            try { result = Convert.ToDouble(value, CultureInfo.InvariantCulture); return true; }
            catch { return false; }
        }

        protected abstract void PopulateAvailableTagNamesInternal();
        protected abstract bool IsDataTypePlottableInternal(object dataType);

        public void PopulateAvailableTagNames()
        {
            AvailableTagNamesForPlotting.Clear();
            PopulateAvailableTagNamesInternal();
            SelectedTagNameForPlotting = AvailableTagNamesForPlotting.FirstOrDefault();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\ReferenceDescriptionViewModel.cs"
using Data_Logger.Core;
using Opc.Ua;

namespace Data_Logger.ViewModels;

public class ReferenceDescriptionViewModel : ObservableObject
{
    public NodeId ReferenceTypeId { get; }
    public string ReferenceTypeDisplay { get; }
    public bool IsForward { get; }
    public NodeId TargetNodeId { get; }
    public string TargetNodeIdString => TargetNodeId?.ToString() ?? "N/A";
    public NodeClass TargetNodeClass { get; }
    public string TargetBrowseName { get; }
    public string TargetDisplayName { get; }

    public ReferenceDescriptionViewModel(
        ReferenceDescription rd,
        NodeId referenceTypeId,
        string referenceTypeDisplay,
        bool isForward,
        NodeId targetNodeId
    )
    {
        ReferenceTypeId = referenceTypeId;
        ReferenceTypeDisplay = referenceTypeDisplay;
        IsForward = isForward;
        TargetNodeId = targetNodeId;
        TargetNodeClass = rd.NodeClass;
        TargetBrowseName = rd.BrowseName?.ToString() ?? "N/A";
        TargetDisplayName = rd.DisplayName?.Text ?? "N/A";
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\SettingsViewModel.cs"
using System;
using System.Collections.ObjectModel;
using System.Windows.Input;
using Data_Logger.Core;
using Data_Logger.Enums;
using Data_Logger.Models;
using Data_Logger.Services.Abstractions;
using Newtonsoft.Json;
using Serilog;

namespace Data_Logger.ViewModels
{
    public class SettingsViewModel : ObservableObject
    {
        private readonly ISettingsService _settingsService;
        private readonly IStatusService _statusService;
        private readonly ILogger _logger;

        private ObservableCollection<ConnectionConfigBase> _workingConnections;
        public ObservableCollection<ConnectionConfigBase> WorkingConnections
        {
            get => _workingConnections;
            set => SetProperty(ref _workingConnections, value);
        }

        private ConnectionConfigBase _selectedConnection;
        public ConnectionConfigBase SelectedConnection
        {
            get => _selectedConnection;
            set
            {
                if (SetProperty(ref _selectedConnection, value))
                {
                    ((RelayCommand)RemoveConnectionCommand).RaiseCanExecuteChanged();
                }
            }
        }

        public ICommand AddOpcUaConnectionCommand { get; }
        public ICommand AddModbusTcpConnectionCommand { get; }
        public ICommand RemoveConnectionCommand { get; }
        public ICommand SaveCommand { get; }
        public ICommand CancelCommand { get; }

        private Action _closeWindowAction;

        public SettingsViewModel(
            ISettingsService settingsService,
            IStatusService statusService,
            ILogger logger,
            Action closeWindowAction
        )
        {
            _settingsService = settingsService;
            _statusService = statusService;
            _logger = logger;
            _closeWindowAction =
                closeWindowAction ?? throw new ArgumentNullException(nameof(closeWindowAction));

            LoadWorkingCopyOfSettings();

            AddOpcUaConnectionCommand = new RelayCommand(_ => AddConnection(ConnectionType.OpcUa));
            AddModbusTcpConnectionCommand = new RelayCommand(_ =>
                AddConnection(ConnectionType.ModbusTcp)
            );
            RemoveConnectionCommand = new RelayCommand(
                _ => RemoveSelectedConnection(),
                _ => SelectedConnection != null
            );
            SaveCommand = new RelayCommand(_ => SaveSettingsAndClose());
            CancelCommand = new RelayCommand(_ => CancelAndClose());

            _logger.Information("SettingsViewModel geïnitialiseerd.");
        }

        private void LoadWorkingCopyOfSettings()
        {
            _logger.Debug("Werkkopie van instellingen laden...");

            var originalConnections = _settingsService.CurrentSettings.Connections;
            var tempWorkingConnections = new ObservableCollection<ConnectionConfigBase>();

            var serializerSettings = new JsonSerializerSettings
            {
                TypeNameHandling = TypeNameHandling.Objects,
            };

            foreach (var conn in originalConnections)
            {
                try
                {
                    string jsonConn = JsonConvert.SerializeObject(conn, serializerSettings);
                    var clonedConn = JsonConvert.DeserializeObject<ConnectionConfigBase>(
                        jsonConn,
                        serializerSettings
                    );
                    if (clonedConn != null)
                    {
                        tempWorkingConnections.Add(clonedConn);
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(
                        ex,
                        "Fout bij het klonen van een ConnectionConfig object: {ConnectionName}",
                        conn.ConnectionName
                    );
                }
            }
            WorkingConnections = tempWorkingConnections;
            _logger.Information(
                "Werkkopie van {Count} verbindingen geladen.",
                WorkingConnections.Count
            );
        }

        private void AddConnection(ConnectionType type)
        {
            ConnectionConfigBase newConnection = null;
            switch (type)
            {
                case ConnectionType.ModbusTcp:
                    newConnection = new ModbusTcpConnectionConfig();
                    _logger.Information("Nieuwe Modbus TCP verbinding toegevoegd aan werkkopie.");
                    break;
                case ConnectionType.OpcUa:
                    newConnection = new OpcUaConnectionConfig();
                    _logger.Information("Nieuwe OPC UA verbinding toegevoegd aan werkkopie.");
                    break;
                default:
                    _logger.Warning("Onbekend verbindingstype gevraagd: {Type}", type);
                    return;
            }

            if (newConnection != null)
            {
                WorkingConnections.Add(newConnection);
                SelectedConnection = newConnection;
            }
        }

        private void RemoveSelectedConnection()
        {
            if (SelectedConnection != null)
            {
                _logger.Information(
                    "Verbinding '{ConnectionName}' verwijderd uit werkkopie.",
                    SelectedConnection.ConnectionName
                );
                WorkingConnections.Remove(SelectedConnection);
                SelectedConnection = null;
            }
        }

        private void SaveSettingsAndClose()
        {
            _logger.Information("Instellingen opslaan vanuit SettingsViewModel...");
            _statusService.SetStatus(
                Enums.ApplicationStatus.Saving,
                "Bezig met opslaan van gewijzigde instellingen..."
            );

            _settingsService.CurrentSettings.Connections.Clear();
            foreach (var conn in WorkingConnections)
            {
                _settingsService.CurrentSettings.Connections.Add(conn);
            }

            _settingsService.SaveSettings();
            _logger.Information("Instellingen succesvol opgeslagen.");
            _statusService.SetStatus(Enums.ApplicationStatus.Idle, "Instellingen opgeslagen.");
            _closeWindowAction();
        }

        private void CancelAndClose()
        {
            _logger.Information("Wijzigingen in instellingen geannuleerd.");
            _statusService.SetStatus(
                Enums.ApplicationStatus.Idle,
                "Wijzigingen in instellingen geannuleerd."
            );
            _closeWindowAction();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\ViewModels\TabViewModelBase.cs"
using Data_Logger.Core;
using Data_Logger.Models;

namespace Data_Logger.ViewModels
{
    public abstract class TabViewModelBase : ObservableObject
    {
        private string _displayName;

        private ConnectionConfigBase _connectionConfiguration;

        public ConnectionConfigBase ConnectionConfiguration
        {
            get => _connectionConfiguration;
            protected set => SetProperty(ref _connectionConfiguration, value);
        }

        public string DisplayName
        {
            get => _displayName;
            set => SetProperty(ref _displayName, value);
        }

        protected TabViewModelBase(ConnectionConfigBase connectionConfig)
        {
            ConnectionConfiguration = connectionConfig;
            DisplayName = connectionConfig.ConnectionName;
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml"
<Window x:Class="Data_Logger.Views.BrowseOpcUaNodesView"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        mc:Ignorable="d"
        Title="BrowseOpcUaNodesView" Height="450" Width="800">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>   <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,5">
            <Button Content="Omhoog" Command="{Binding GoUpCommand}" MinWidth="70" Margin="0,0,10,0"/>
            <TextBlock Text="{Binding CurrentBrowsePathDisplay}" VerticalAlignment="Center" FontWeight="SemiBold" TextTrimming="CharacterEllipsis"/>
        </StackPanel>
        
        <ListView Grid.Row="1" x:Name="NodesListView"
                  ItemsSource="{Binding CurrentNodes}" 
                  SelectedItem="{Binding SelectedNodeInView}" 
                  SelectionMode="Single" Margin="0,0,0,5"
                  HorizontalContentAlignment="Stretch">
            <ListView.InputBindings>
                <MouseBinding MouseAction="LeftDoubleClick" Command="{Binding BrowseDeeperCommand}" CommandParameter="{Binding SelectedItem, ElementName=NodesListView}"/>
            </ListView.InputBindings>
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding NodeClass}" Value="Variable">
                            <Setter Property="FontWeight" Value="Bold"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="Naam" Width="*">
                        <GridViewColumn.CellTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="{Binding DisplayName}" />
                                </StackPanel>
                            </DataTemplate>
                        </GridViewColumn.CellTemplate>
                    </GridViewColumn>
                    <GridViewColumn Header="NodeClass" DisplayMemberBinding="{Binding NodeClass}" Width="100"/>
                    <GridViewColumn Header="NodeId" DisplayMemberBinding="{Binding NodeId}" Width="200"/>
                </GridView>
            </ListView.View>
        </ListView>
        
        <TextBlock Grid.Row="1" Text="Laden..." FontSize="16" HorizontalAlignment="Center" VerticalAlignment="Center"
                   Visibility="{Binding IsLoading, Converter={StaticResource BooleanToVisibilityConverter}}"/>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
            <Button Content="Selecteer" Command="{Binding SelectNodeCommand}" IsDefault="True" MinWidth="80" Margin="0,0,10,0"/>
            <Button Content="Annuleren" Command="{Binding CancelCommand}" IsCancel="True" MinWidth="80"/>
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\BrowseOpcUaNodesView.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class BrowseOpcUaNodesView : Window
    {
        public BrowseOpcUaNodesView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml"
<UserControl
    d:DataContext="{d:DesignInstance vm:LogViewModel,
                                     IsDesignTimeCreatable=False}"
    d:DesignHeight="300"
    d:DesignWidth="600"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.LogView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Grid>

        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <StackPanel
            Grid.Row="0"
            Margin="5"
            Orientation="Horizontal">
            <TextBlock
                Margin="0,0,5,0"
                Text="Filter Tekst:"
                VerticalAlignment="Center" />
            <TextBox
                Margin="0,0,10,0"
                Text="{Binding FilterText, UpdateSourceTrigger=PropertyChanged}"
                VerticalAlignment="Center"
                Width="150" />
            <TextBlock
                Margin="0,0,5,0"
                Text="Niveau:"
                VerticalAlignment="Center" />
            <ComboBox
                ItemsSource="{Binding LogLevels}"
                Margin="0,0,10,0"
                SelectedValue="{Binding SelectedLogLevelFilter}"
                VerticalAlignment="Center"
                Width="100" />
            <Button
                Command="{Binding ClearLogsCommand}"
                Content="Wis Logs"
                VerticalAlignment="Center" />
        </StackPanel>

        <ListView
            AlternationCount="2"
            Grid.Row="1"
            ItemsSource="{Binding LogEntries}"
            Margin="5,0,5,5">
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding Level}" Value="Error">
                            <Setter Property="Background" Value="LightPink" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Fatal">
                            <Setter Property="Background" Value="Red" />
                            <Setter Property="Foreground" Value="White" />
                        </DataTrigger>
                        <DataTrigger Binding="{Binding Level}" Value="Warning">
                            <Setter Property="Background" Value="LightYellow" />
                        </DataTrigger>
                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                            <Setter Property="Background" Value="#EFEFEF" />
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.View>
                <GridView>
                    <GridViewColumn
                        DisplayMemberBinding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}"
                        Header="Tijd"
                        Width="150" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding LevelDisplay}"
                        Header="Niveau"
                        Width="80" />
                    <GridViewColumn
                        DisplayMemberBinding="{Binding RenderedMessage}"
                        Header="Bericht"
                        Width="Auto" />
                </GridView>
            </ListView.View>
        </ListView>
    </Grid>
</UserControl>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\LogView.xaml.cs"
using System.Windows.Controls;

namespace Data_Logger.Views
{
    public partial class LogView : UserControl
    {
        public LogView()
        {
            InitializeComponent();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml"
<Window
    Height="600"
    Title="{Binding ApplicationTitle}"
    Width="800"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:views="clr-namespace:Data_Logger.Views"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Window.Resources>
        <DataTemplate DataType="{x:Type vm:ModbusTabViewModel}">
            <views:ModbusTabView />
        </DataTemplate>
        <DataTemplate DataType="{x:Type vm:OpcUaTabViewModel}"> <views:OpcUaTabView />
        </DataTemplate>
    </Window.Resources>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
            <RowDefinition Height="200" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <Menu Grid.Row="0">
            <MenuItem Header="_Bestand">
                <MenuItem Command="{Binding OpenSettingsCommand}" Header="_Instellingen..." />
                <Separator />
                <MenuItem Click="Afsluiten_Click" Header="_Afsluiten" />
            </MenuItem>
        </Menu>

        <TabControl
            Grid.Row="1"
            ItemsSource="{Binding ActiveTabs}"
            Margin="5"
            SelectedItem="{Binding SelectedTab}">
            <TabControl.ItemTemplate>
                <DataTemplate DataType="{x:Type vm:TabViewModelBase}">
                    <TextBlock Text="{Binding DisplayName}" />
                </DataTemplate>
            </TabControl.ItemTemplate>
        </TabControl>

        <GridSplitter
            Background="LightGray"
            Grid.Row="2"
            Height="5"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Center" />

        <GroupBox
            Grid.Row="3"
            Header="Applicatie Logs"
            Margin="5">
            <views:LogView DataContext="{Binding LogVm}" />
        </GroupBox>

        <StatusBar Grid.Row="4" Padding="5,2">
            <StatusBar.ItemsPanel>
                <ItemsPanelTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                    </Grid>
                </ItemsPanelTemplate>
            </StatusBar.ItemsPanel>
            <StatusBarItem Grid.Column="0">
                <Ellipse
                    Height="15"
                    Margin="0,0,5,0"
                    Width="15">
                    <Ellipse.Style>
                        <Style TargetType="Ellipse">
                            <Setter Property="Fill" Value="Gray" />
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Idle}">
                                    <Setter Property="Fill" Value="LightGray" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Connecting}">
                                    <Setter Property="Fill" Value="Orange" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Logging}">
                                    <Setter Property="Fill" Value="Green" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Warning}">
                                    <Setter Property="Fill" Value="Yellow" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Error}">
                                    <Setter Property="Fill" Value="Red" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Loading}">
                                    <Setter Property="Fill" Value="SkyBlue" />
                                </DataTrigger>
                                <DataTrigger Binding="{Binding CurrentApplicationStatus}" Value="{x:Static enums:ApplicationStatus.Saving}">
                                    <Setter Property="Fill" Value="Plum" />
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </Ellipse.Style>
                </Ellipse>
            </StatusBarItem>
            <StatusBarItem Grid.Column="1">
                <TextBlock Text="{Binding CurrentStatusMessage}" VerticalAlignment="Center" />
            </StatusBarItem>
        </StatusBar>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\MainWindow.xaml.cs"
using System.Windows;

namespace Data_Logger.Views
{
    public partial class MainWindow
    {
        public MainWindow()
        {
            InitializeComponent();
        }
        
        private void Afsluiten_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }
    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml"
<UserControl x:Class="Data_Logger.Views.ModbusTabView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:Data_Logger.ViewModels"
             xmlns:converters="clr-namespace:Data_Logger.Converters"
             xmlns:lvc="clr-namespace:LiveChartsCore.SkiaSharpView.WPF;assembly=LiveChartsCore.SkiaSharpView.WPF"
             mc:Ignorable="d"
             d:DataContext="{d:DesignInstance Type=vm:ModbusTabViewModel, IsDesignTimeCreatable=False}"
             d:DesignHeight="600" d:DesignWidth="800">

    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
    </UserControl.Resources>

    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="120"/>  <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> <RowDefinition Height="200"/>  </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" HorizontalAlignment="Left" Margin="0,0,0,10">
            <TextBlock Text="{Binding ModbusConfig.ConnectionName}" FontSize="18" FontWeight="Bold"/>
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="IP: " FontWeight="SemiBold"/><TextBlock Text="{Binding ModbusConfig.IpAddress}"/>
                <TextBlock Text=":" Margin="2,0,2,0"/><TextBlock Text="{Binding ModbusConfig.Port}" Margin="0,0,10,0"/>
                <TextBlock Text="Unit ID: " FontWeight="SemiBold"/><TextBlock Text="{Binding ModbusConfig.UnitId}"/>
            </StackPanel>
            <StackPanel Orientation="Horizontal" Margin="0,5,0,0">
                <TextBlock Text="Status: " FontWeight="SemiBold"/>
                <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" />
                <TextBlock Text=" (Scan Interval: " Margin="5,0,0,0" FontWeight="SemiBold"/>
                <TextBlock Text="{Binding ModbusConfig.ScanIntervalSeconds}" /><TextBlock Text="s)" />
            </StackPanel>
        </StackPanel>

        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="100" Margin="0,0,5,0"/>
            <Button Content="Verbinding Verbreken" Command="{Binding DisconnectCommand}" MinWidth="100"/>
        </StackPanel>

        <TextBlock Grid.Row="2" Text="Geconfigureerde Tags (uit Instellingen):" FontWeight="SemiBold" Margin="0,10,0,2"/>
        <DataGrid Grid.Row="3" ItemsSource="{Binding ModbusConfig.TagsToMonitor}" AutoGenerateColumns="False" CanUserAddRows="False" IsReadOnly="True" MaxHeight="120" VerticalScrollBarVisibility="Auto">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*"/>
                <DataGridTextColumn Header="Adres" Binding="{Binding Address}" Width="Auto"/>
                <DataGridTextColumn Header="Register Type" Binding="{Binding RegisterType}" Width="*"/>
                <DataGridTextColumn Header="Data Type" Binding="{Binding DataType}" Width="*"/>
                <DataGridCheckBoxColumn Header="Actief" Binding="{Binding IsActive, Mode=OneWay}" Width="Auto"/>
            </DataGrid.Columns>
        </DataGrid>

        <DataGrid Grid.Row="4" ItemsSource="{Binding DataValues}" Margin="0,5,0,0" AutoGenerateColumns="False" CanUserAddRows="False" IsReadOnly="True" AlternationCount="2" VerticalScrollBarVisibility="Auto">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Tijdstempel" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" Width="Auto" SortDirection="Descending"/>
                <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*"/>
                <DataGridTextColumn Header="Waarde" Binding="{Binding FormattedValue}" Width="Auto"/>
                <DataGridTextColumn Header="Kwaliteit" Width="Auto">
                    <DataGridTextColumn.CellStyle>
                        <Style TargetType="DataGridCell">
                            <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True"><Setter Property="Foreground" Value="Green"/></DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Foreground" Value="Red"/><Setter Property="FontWeight" Value="Bold"/></DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.CellStyle>
                    <DataGridTextColumn.ElementStyle>
                        <Style TargetType="TextBlock">
                            <Setter Property="HorizontalAlignment" Value="Center"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="True"><Setter Property="Text" Value="Goed"/></DataTrigger>
                                <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Text" Value="Slecht"/></DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </DataGridTextColumn.ElementStyle>
                </DataGridTextColumn>
            </DataGrid.Columns>
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                    <Style.Triggers>
                        <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Background" Value="#FFF0F0"/></DataTrigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>
        </DataGrid>
        
        <GridSplitter Grid.Row="5" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray" ShowsPreview="True"/>
        
        <Grid Grid.Row="6">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,5,0,5">
                <TextBlock Text="Plot Tag:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                <ComboBox ItemsSource="{Binding AvailableTagNamesForPlotting}" 
                          SelectedItem="{Binding SelectedTagNameForPlotting}"
                          MinWidth="200" VerticalAlignment="Center"/>
            </StackPanel>
            <lvc:CartesianChart Grid.Row="1"
                                Series="{Binding Series}"
                                XAxes="{Binding XAxes}"
                                YAxes="{Binding YAxes}"
                                LegendPosition="Bottom" 
                                Margin="0,5,0,0"/>
        </Grid>
    </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\ModbusTabView.xaml.cs"
using System.Windows.Controls;
using Data_Logger.ViewModels;

namespace Data_Logger.Views
{
    public partial class ModbusTabView : UserControl
    {
        private ModbusTabViewModel _viewModel;
        

        public ModbusTabView()
        {
            InitializeComponent();
        }
    }
}




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml"
<UserControl x:Class="Data_Logger.Views.OpcUaTabView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:vm="clr-namespace:Data_Logger.ViewModels"
             xmlns:enums="clr-namespace:Data_Logger.Enums"
             xmlns:converters="clr-namespace:Data_Logger.Converters"
             xmlns:lvc="clr-namespace:LiveChartsCore.SkiaSharpView.WPF;assembly=LiveChartsCore.SkiaSharpView.WPF"
             x:Name="OpcUaTabViewControl" mc:Ignorable="d"
             d:DataContext="{d:DesignInstance Type=vm:OpcUaTabViewModel, IsDesignTimeCreatable=False}"
             d:DesignHeight="700" d:DesignWidth="1000">

    <UserControl.Resources>
        <converters:BooleanToConnectionStatusConverter x:Key="BooleanToConnectionStatusConverter" />
        <BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
        <converters:BooleanToForwardBackwardConverter x:Key="BooleanToForwardBackwardConverter"/>

        <Style TargetType="{x:Type TreeViewItem}">
            <Setter Property="Header" Value="{Binding DisplayName}" />
            <Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}" />
            <Setter Property="ItemsSource" Value="{Binding Children}" />
            <Setter Property="ToolTip">
                <Setter.Value>
                    <StackPanel MaxWidth="300">
                        <TextBlock Text="{Binding NodeId, StringFormat='NodeId: {0}'}" TextWrapping="Wrap"/>
                        <TextBlock Text="{Binding NodeClass, StringFormat='Klasse: {0}'}" />
                    </StackPanel>
                </Setter.Value>
            </Setter>
            <Setter Property="ContextMenu">
                <Setter.Value>
                    <ContextMenu DataContext="{Binding Path=DataContext, Source={x:Reference Name=OpcUaTabViewControl}}">
                        <MenuItem Header="[DEBUG] ContextMenu DC Type">
                            <TextBlock Text="{Binding Path=., FallbackValue='CTX MENU DC IS NULL', TargetNullValue='CTX MENU DC IS TARGETNULL'}" Foreground="Red" FontWeight="Bold"/>
                        </MenuItem>
                        <MenuItem Header="[DEBUG] AddNodeToPlotCommand Exists?">
                            <TextBlock Text="{Binding Path=AddNodeToPlotCommand, FallbackValue='AddNodeToPlotCMD NOT Found', TargetNullValue='AddNodeToPlotCMD is TargetNull'}" Foreground="Red" FontWeight="Bold"/>
                        </MenuItem>
                        <MenuItem Header="Voeg toe aan Monitoring"
                                  Command="{Binding AddSelectedNodeToMonitoringCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                        
                        <MenuItem Header="Verwijder van Monitoring"
                                  Command="{Binding RemoveSelectedNodeFromMonitoringCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                        
                        <MenuItem Header="Lees Huidige Waarde"
                                  Command="{Binding ReadSelectedNodeValueCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                        
                        <Separator/>
                        <MenuItem Header="Plot deze Node"
                                  Command="{Binding AddNodeToPlotCommand}"
                                  CommandParameter="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type ContextMenu}}}"/>                    
                    </ContextMenu>
                </Setter.Value>
            </Setter>
        </Style>

        <HierarchicalDataTemplate DataType="{x:Type vm:OpcUaNodeViewModel}" ItemsSource="{Binding Children}">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding DisplayName}" />
                <TextBlock Text="{Binding NodeClass, StringFormat=' ({0})'}" Foreground="Gray" FontStyle="Italic" Margin="5,0,0,0" FontSize="10"/>
            </StackPanel>
        </HierarchicalDataTemplate>

        <DataTemplate x:Key="ChartTabContentTemplate" DataType="{x:Type vm:ChartTabViewModel}">
            <lvc:CartesianChart Series="{Binding Series}"
                                XAxes="{Binding XAxes}"
                                YAxes="{Binding YAxes}"
                                LegendPosition="Right"
                                Margin="2"/>
        </DataTemplate>

        <DataTemplate x:Key="ChartTabHeaderTemplate" DataType="{x:Type vm:ChartTabViewModel}">
            <StackPanel Orientation="Horizontal">
                <TextBlock Text="{Binding Header}" ToolTip="{Binding NodeIdToPlot, StringFormat='NodeId: {0}'}"/>
                <Button Margin="5,0,0,0" Padding="3,0" FontSize="10" FontWeight="Bold" VerticalAlignment="Center" Background="Transparent" BorderThickness="0"
                        Command="{Binding DataContext.ClosePlotTabCommand, RelativeSource={RelativeSource AncestorType={x:Type TabControl}}}"
                        CommandParameter="{Binding}"
                        ToolTip="Sluit deze grafiek tab">
                    <TextBlock Text="&#x2715;" Foreground="DimGray"/>
                </Button>
            </StackPanel>
        </DataTemplate>

        <ObjectDataProvider x:Key="OpcUaDataTypeEnumValuesForGrid" MethodName="GetValues" ObjectType="{x:Type sys:Enum}"
                            xmlns:sys="clr-namespace:System;assembly=mscorlib">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:OpcUaDataType"/>
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <Style x:Key="DataGridButtonStyleInCell" TargetType="Button">
            <Setter Property="Padding" Value="3,1"/>
            <Setter Property="Margin" Value="1"/>
            <Setter Property="MinWidth" Value="50"/>
            <Setter Property="FontSize" Value="10"/>
        </Style>

    </UserControl.Resources>

    <Grid Margin="5">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Margin="0,0,0,5">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <StackPanel Grid.Column="0" HorizontalAlignment="Left" Margin="0,0,20,0">
                    <TextBlock Text="{Binding OpcUaConfig.ConnectionName}" FontSize="16" FontWeight="Bold"/>
                    <TextBlock Text="{Binding OpcUaConfig.EndpointUrl, StringFormat='Endpoint: {0}'}" FontSize="10" ToolTip="{Binding OpcUaConfig.EndpointUrl}" TextTrimming="CharacterEllipsis"/>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="Status: " FontSize="10" FontWeight="SemiBold"/>
                        <TextBlock Text="{Binding IsConnected, Converter={StaticResource BooleanToConnectionStatusConverter}}" FontSize="10" />
                    </StackPanel>
                </StackPanel>
                <WrapPanel Grid.Column="1" Orientation="Horizontal" HorizontalAlignment="Left" VerticalAlignment="Top">
                    <Button Content="Verbinden" Command="{Binding ConnectCommand}" MinWidth="70" Margin="0,0,5,2"/>
                    <Button Content="Verbreken" Command="{Binding DisconnectCommand}" MinWidth="70" Margin="0,0,5,2"/>
                    <Button Content="Lees Config Tags" Command="{Binding ReadAllConfiguredTagsCommand}" MinWidth="100" Margin="0,0,5,2" ToolTip="Leest waarden van tags in de huidige monitoring configuratie."/>
                    <Button Content="Refresh Address Space" Command="{Binding LoadAddressSpaceCommand}" MinWidth="100" Margin="0,0,5,2"/>
                    <TextBlock Text="Laden..." VerticalAlignment="Center" Margin="5,0,0,0" Visibility="{Binding IsBrowse, Converter={StaticResource BooleanToVisibilityConverter}}"/>
                </WrapPanel>
            </Grid>
            <TextBlock Text="{Binding LastReadNodeValue}" FontSize="10" TextWrapping="Wrap" Margin="0,5,0,0" MinHeight="15" FontStyle="Italic"/>
        </StackPanel>

        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="0.35*" MinWidth="280"/> <ColumnDefinition Width="Auto"/>             <ColumnDefinition Width="0.65*" MinWidth="350"/> </Grid.ColumnDefinitions>

            <TabControl Grid.Column="0" Margin="0,0,2,0">
                <TabItem Header="Address Space">
                    <Border BorderBrush="LightGray" BorderThickness="1">
                        <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto">
                            <TreeView ItemsSource="{Binding RootNodes}" Padding="2"
                                      x:Name="OpcUaNodeTreeView" 
                                      SelectedItemChanged="TreeView_SelectedItemChanged"/>
                        </ScrollViewer>
                    </Border>
                </TabItem>
                <TabItem Header="Attributes &amp; References">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    </Grid.RowDefinitions>

                        <TextBlock Grid.Row="0" Text="Node Attributen:" FontWeight="Bold" Margin="5,5,5,2"/>
                        <ListView Grid.Row="1" ItemsSource="{Binding SelectedNodeAttributes}" Margin="5,0,5,5" AlternationCount="2">
                            <ListView.ItemContainerStyle>
                                <Style TargetType="ListViewItem">
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding IsGood}" Value="False">
                                            <Setter Property="Foreground" Value="Red"/>
                                        </DataTrigger>
                                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                                            <Setter Property="Background" Value="#F5F5F5" />
                                        </Trigger>
                                    </Style.Triggers>
                                </Style>
                            </ListView.ItemContainerStyle>
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Attribuut" DisplayMemberBinding="{Binding AttributeName}" Width="150"/>
                                    <GridViewColumn Header="Waarde" DisplayMemberBinding="{Binding Value}" Width="Auto"/>
                                    <GridViewColumn Header="Status" DisplayMemberBinding="{Binding StatusCodeDisplay}" Width="100"/>
                                </GridView>
                            </ListView.View>
                        </ListView>

                        <GridSplitter Grid.Row="2" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray" ShowsPreview="True"/>

                        <TextBlock Grid.Row="3" Text="Node Referenties:" FontWeight="Bold" Margin="5,5,5,2"/>
                        <ListView Grid.Row="4" ItemsSource="{Binding SelectedNodeReferences}" Margin="5,0,5,5" AlternationCount="2">
                             <ListView.ItemContainerStyle>
                                <Style TargetType="ListViewItem">
                                    <Style.Triggers>
                                        <Trigger Property="ItemsControl.AlternationIndex" Value="1">
                                            <Setter Property="Background" Value="#F5F5F5" />
                                        </Trigger>
                                    </Style.Triggers>
                                </Style>
                            </ListView.ItemContainerStyle>
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Type" DisplayMemberBinding="{Binding ReferenceTypeDisplay}" Width="150"/>
                                    <GridViewColumn Header="Richting" Width="70">
                                        <GridViewColumn.CellTemplate>
                                            <DataTemplate>
                                                <TextBlock Text="{Binding IsForward, Converter={StaticResource BooleanToForwardBackwardConverter}}"/>
                                            </DataTemplate>
                                        </GridViewColumn.CellTemplate>
                                    </GridViewColumn>
                                    <GridViewColumn Header="Target Naam" DisplayMemberBinding="{Binding TargetDisplayName}" Width="Auto"/>
                                    <GridViewColumn Header="Target Klasse" DisplayMemberBinding="{Binding TargetNodeClass}" Width="100"/>
                                    </GridView>
                            </ListView.View>
                        </ListView>
                        
                        <TextBlock Grid.Row="1" Grid.RowSpan="4" Text="Details laden..." 
                                   HorizontalAlignment="Center" VerticalAlignment="Center"
                                   Visibility="{Binding IsLoadingNodeDetails, Converter={StaticResource BooleanToVisibilityConverter}}"
                                   IsEnabled="{Binding IsLoadingNodeDetails}"/>
                    </Grid>
                </TabItem>
            </TabControl>

            <GridSplitter Grid.Column="1" Width="5" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Background="LightGray"/>

            <Grid Grid.Column="2" Margin="2,0,0,0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="0.4*" MinHeight="150"/> <RowDefinition Height="Auto"/>               <RowDefinition Height="0.6*" MinHeight="150"/> </Grid.RowDefinitions>

                <GroupBox Grid.Row="0" Header="Gemonitorde OPC UA Tags (Configuratie Live Waarden)" Padding="2"
                          Visibility="{Binding IsConnected, Converter={StaticResource BooleanToVisibilityConverter}}"> 
                    <DataGrid ItemsSource="{Binding OpcUaConfig.TagsToMonitor}"
                              AutoGenerateColumns="False"
                              CanUserAddRows="False" 
                              CanUserDeleteRows="False" 
                              AlternationCount="2" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto"
                              SelectionUnit="FullRow" SelectionMode="Single">
                        <DataGrid.Columns>
                            <DataGridTextColumn Header="Tag Naam" Binding="{Binding TagName}" Width="*" IsReadOnly="True"/>
                            <DataGridTextColumn Header="NodeID" Binding="{Binding NodeId}" Width="1.5*" IsReadOnly="True"/>
                            <DataGridTextColumn Header="Data Type (Config)" Binding="{Binding DataType, Mode=OneWay}" Width="Auto" IsReadOnly="True"/>
                            
                            <DataGridTextColumn Header="Sampling (ms)" Width="Auto">
                                <DataGridTextColumn.Binding>
                                    <Binding Path="SamplingInterval" UpdateSourceTrigger="LostFocus">
                                        <Binding.ValidationRules><ExceptionValidationRule/></Binding.ValidationRules>
                                    </Binding>
                                </DataGridTextColumn.Binding>
                                <DataGridTextColumn.EditingElementStyle>
                                    <Style TargetType="TextBox">
                                        <EventSetter Event="LostFocus" Handler="ConfigTagTextBox_LostFocus_SaveChanges"/>
                                    </Style>
                                </DataGridTextColumn.EditingElementStyle>
                            </DataGridTextColumn>

                            <DataGridCheckBoxColumn Header="Actief" Width="50">
                                <DataGridCheckBoxColumn.Binding>
                                    <Binding Path="IsActive" UpdateSourceTrigger="PropertyChanged"/>
                                </DataGridCheckBoxColumn.Binding>
                                <DataGridCheckBoxColumn.CellStyle>
                                    <Style TargetType="DataGridCell">
                                        <EventSetter Event="CheckBox.Checked" Handler="ConfigTagCheckBox_Changed_SaveChanges"/>
                                        <EventSetter Event="CheckBox.Unchecked" Handler="ConfigTagCheckBox_Changed_SaveChanges"/>
                                        <Setter Property="HorizontalAlignment" Value="Center"/>
                                    </Style>
                                </DataGridCheckBoxColumn.CellStyle>
                            </DataGridCheckBoxColumn>

                            <DataGridTextColumn Header="Waarde" Binding="{Binding FormattedLiveValue}" Width="*" IsReadOnly="True"/>
                            <DataGridTextColumn Header="Tijdstempel" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff', Mode=OneWay}" Width="Auto" IsReadOnly="True"/>
                            <DataGridTextColumn Header="Kwaliteit" Width="Auto" IsReadOnly="True">
                                <DataGridTextColumn.ElementStyle>
                                    <Style TargetType="TextBlock">
                                        <Setter Property="HorizontalAlignment" Value="Center"/>
                                        <Style.Triggers>
                                            <DataTrigger Binding="{Binding IsGoodQuality}" Value="True"><Setter Property="Text" Value="Goed"/><Setter Property="Foreground" Value="Green"/></DataTrigger>
                                            <DataTrigger Binding="{Binding IsGoodQuality}" Value="False"><Setter Property="Text" Value="Slecht"/><Setter Property="Foreground" Value="Red"/></DataTrigger>
                                        </Style.Triggers>
                                    </Style>
                                </DataGridTextColumn.ElementStyle>
                                <DataGridTextColumn.CellStyle>
                                     <Style TargetType="DataGridCell">
                                        <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/>
                                     </Style>
                                </DataGridTextColumn.CellStyle>
                            </DataGridTextColumn>

                            <DataGridTemplateColumn Header="Plot" Width="Auto">
                                <DataGridTemplateColumn.CellTemplate>
                                    <DataTemplate>
                                        <Button Content="Plot" Style="{StaticResource DataGridButtonStyleInCell}"
                                                Command="{Binding DataContext.PlotConfiguredTagCommand, RelativeSource={RelativeSource AncestorType={x:Type UserControl}}}"
                                                CommandParameter="{Binding}"/>
                                    </DataTemplate>
                                </DataGridTemplateColumn.CellTemplate>
                            </DataGridTemplateColumn>
                            <DataGridTemplateColumn Header="Actie" Width="Auto">
                                <DataGridTemplateColumn.CellTemplate>
                                    <DataTemplate>
                                        <Button Content="Stop" ToolTip="Stop Monitoring" Style="{StaticResource DataGridButtonStyleInCell}"
                                                Command="{Binding DataContext.UnmonitorTagCommand, RelativeSource={RelativeSource AncestorType={x:Type UserControl}}}"
                                                CommandParameter="{Binding}"/>
                                    </DataTemplate>
                                </DataGridTemplateColumn.CellTemplate>
                            </DataGridTemplateColumn>
                        </DataGrid.Columns>
                         <DataGrid.RowStyle>
                            <Style TargetType="DataGridRow">
                                <Setter Property="ToolTip" Value="{Binding ErrorMessage}"/> <Style.Triggers>
                                    <DataTrigger Binding="{Binding IsGoodQuality}" Value="False">
                                        </DataTrigger>
                                </Style.Triggers>
                            </Style>
                        </DataGrid.RowStyle>
                    </DataGrid>
                </GroupBox>

                <GridSplitter Grid.Row="1" Height="5" HorizontalAlignment="Stretch" VerticalAlignment="Center" Background="LightGray"/>

                <TabControl Grid.Row="2" Margin="0,2,0,0"
                            ItemsSource="{Binding PlottedSeriesViewModels}"
                            SelectedItem="{Binding SelectedPlotTab}"
                            ItemTemplate="{StaticResource ChartTabHeaderTemplate}"
                            ContentTemplate="{StaticResource ChartTabContentTemplate}">
                    <TabControl.Resources>
                         <Style TargetType="TabItem"><Setter Property="Padding" Value="5,2"/></Style>
                    </TabControl.Resources>
                </TabControl>
            </Grid>
        </Grid>
    </Grid>
</UserControl>



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\OpcUaTabView.xaml.cs"

using System.Windows;
using Data_Logger.ViewModels;
using System.Windows.Controls;
using Data_Logger.Models;

namespace Data_Logger.Views
{
    public partial class OpcUaTabView : UserControl
    {
        private OpcUaTabViewModel _viewModel;

        public OpcUaTabView()
        {
            InitializeComponent();
        }
        
        private void TreeView_SelectedItemChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            if (this.DataContext is OpcUaTabViewModel viewModel && e.NewValue is OpcUaNodeViewModel selectedNode)
            {
                viewModel.SelectedOpcUaNode = selectedNode;
            }
            else if (this.DataContext is OpcUaTabViewModel viewModelWithNull && e.NewValue == null) 
            {
                viewModelWithNull.SelectedOpcUaNode = null;
            }
        }

        private void ConfigTagTextBox_LostFocus_SaveChanges(object sender, RoutedEventArgs e)
        {
            if (this.DataContext is OpcUaTabViewModel viewModel && sender is FrameworkElement element)
            {
                if (element.DataContext is OpcUaTagConfig tagConfig) 
                {
                    viewModel.SaveChangesForTagConfig(tagConfig);
                }
            }
        }

        
        private void ConfigTagCheckBox_Changed_SaveChanges(object sender, RoutedEventArgs e)
        {
            if (this.DataContext is OpcUaTabViewModel viewModel && sender is FrameworkElement element)
            {
                if (element.DataContext is OpcUaTagConfig tagConfig)
                {
                    viewModel.SaveChangesForTagConfig(tagConfig);
                }
            }
        }

    }
}



// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml"
<Window
    Height="500"
    MinHeight="400"
    MinWidth="600"
    Title="Instellingen"
    Width="800"
    WindowStartupLocation="CenterOwner"
    d:DataContext="{d:DesignInstance Type=vm:SettingsViewModel,
                                     IsDesignTimeCreatable=False}"
    mc:Ignorable="d"
    x:Class="Data_Logger.Views.SettingsView"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:System="clr-namespace:System;assembly=mscorlib"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:enums="clr-namespace:Data_Logger.Enums"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:models="clr-namespace:Data_Logger.Models"
    xmlns:vm="clr-namespace:Data_Logger.ViewModels"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:Data_Logger.Views"
    xmlns:opcua="clr-namespace:Opc.Ua;assembly=Opc.Ua.Core">
    <Window.Resources>
        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusRegisterTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusRegisterType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider
            MethodName="GetValues"
            ObjectType="{x:Type System:Enum}"
            x:Key="ModbusDataTypeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:ModbusDataType" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>
        
        <ObjectDataProvider x:Key="OpcUaDataTypeEnumValues" MethodName="GetValues" ObjectType="{x:Type System:Enum}">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="enums:OpcUaDataType"/>
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>
        
        <ObjectDataProvider MethodName="GetValues"
                            ObjectType="{x:Type System:Enum}"
                            x:Key="MessageSecurityModeEnumValues">
            <ObjectDataProvider.MethodParameters>
                <x:Type TypeName="opcua:MessageSecurityMode" />
            </ObjectDataProvider.MethodParameters>
        </ObjectDataProvider>

        <ObjectDataProvider ObjectType="{x:Type local:OpcUaSecurityPolicyValues}"
                            MethodName="GetInstance"
                            x:Key="SecurityPolicyUriValues"/>

        <DataTemplate DataType="{x:Type models:OpcUaConnectionConfig}">
        <ScrollViewer VerticalScrollBarVisibility="Auto">
            <StackPanel Margin="10">
                <TextBlock Text="OPC UA Verbinding Details" FontWeight="Bold" Margin="0,0,0,10"/>
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" MinWidth="150"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

                    <Label Grid.Row="0" Grid.Column="0" Content="Naam:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="0" Grid.Column="1" Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                    <Label Grid.Row="1" Grid.Column="0" Content="Endpoint URL:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding EndpointUrl, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                    <Label Grid.Row="2" Grid.Column="0" Content="Security Mode:" VerticalAlignment="Center"/>
                    <ComboBox Grid.Row="2" Grid.Column="1" Margin="5"
                              ItemsSource="{Binding Source={StaticResource MessageSecurityModeEnumValues}}"
                              SelectedValue="{Binding SecurityMode, UpdateSourceTrigger=PropertyChanged}"/>


                    <Label Grid.Row="3" Grid.Column="0" Content="Security Policy:" VerticalAlignment="Center"/>
                    <ComboBox Grid.Row="3" Grid.Column="1" Margin="5"
                              ItemsSource="{Binding Source={StaticResource SecurityPolicyUriValues}}"
                              SelectedValue="{Binding SecurityPolicyUri, UpdateSourceTrigger=PropertyChanged}"/>

                    <Label Grid.Row="4" Grid.Column="0" Content="Gebruikersnaam:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="4" Grid.Column="1" Text="{Binding UserName, UpdateSourceTrigger=PropertyChanged, ValidatesOnExceptions=True, NotifyOnValidationError=True}" Margin="5"/>

                    <Label Grid.Row="5" Grid.Column="0" Content="Wachtwoord:" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="5" Grid.Column="1" Text="{Binding Password, UpdateSourceTrigger=PropertyChanged, ValidatesOnExceptions=True, NotifyOnValidationError=True}" Margin="5"/>


                    <Label Grid.Row="6" Grid.Column="0" Content="Scan Interval (sec):" VerticalAlignment="Center"/>
                    <TextBox Grid.Row="6" Grid.Column="1" Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" Margin="5"/>

                    <CheckBox Grid.Row="7" Grid.Column="1" IsChecked="{Binding IsEnabled}" Content="Actief" Margin="5" VerticalAlignment="Center"/>
                </Grid>
            </StackPanel>
        </ScrollViewer>
    </DataTemplate>

        <DataTemplate DataType="{x:Type models:ModbusTcpConnectionConfig}">
            <ScrollViewer VerticalScrollBarVisibility="Auto">
                <StackPanel Margin="10">
                    <TextBlock
                        FontWeight="Bold"
                        Margin="0,0,0,10"
                        Text="Modbus TCP Verbinding Details" />
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition MinWidth="150" Width="Auto" />
                            <ColumnDefinition Width="*" />
                        </Grid.ColumnDefinitions>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                            <RowDefinition Height="Auto" />
                        </Grid.RowDefinitions>

                        <Label
                            Content="Naam:"
                            Grid.Column="0"
                            Grid.Row="0"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="0"
                            Margin="5"
                            Text="{Binding ConnectionName, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="IP Adres:"
                            Grid.Column="0"
                            Grid.Row="1"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="1"
                            Margin="5"
                            Text="{Binding IpAddress, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Poort:"
                            Grid.Column="0"
                            Grid.Row="2"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="2"
                            Margin="5"
                            Text="{Binding Port, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Unit ID:"
                            Grid.Column="0"
                            Grid.Row="3"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="3"
                            Margin="5"
                            Text="{Binding UnitId, UpdateSourceTrigger=PropertyChanged}" />

                        <Label
                            Content="Scan Interval (sec):"
                            Grid.Column="0"
                            Grid.Row="4"
                            VerticalAlignment="Center" />
                        <TextBox
                            Grid.Column="1"
                            Grid.Row="4"
                            Margin="5"
                            Text="{Binding ScanIntervalSeconds, UpdateSourceTrigger=PropertyChanged}" />

                        <CheckBox
                            Content="Actief"
                            Grid.Column="1"
                            Grid.Row="5"
                            IsChecked="{Binding IsEnabled}"
                            Margin="5"
                            VerticalAlignment="Center" />
                    </Grid>
                </StackPanel>
            </ScrollViewer>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition MinWidth="200" Width="250" />
            <ColumnDefinition Width="5" />
            <ColumnDefinition Width="*" />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto" />
            <RowDefinition Height="*" />
            <RowDefinition Height="Auto" />
        </Grid.RowDefinitions>

        <ToolBar
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="0"
            Padding="5">
            <Button
                Command="{Binding AddOpcUaConnectionCommand}"
                Content="Nieuwe OPC UA"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding AddModbusTcpConnectionCommand}"
                Content="Nieuwe Modbus TCP"
                Margin="0,0,5,0" />
            <Button
                Command="{Binding RemoveConnectionCommand}"
                Content="Verwijder Geselecteerde"
                Foreground="Red" />
        </ToolBar>

        <GroupBox
            Grid.Column="0"
            Grid.Row="1"
            Header="Verbindingen"
            Margin="5">
            <ListView
                DisplayMemberPath="ConnectionName"
                ItemsSource="{Binding WorkingConnections}"
                SelectedItem="{Binding SelectedConnection}" />
        </GroupBox>

        <GridSplitter
            Background="LightGray"
            Grid.Column="1"
            Grid.Row="1"
            HorizontalAlignment="Stretch"
            VerticalAlignment="Stretch"
            Width="5" />

        <GroupBox
            Grid.Column="2"
            Grid.Row="1"
            Header="Details"
            Margin="5">
            <ContentControl Content="{Binding SelectedConnection}" />
        </GroupBox>

        <StackPanel
            Grid.Column="0"
            Grid.ColumnSpan="3"
            Grid.Row="2"
            HorizontalAlignment="Right"
            Margin="10"
            Orientation="Horizontal">
            <Button
                Command="{Binding SaveCommand}"
                Content="Opslaan"
                IsDefault="True"
                Margin="0,0,10,0"
                MinWidth="80" />
            <Button
                Command="{Binding CancelCommand}"
                Content="Annuleren"
                IsCancel="True"
                MinWidth="80" />
        </StackPanel>
    </Grid>
</Window>




// $`$$: "C:\Development\Projects\Afstudeeropdracht\Data Logger\Views\SettingsView.xaml.cs"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using Opc.Ua;

namespace Data_Logger.Views
{
    public partial class SettingsView : Window
    {
        public SettingsView()
        {
            InitializeComponent();
        }
    }
    
    public static class OpcUaSecurityModeValues
    {
        
        public static IEnumerable<MessageSecurityMode> Instance => 
            Enum.GetValues(typeof(MessageSecurityMode)).Cast<MessageSecurityMode>();
    }

    public static class OpcUaSecurityPolicyValues
    {
        public static IEnumerable<string> GetInstance()
        {
            return new List<string>
            {
                SecurityPolicies.None,
                SecurityPolicies.Basic256Sha256,
            };
        }
    }
}



