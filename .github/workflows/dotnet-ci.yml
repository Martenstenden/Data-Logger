name: .NET Framework CI/CD for Data Logger

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  build-and-test: # Samengevoegde naam, of je kunt ze apart houden
    name: Build & Test (.NET Framework)
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v1 # Controleer voor de laatste versie (v1 is een voorbeeld)
      with:
        nuget-version: 'latest'

    - name: Add msbuild to PATH
      uses: microsoft/setup-msbuild@v1.1 # Controleer voor de laatste versie

    - name: Restore NuGet packages for Solution
      # Pad relatief aan de root van de repository (waar .git en .github staan)
      # Als je solution file 'Data Logger/Data Logger.sln' heet:
      run: nuget restore "Data Logger/Data Logger.sln" -SolutionDirectory "Data Logger"
      # Als je solution file 'Data Logger.sln' in de root staat:
      # run: nuget restore "Data Logger.sln" -SolutionDirectory .

    - name: Build Solution
      run: msbuild "Data Logger/Data Logger.sln" /p:Configuration=Release /p:Platform="Any CPU"
      # Pas pad aan als je solution elders staat.

    - name: Run Unit Tests (excluding IntegrationTests)
      shell: pwsh
      run: |
        $vstestPaths = @(
            (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft Visual Studio\2022\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft Visual Studio\2022\Professional\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles} -ChildPath "Microsoft Visual Studio\2022\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles} -ChildPath "Microsoft Visual Studio\2022\Professional\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles} -ChildPath "Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"),
        
            (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft Visual Studio\2019\Enterprise\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft Visual Studio\2019\Professional\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe"),
            (Join-Path -Path ${env:ProgramFiles(x86)} -ChildPath "Microsoft Visual Studio\2019\Community\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe")
        )
        $vstestPath = $vstestPaths | Where-Object { Test-Path $_ -PathType Leaf } | Select-Object -First 1 # -PathType Leaf controleert of het een bestand is

        if (-not $vstestPath) {
            Write-Error "VSTest.Console.exe niet gevonden."
            # Probeer VSTest te vinden via 'where.exe' als fallback
            $vstestPath = (where.exe vstest.console.exe | Select-Object -First 1)
            if (-not $vstestPath) {
                 Write-Error "VSTest.Console.exe ook niet gevonden via where.exe. Zorg dat Visual Studio Test Platform is ge√Ønstalleerd op de runner."
                 exit 1
            }
        }
        Write-Host "VSTest.Console.exe gevonden op: $vstestPath"
        
        # Pad naar je test DLL, relatief aan de root van de repository (Data-Logger)
        # Dit pad moet overeenkomen met de output van je build stap.
        $testDllPath = "DataLogger.Tests/bin/Release/DataLogger.Tests.dll" 
        # OF als je solution in een submap "Data Logger" staat:
        # $testDllPath = "Data Logger/DataLogger.Tests/bin/Release/DataLogger.Tests.dll"

        $unitTestFilter = '/TestCaseFilter:"TestCategory!=IntegrationTest"'
        $unitTestResultFile = "unit_test_results.trx"

        Write-Host "Unit Test DLL Pad: $testDllPath"
        Write-Host "Unit Test Filter: $unitTestFilter"
        & $vstestPath $testDllPath /Logger:"trx;LogFileName=$unitTestResultFile" $unitTestFilter /EnableCodeCoverage /InIsolation

    - name: Upload Unit Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: unit-test-results-framework
        path: unit_test_results.trx # VSTest plaatst dit in de werkdirectory

    # Docker gerelateerde stappen voor integratietests
    # Deze stappen veronderstellen dat de Windows runner Docker CLI kan gebruiken voor Linux containers
    - name: Check Docker is available (Integration Test Prerequisite)
      shell: pwsh
      run: |
        docker --version
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Docker CLI niet gevonden of werkt niet. Sla integratietests over of markeer als mislukt."
          # exit 1 # Of laat het doorgaan en de tests falen
        }

    - name: Pull OPC UA Reference Server Image (Integration Test Prerequisite)
      shell: pwsh
      run: docker pull ghcr.io/opcfoundation/uanetstandard/refserver:latest

    - name: Run Integration Tests (requires Docker)
      shell: pwsh
      run: |
        # $vstestPath zou nog steeds moeten zijn ingesteld vanuit de vorige PowerShell run stap
        # Als dat niet het geval is, herhaal de logica om $vstestPath hier te vinden.
        if (-not $vstestPath) {
            $vstestPaths = @(
                Join-Path ${env:ProgramFiles(x86)} "Microsoft Visual Studio\2022\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe",
                # ... (rest van de paden zoals hierboven) ...
                Join-Path ${env:ProgramFiles(x86)} "Microsoft Visual Studio\2019\Community\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe"
            )
            $vstestPath = $vstestPaths | Where-Object { Test-Path $_ } | Select-Object -First 1
            if (-not $vstestPath) {
                $vstestPath = (where.exe vstest.console.exe | Select-Object -First 1)
                if (-not $vstestPath) { Write-Error "VSTest.Console.exe niet gevonden voor integratietests."; exit 1 }
            }
        }
        Write-Host "VSTest.Console.exe (voor integratietests) gevonden op: $vstestPath"

        $testDllPath = "DataLogger.Tests/bin/Release/DataLogger.Tests.dll" # Controleer dit pad
        $integrationTestFilter = '/TestCaseFilter:"TestCategory=IntegrationTest"'
        $integrationTestResultFile = "integration_test_results.trx"

        Write-Host "Integration Test DLL Pad: $testDllPath"
        Write-Host "Integration Test Filter: $integrationTestFilter"
        
        # De OneTimeSetUp in je test assembly zal DockerTestHelper aanroepen
        # om de container te starten en te wachten.
        & $vstestPath $testDllPath /Logger:"trx;LogFileName=$integrationTestResultFile" $integrationTestFilter /EnableCodeCoverage /InIsolation
      timeout-minutes: 20 # Geef integratietests meer tijd

    - name: Upload Integration Test Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: integration-test-results-framework
        path: integration_test_results.trx
